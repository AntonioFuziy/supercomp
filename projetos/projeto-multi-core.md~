# Multi-core

Neste semeste trabalharemos com um problema bastante familiar para os alunos do 8/9 semestre: a atribuição de alunos a projetos no Projeto Final de Engenharia. 

* Cada aluno escolhe cinco opções de projetos de acordo com sua preferência. 
* Cada projeto receberá exatamente três alunos. 

Uma solução para este problema é uma atribuição de três alunos para cada projeto. Claramente algumas soluções são melhores pois maior quantidade de alunos está alocada em projetos que tem maior preferência. Para quantificar esta qualidade de cada solução vamos adotar a seguinte estratégia:

* a satisfação individual de um aluno, dada sua atribuição a um projeto é 
    1. $5^2 = 25$ se foi colocado em sua primeira opção
    1. ....
    1. $2^2 = 4$ se foi colocado em sua quarta opção
    1. $1$ se foi colocado em sua última opção
    1. $0$ se não foi possível colocá-lo em nenhuma de suas opções. 
* a satisfação "global" de uma solução é a soma da satisfação individual de todos alunos. 

Desta maneira, gostaríamos de encontrar a melhor solução (a que possui maior satisfação global) dados o número de alunos, o número de projetos e até 5 opções de projetos em ordem de preferência para cada aluno.

## Justificativa

Apesar de parecer simples, este problema é *NP-completo*: não existe um método que encontra a solução com maior satisfação global em tempo polinomial. Além disso, não existe uma maneira que verifique se uma solução é a melhor possível em tempo polinomial. Ou seja, trabalhar com este problema invariavelmente envolverá enumerar todas as possibilidades. Claramente este é um problema em que SuperComputação é necessária! Veremos que técnicas de computação paralela podem diminuir consideravelmente o tempo de execução de nosso programa. 

Outra fonte de ideias para acelerar a resolução deste problema é a utilização de técnicas de otimização discreta, que são nada mais do que explorar alguma característica do problema que estamos tratando para melhorar nossas soluções. Podemos usá-las para encontrar boas soluções sem enumerar todas ou para evitar enumerar soluções que com certeza não são as ótimas. Porém, nem sempre é fácil paralelizar estas técnicas e este será um dos desafios dos conceitos mais avançados neste projeto. 

Em resumo, este projeto tem como objetivo encontrar as seguintes situações:

* paralelizar um programa que use uma técnica de resolução ruim não resultará em grandes ganhos de tempo
* paralelizar um programa que use uma técnica de resolução inteligente pode ser difícil, mas retorna ganhos muito mais significativos

É provável vermos um programa single-core inteligente sendo mais rápido que um programa multi-core simplório. 

## Entrada e saída

O formato de entrada do programa estará no formato abaixo.

```
n_alunos n_projetos
p1 p2 p3 p4 p5
..... # repetido n_alunos vezes
```

* `n_alunos` é o número de alunos
* `n_projetos` é o número de projetos existentes
* cada linha seguinte representa as cinco prioridades de um aluno.    
* `p1, ..., p5` é um número entre `0` e `n_projetos-1`, sem repetições

A saída do programa deverá estar no formato abaixo.

```
satisfacao opt
pa1 pa2 pa3 ... pa(n_alunos)
```

* `satisfacao`
* `opt` é `1` se a solução encontrada é a melhor possível, `0` caso contrário
* `pa(i) ` contém a qual projeto o aluno `i` foi atribuído

A pasta [code/projeto](...) contém exemplos de entradas e saída esperadas. Seu programa deverá funcionar com estas entradas e produzir saídas **exatamente** neste formato. 

!!! note "Avisos"
    * Se existirem duas soluções com mesma satisfação qualquer uma pode ser retornada.  
    * Informações de *debug* devem ser enviadas para a saída de erros. A saída de seu programa deverá estar **exatamente** no formato mostrado na seção anterior.

### Simplificações:

Seu programa pode assumir o seguinte:

1. `n_alunos` é divisível por 3
1. `n_projetos` é exatamente `n_alunos/3`

Isto facilita muito o problema, pois nunca conseguimos montar uma solução inválida nem precisamos levar em conta a distribuição de alunos ao criar soluções.

## Entregas

Para facilitar a realização deste projeto ele será dividido em duas partes. 

A primeira parte focará em criar uma solução que resolve este problema este C++ e compará-la com uma solução inocente em Python. Isto inclui estudar métodos de resolução do problema e implementá-los em C++. 

A segunda parte tratará da paralelização destes métodos usando as técnicas mostradas em sala de aula. O programa deverá ser escrito usando OpenMP e deverá escalar o mais naturalmente possível conforme o número de cores aumenta.

### Parte 1: estratégias de resolução (16/03)

O arquivo `solucao-ingenua.py` contém uma solução simplista escrita em Python. Este programa sempre encontra a melhor solução, mas é **extremamente ingênuo**. Por isso, ele também é **extremamente lento**. 

**Implementação em C++**: 

Nosso primeiro passo será implementar esse mesmo programa em C++. O objetivo desta parte será implementar soluções para o problema sem nós preocuparmos com paralelismo e o primeiro passo para isso é implementar o algoritmo que está em Python em C++.

**Busca local**:

A estratégia de busca local visa encontrar boas soluções em um processo de melhora iterativa. A partir de uma solução inicial (que pode ser aleatória), tentamos aplicar uma heurística (truque) que pode melhorar a solução (mas nunca piorar). Note que isto somente garante que a solução irá melhorar iterativamente, porém não garante que eventualmente chegaremos na melhor solução possível. Além dissto,

1. a solução encontrada muda conforme a solução inicial
1. nem todas as soluções são possíveis de serem encontradas. 

Uma boa heurística geralmente é baseada em alguma característica da solução ótima. Para este problema usaremos a seguinte propriedade

> não existe nenhuma dupla de alunos que, se for trocada de projeto, melhora a satisfação global.

Claramente se a solução é a melhor possível então isto não pode acontecer. Nosso algoritmo será

1. escolha uma atribuição aluno-projeto válida aleatoriamente
1. verifique se existe um par de alunos cuja troca de projeto melhore a satisfação global
    * se existir faça a troca e repita o teste acima
    * se não existir retorne a solução atual

A implementação deste algoritmo resulta em um programa que encontra soluções razoáveis muito rapidamente. 

**Branch and Bound**:

O algoritmo 

**Heurísticas de busca**:

O algoritmo recursivo implementado em Python testa todas as possibilidades de maneira bastante inocente. Ele não leva em conta, por exemplo, as preferência dos alunos ou o fato de alocar um aluno em uma opção com satisfação 0 não mudar o valor global da solução. 

Este item envolve modificar a ordem que as soluções são analisadas de maneira a tentar encontrar primeiro as soluções de maior satisfação global. Combinada com o item anterior, está estratégia pode diminuir consideravelmente o tempo de execução. 

Será obrigatório implementar este item em cima do branch and bound.

### Parte 2: Paralelismo

Cada item da parte anterior deverá ser paralelizado usando OpenMP. Isto deverá ser feito da maneira mais escalável possível: o tempo de execução do programa deverá diminuir conforme o número de cores aumenta. 

Este item é o principal da entrega, mas ele se apoia inteiramente em cima dos itens da primeira entrega. 

!!! warning
    Os projetos da disciplina consideram que não é razoável tentar paralelizar um problema que vocês não sejam capazes de resolver sequencialmente. 



## Avaliação

## Extras

Rodar. No monstrao

Melhor que o código do professor



