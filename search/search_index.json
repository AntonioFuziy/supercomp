{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SuperComputa\u00e7\u00e3o \u00b6 Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2020/2. Professor : Igor Montagner Objetivos \u00b6 Ao final da disciplina o aluno ser\u00e1 capaz de: TODO: objetivos atualizados aqui Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; O projeto da disciplina ser\u00e1 composto por m\u00faltiplas partes. Mais detalhes na p\u00e1gina de projetos A m\u00e9dia final \u00e9 dada por 55% Projeto 45% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Projeto >= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados) Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Home"},{"location":"#supercomputacao","text":"Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2020/2. Professor : Igor Montagner","title":"SuperComputa\u00e7\u00e3o"},{"location":"#objetivos","text":"Ao final da disciplina o aluno ser\u00e1 capaz de: TODO: objetivos atualizados aqui","title":"Objetivos"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; O projeto da disciplina ser\u00e1 composto por m\u00faltiplas partes. Mais detalhes na p\u00e1gina de projetos A m\u00e9dia final \u00e9 dada por 55% Projeto 45% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Projeto >= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados) Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Avalia\u00e7\u00e3o"},{"location":"sobre/","text":"Burocracias \u00b6 Turma 1 (remoto) \u00b6 Hor\u00e1rios: TER - 09:45 SEX - 13:30 Atendimento SEX - 15:30 Alunos Rachel Arthur (F)Olga Raphael Iago Jorge Vitor Satyro Juan Garcia Guilherme Aliperti Gabriel Moura Bruno Matteo Sabrina Gobetti Isabella Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 25/08 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 28/08 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 01/09 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 04/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 08/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 11/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 15/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 18/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 22/09 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 25/09 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 29/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 02/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 06/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 09/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 16/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 20/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 23/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 27/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 30/10 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 03/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 06/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 10/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 13/11 Quiz para PF Quiz para PF 17/11 Apresenta\u00e7\u00e3o da competi\u00e7\u00e3o final de desempenho Aula est\u00fadio para projeto 20/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 24/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 27/11 Prova Final Prova Final 01/12 Prova Final Prova Final Turma 2 (presencial) \u00b6 Hor\u00e1rios: QUA - 13:30 SEX - 07:30 Atendimento SEX - 09:30 Alunos Alessandra Tarraf Alexandre Giulia Felippe Teracini Guilherme Schoueri Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 26/08 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 28/08 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 02/09 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 04/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 09/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 11/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 16/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 18/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 23/09 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 25/09 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 30/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 02/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 07/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 09/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 14/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 16/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 21/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 23/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 28/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 30/10 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 04/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 06/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 11/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 13/11 Quiz para PF Quiz para PF 18/11 Apresenta\u00e7\u00e3o da competi\u00e7\u00e3o final de desempenho Aula est\u00fadio para projeto 20/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 25/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 27/11 Prova Final Prova Final 02/12 Prova Final Prova Final Turma Mista (Presencial/Remoto) \u00b6 Hugo (TER 09:45, SEX 7:30)","title":"Burocracias"},{"location":"sobre/#burocracias","text":"","title":"Burocracias"},{"location":"sobre/#turma-1-remoto","text":"Hor\u00e1rios: TER - 09:45 SEX - 13:30 Atendimento SEX - 15:30 Alunos Rachel Arthur (F)Olga Raphael Iago Jorge Vitor Satyro Juan Garcia Guilherme Aliperti Gabriel Moura Bruno Matteo Sabrina Gobetti Isabella Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 25/08 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 28/08 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 01/09 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 04/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 08/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 11/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 15/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 18/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 22/09 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 25/09 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 29/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 02/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 06/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 09/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 16/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 20/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 23/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 27/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 30/10 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 03/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 06/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 10/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 13/11 Quiz para PF Quiz para PF 17/11 Apresenta\u00e7\u00e3o da competi\u00e7\u00e3o final de desempenho Aula est\u00fadio para projeto 20/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 24/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 27/11 Prova Final Prova Final 01/12 Prova Final Prova Final","title":"Turma 1 (remoto)"},{"location":"sobre/#turma-2-presencial","text":"Hor\u00e1rios: QUA - 13:30 SEX - 07:30 Atendimento SEX - 09:30 Alunos Alessandra Tarraf Alexandre Giulia Felippe Teracini Guilherme Schoueri Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 26/08 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 28/08 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 02/09 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 04/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 09/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 11/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 16/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 18/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 23/09 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 25/09 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 30/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 02/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 07/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 09/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 14/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 16/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 21/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 23/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 28/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 30/10 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 04/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 06/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 11/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 13/11 Quiz para PF Quiz para PF 18/11 Apresenta\u00e7\u00e3o da competi\u00e7\u00e3o final de desempenho Aula est\u00fadio para projeto 20/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 25/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 27/11 Prova Final Prova Final 02/12 Prova Final Prova Final","title":"Turma 2 (presencial)"},{"location":"sobre/#turma-mista-presencialremoto","text":"Hugo (TER 09:45, SEX 7:30)","title":"Turma Mista (Presencial/Remoto)"},{"location":"turmas/","text":"Divis\u00e3o de turmas \u00b6 A partir de 08/09 \u00b6 Turma 1 (remoto) \u00b6 Hor\u00e1rios: TER - 09:45 SEX - 13:30 Atendimento SEX - 15:30 Alunos \u00b6 Rachel Arthur (F)Olga Raphael Iago Jorge Vitor Satyro Juan Garcia Guilherme Aliperti Gabriel Moura Bruno Matteo Sabrina Gobetti Isabella Turma 2 (presencial) \u00b6 Hor\u00e1rios: QUA - 13:30 SEX - 07:30 Atendimento SEX - 09:30 Alunos \u00b6 Alessandra Tarraf Alexandre Giulia Felippe Teracini Guilherme Schoueri Turma Mista (Presencial/Remoto) \u00b6 Hugo (TER 09:45, SEX 7:30)","title":"Divis\u00e3o de turmas"},{"location":"turmas/#divisao-de-turmas","text":"","title":"Divis\u00e3o de turmas"},{"location":"turmas/#a-partir-de-0809","text":"","title":"A partir de 08/09"},{"location":"turmas/#turma-1-remoto","text":"Hor\u00e1rios: TER - 09:45 SEX - 13:30 Atendimento SEX - 15:30","title":"Turma 1 (remoto)"},{"location":"turmas/#alunos","text":"Rachel Arthur (F)Olga Raphael Iago Jorge Vitor Satyro Juan Garcia Guilherme Aliperti Gabriel Moura Bruno Matteo Sabrina Gobetti Isabella","title":"Alunos"},{"location":"turmas/#turma-2-presencial","text":"Hor\u00e1rios: QUA - 13:30 SEX - 07:30 Atendimento SEX - 09:30","title":"Turma 2 (presencial)"},{"location":"turmas/#alunos_1","text":"Alessandra Tarraf Alexandre Giulia Felippe Teracini Guilherme Schoueri","title":"Alunos"},{"location":"turmas/#turma-mista-presencialremoto","text":"Hugo (TER 09:45, SEX 7:30)","title":"Turma Mista (Presencial/Remoto)"},{"location":"aulas/01-introducao/","text":"01 - Recursos \u00fateis de C++ \u00b6 A disciplina utilizar\u00e1 a linguagem C++ para implementa\u00e7\u00e3o dos programas. Ela \u00e9 muito usada em implementa\u00e7\u00f5es de alto desempenho e possui recursos muito \u00fateis e que simplificam a programa\u00e7\u00e3o se comparada com C puro. Nas aulas 01 e 02 aprenderemos alguns desses recursos e os utilizaremos para implementa\u00e7\u00e3o de algoritmos simples. Gabaritos e respostas Este curso n\u00e3o fornece c\u00f3digo de resposta para os exerc\u00edcios de sala. Cada exerc\u00edcio \u00e9 acompanhado de um algoritmo em pseudo-c\u00f3digo e alguns pares de arquivos entrada/sa\u00edda. Isto j\u00e1 \u00e9 suficiente para que voc\u00eas verifiquem se sua solu\u00e7\u00e3o est\u00e1 correta. Boas pr\u00e1ticas de programa\u00e7\u00e3o ser\u00e3o demonstradas em exerc\u00edcios corrigidos pelo professor durante o semestre. Uma lista (n\u00e3o exaustiva) dessas pr\u00e1ticas estar\u00e1 dispon\u00edveis na p\u00e1gina Projeto . Compila\u00e7\u00e3o \u00b6 Programas em C++ s\u00e3o compilados com o comando g++ . Ele funciona igual ao gcc que voc\u00eas j\u00e1 usaram em Desafios e Sistemas Hardware-Software. $> g++ arquivo.cpp -o executavel Entrada e sa\u00edda em C++ \u00b6 Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream). A maior vantagem de usar cin e cout \u00e9 que n\u00e3o precisamos mais daquelas strings de formata\u00e7\u00e3o estranhas com %d , %s e afins. Podemos passar vari\u00e1veis diretamente para a sa\u00edda do terminal usando o operador << . Veja um exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << \"Sa\u00edda: \" << a << \";\" << b << \" \\n \" ; Example Crie um arquivo entrada-saida.cpp com uma fun\u00e7\u00e3o main que roda o c\u00f3digo acima. Compile e execute seu programa e verifique que ele mostra o valor correto no terminal. O mesmo vale para a entrada, mas desta vez \"tiramos\" os dados do objeto std::cin . O exemplo abaixo l\u00ea um inteiro e um double do terminal. int a ; double b ; std :: cin >> a >> b ; Example Modifique seu programa entrada-saida.cpp para ler \u00ea um n\u00famero inteiro n e mostrar sua divis\u00e3o fracion\u00e1ria por 2. Ou seja, antes de dividir converta n para double . E esse std:: ? Em C++ podemos ter v\u00e1rias fun\u00e7\u00f5es, vari\u00e1veis e objetos em geral com o mesmo nome. Para evitar que eles colidam e n\u00e3o se saiba a qual estamos nos referindo cada nome deve ser definido um namespace (literalmente espaco de nomes ). Podemos ter namespace s aninhados.Por exemplo, std::chrono cont\u00e9m as fun\u00e7\u00f5es relacionadas contagem de tempo durante a execu\u00e7\u00e3o de um programa. Todas as fun\u00e7\u00f5es, classes e globais na biblioteca padr\u00e3o est\u00e3o definidas no espa\u00e7o std . Se quisermos, podemos omitir escrever std:: toda vez digitando using namespace std . Isso pode ser feito tamb\u00e9m com namespaces aninhados. A implementa\u00e7\u00e3o de algoritmos definidos usando express\u00f5es matem\u00e1ticas \u00e9 uma habilidade importante neste curso. Example Escreva um programa que receba um inteiro n e calcule a seguinte s\u00e9rie. S = \\sum_{i=0}^n \\frac{1}{2^i} S = \\sum_{i=0}^n \\frac{1}{2^i} Mostre as primeiras 15 casas decimais de S . Veja a documenta\u00e7\u00e3o de std::setprecision aqui . Resposta Essa s\u00e9rie converge para o n\u00famero 2, mas sua resposta dever\u00e1 ser sempre menor que este n\u00famero. Logo, quanto maior n mais pr\u00f3xima sua resposta ser\u00e1. Seu programa dever\u00e1 implementar algo como o algoritmo abaixo. leia inteiro n s = 0.0 para i=0 at\u00e9 n s += 1 / (2 elevado a i) print(s) Aloca\u00e7\u00e3o de mem\u00f3ria \u00b6 Em C usamos as fun\u00e7\u00f5es malloc e free para alocar mem\u00f3ria dinamicamente. Um inconveniente dessas fun\u00e7\u00f5es \u00e9 que sempre temos que passar o tamanho que queremos em bytes. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m est\u00e3o dispon\u00edveis, mas us\u00e1-las \u00e9 considerado uma m\u00e1 pr\u00e1tica. Ao inv\u00e9s, usamos os operadores new e delete para alocar mem\u00f3ria. Existem duas vantagens em us\u00e1-los. Podemos escrever diretamente o tipo que queremos, em vez de seu tamanho em bytes. A aloca\u00e7\u00e3o de arrays \u00e9 feita de maneira natural usando os colchetes [] . Vejamos o exemplo abaixo. int n ; std :: cin >> n ; double * values = new double [ n ]; /* usar values aqui */ delete [] values ; \u00c9 alocado um vetor de double de tamanho n (lido do terminal). Ap\u00f3s ele ser usado liberamos o espa\u00e7o alocado usando delete[] . E se eu quiser alocar um s\u00f3 valor? \u00c9 simples! \u00c9 s\u00f3 usar new sem os colchetes [] ! Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Resposta Os arquivos t4-in-(1,2,3).txt e t4-out-(1,2,3).txt devem ser usados para testar seu programa. Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas? Resposta M\u00e9dia e vari\u00e2ncia. Vetores em C++ \u00b6 Apesar do uso de new[] e delete[] mostrado na se\u00e7\u00e3o anterior j\u00e1 ser mais conveniente, ainda s\u00e3o essencialmente um programa em C com sintaxe ligeiramente mais agrad\u00e1vel. Para tornar a programa\u00e7\u00e3o em C++ mais produtiva sua biblioteca padr\u00e3o conta com estruturas de dados prontas para uso. A estrutura std::vector \u00e9 um vetor din\u00e2mico que tem funcionalidades parecidas com a lista de Python ou o ArrayList de Java. O c\u00f3digo abaixo exemplifica seu uso e mostra algumas de suas fun\u00e7\u00f5es. Note que omitimos o uso de std no c\u00f3digo abaixo. int n ; cin >> n ; vector < double > vec ; for ( int i = 0 ; i < n ; i ++ ) { vec . push_back ( i * i ) } cout << \"Tamanho do vetor: \" << vec . size () << \" \\n \" ; cout << \"Primeiro elemento: \" << vec . front () << \" \\n \" ; cout << \"\u00daltimo elemento: \" << vec . back () << \" \\n \" ; cout << \"Elemento 3: \" << vec [ 2 ] << \" \\n \" ; Alguns pontos interessantes deste exemplo: N\u00e3o sabemos o tamanho de vec ao cri\u00e1-lo. O m\u00e9todo push_back aumenta ele quando necess\u00e1rio e n\u00e3o precisamos nos preocupar com isso. O n\u00famero de elementos colocados no vetor \u00e9 retornado pelo m\u00e9todo size() O acesso \u00e9 feito exatamente igual ao array de C, usando os colchetes [] E esse <double> na declara\u00e7\u00e3o? Em C++ tipos passados entre < > s\u00e3o usados para parametrizar tipos gen\u00e9ricos. Ou seja, um vetor pode guardar qualquer tipo de dado e precisamos indicar qual ao cri\u00e1-lo. Note que, portanto, um vetor vector<int> e um vetor vector<double> s\u00e3o considerados de tipos diferentes e n\u00e3o posso passar o primeiro para uma fun\u00e7\u00e3o esperando o segundo. Question Modifique sua Tarefa 4 para usar vector . Me\u00e7a o desempenho com o programa time e anote abaixo seus resultados.","title":"01 - Recursos \u00fateis de C++"},{"location":"aulas/01-introducao/#01-recursos-uteis-de-c","text":"A disciplina utilizar\u00e1 a linguagem C++ para implementa\u00e7\u00e3o dos programas. Ela \u00e9 muito usada em implementa\u00e7\u00f5es de alto desempenho e possui recursos muito \u00fateis e que simplificam a programa\u00e7\u00e3o se comparada com C puro. Nas aulas 01 e 02 aprenderemos alguns desses recursos e os utilizaremos para implementa\u00e7\u00e3o de algoritmos simples. Gabaritos e respostas Este curso n\u00e3o fornece c\u00f3digo de resposta para os exerc\u00edcios de sala. Cada exerc\u00edcio \u00e9 acompanhado de um algoritmo em pseudo-c\u00f3digo e alguns pares de arquivos entrada/sa\u00edda. Isto j\u00e1 \u00e9 suficiente para que voc\u00eas verifiquem se sua solu\u00e7\u00e3o est\u00e1 correta. Boas pr\u00e1ticas de programa\u00e7\u00e3o ser\u00e3o demonstradas em exerc\u00edcios corrigidos pelo professor durante o semestre. Uma lista (n\u00e3o exaustiva) dessas pr\u00e1ticas estar\u00e1 dispon\u00edveis na p\u00e1gina Projeto .","title":"01 - Recursos \u00fateis de C++"},{"location":"aulas/01-introducao/#compilacao","text":"Programas em C++ s\u00e3o compilados com o comando g++ . Ele funciona igual ao gcc que voc\u00eas j\u00e1 usaram em Desafios e Sistemas Hardware-Software. $> g++ arquivo.cpp -o executavel","title":"Compila\u00e7\u00e3o"},{"location":"aulas/01-introducao/#entrada-e-saida-em-c","text":"Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream). A maior vantagem de usar cin e cout \u00e9 que n\u00e3o precisamos mais daquelas strings de formata\u00e7\u00e3o estranhas com %d , %s e afins. Podemos passar vari\u00e1veis diretamente para a sa\u00edda do terminal usando o operador << . Veja um exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << \"Sa\u00edda: \" << a << \";\" << b << \" \\n \" ; Example Crie um arquivo entrada-saida.cpp com uma fun\u00e7\u00e3o main que roda o c\u00f3digo acima. Compile e execute seu programa e verifique que ele mostra o valor correto no terminal. O mesmo vale para a entrada, mas desta vez \"tiramos\" os dados do objeto std::cin . O exemplo abaixo l\u00ea um inteiro e um double do terminal. int a ; double b ; std :: cin >> a >> b ; Example Modifique seu programa entrada-saida.cpp para ler \u00ea um n\u00famero inteiro n e mostrar sua divis\u00e3o fracion\u00e1ria por 2. Ou seja, antes de dividir converta n para double . E esse std:: ? Em C++ podemos ter v\u00e1rias fun\u00e7\u00f5es, vari\u00e1veis e objetos em geral com o mesmo nome. Para evitar que eles colidam e n\u00e3o se saiba a qual estamos nos referindo cada nome deve ser definido um namespace (literalmente espaco de nomes ). Podemos ter namespace s aninhados.Por exemplo, std::chrono cont\u00e9m as fun\u00e7\u00f5es relacionadas contagem de tempo durante a execu\u00e7\u00e3o de um programa. Todas as fun\u00e7\u00f5es, classes e globais na biblioteca padr\u00e3o est\u00e3o definidas no espa\u00e7o std . Se quisermos, podemos omitir escrever std:: toda vez digitando using namespace std . Isso pode ser feito tamb\u00e9m com namespaces aninhados. A implementa\u00e7\u00e3o de algoritmos definidos usando express\u00f5es matem\u00e1ticas \u00e9 uma habilidade importante neste curso. Example Escreva um programa que receba um inteiro n e calcule a seguinte s\u00e9rie. S = \\sum_{i=0}^n \\frac{1}{2^i} S = \\sum_{i=0}^n \\frac{1}{2^i} Mostre as primeiras 15 casas decimais de S . Veja a documenta\u00e7\u00e3o de std::setprecision aqui . Resposta Essa s\u00e9rie converge para o n\u00famero 2, mas sua resposta dever\u00e1 ser sempre menor que este n\u00famero. Logo, quanto maior n mais pr\u00f3xima sua resposta ser\u00e1. Seu programa dever\u00e1 implementar algo como o algoritmo abaixo. leia inteiro n s = 0.0 para i=0 at\u00e9 n s += 1 / (2 elevado a i) print(s)","title":"Entrada e sa\u00edda em C++"},{"location":"aulas/01-introducao/#alocacao-de-memoria","text":"Em C usamos as fun\u00e7\u00f5es malloc e free para alocar mem\u00f3ria dinamicamente. Um inconveniente dessas fun\u00e7\u00f5es \u00e9 que sempre temos que passar o tamanho que queremos em bytes. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m est\u00e3o dispon\u00edveis, mas us\u00e1-las \u00e9 considerado uma m\u00e1 pr\u00e1tica. Ao inv\u00e9s, usamos os operadores new e delete para alocar mem\u00f3ria. Existem duas vantagens em us\u00e1-los. Podemos escrever diretamente o tipo que queremos, em vez de seu tamanho em bytes. A aloca\u00e7\u00e3o de arrays \u00e9 feita de maneira natural usando os colchetes [] . Vejamos o exemplo abaixo. int n ; std :: cin >> n ; double * values = new double [ n ]; /* usar values aqui */ delete [] values ; \u00c9 alocado um vetor de double de tamanho n (lido do terminal). Ap\u00f3s ele ser usado liberamos o espa\u00e7o alocado usando delete[] . E se eu quiser alocar um s\u00f3 valor? \u00c9 simples! \u00c9 s\u00f3 usar new sem os colchetes [] ! Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Resposta Os arquivos t4-in-(1,2,3).txt e t4-out-(1,2,3).txt devem ser usados para testar seu programa. Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas? Resposta M\u00e9dia e vari\u00e2ncia.","title":"Aloca\u00e7\u00e3o de mem\u00f3ria"},{"location":"aulas/01-introducao/#vetores-em-c","text":"Apesar do uso de new[] e delete[] mostrado na se\u00e7\u00e3o anterior j\u00e1 ser mais conveniente, ainda s\u00e3o essencialmente um programa em C com sintaxe ligeiramente mais agrad\u00e1vel. Para tornar a programa\u00e7\u00e3o em C++ mais produtiva sua biblioteca padr\u00e3o conta com estruturas de dados prontas para uso. A estrutura std::vector \u00e9 um vetor din\u00e2mico que tem funcionalidades parecidas com a lista de Python ou o ArrayList de Java. O c\u00f3digo abaixo exemplifica seu uso e mostra algumas de suas fun\u00e7\u00f5es. Note que omitimos o uso de std no c\u00f3digo abaixo. int n ; cin >> n ; vector < double > vec ; for ( int i = 0 ; i < n ; i ++ ) { vec . push_back ( i * i ) } cout << \"Tamanho do vetor: \" << vec . size () << \" \\n \" ; cout << \"Primeiro elemento: \" << vec . front () << \" \\n \" ; cout << \"\u00daltimo elemento: \" << vec . back () << \" \\n \" ; cout << \"Elemento 3: \" << vec [ 2 ] << \" \\n \" ; Alguns pontos interessantes deste exemplo: N\u00e3o sabemos o tamanho de vec ao cri\u00e1-lo. O m\u00e9todo push_back aumenta ele quando necess\u00e1rio e n\u00e3o precisamos nos preocupar com isso. O n\u00famero de elementos colocados no vetor \u00e9 retornado pelo m\u00e9todo size() O acesso \u00e9 feito exatamente igual ao array de C, usando os colchetes [] E esse <double> na declara\u00e7\u00e3o? Em C++ tipos passados entre < > s\u00e3o usados para parametrizar tipos gen\u00e9ricos. Ou seja, um vetor pode guardar qualquer tipo de dado e precisamos indicar qual ao cri\u00e1-lo. Note que, portanto, um vetor vector<int> e um vetor vector<double> s\u00e3o considerados de tipos diferentes e n\u00e3o posso passar o primeiro para uma fun\u00e7\u00e3o esperando o segundo. Question Modifique sua Tarefa 4 para usar vector . Me\u00e7a o desempenho com o programa time e anote abaixo seus resultados.","title":"Vetores em C++"},{"location":"aulas/02-desempenho/","text":"02 - Detalhes de implementa\u00e7\u00e3o \u00b6 Nesta aula trabalharemos dois objetivos: implementa\u00e7\u00e3o de algoritmos dada uma descri\u00e7\u00e3o de alto n\u00edvel da tarefa a ser implementada t\u00e9cnicas de implementa\u00e7\u00e3o para alto desempenho Software Para esta aula precisaremos dos seguintes pacotes instalados. valgrind - ferramenta de an\u00e1lise de c\u00f3digo execut\u00e1vel kcachegrind - visualizador de resultados do valgrind O problema b\u00e1sico \u00b6 Dados N pontos com coordenadas (x_i, y_i)_{i=0}^N (x_i, y_i)_{i=0}^N , computar a matriz de dist\u00e2ncias D D tal que D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) Example Implemente um programa que calcule a matriz D acima. Sua entrada dever\u00e1 estar no formato dos arquivos t1-in-*.txt e sua sa\u00edda no formato dos arquivos t1-out-*.txt . Dicas : a maneira mais f\u00e1cil (n\u00e3o necessariamente a melhor) de alocar uma matriz \u00e9 usando um vetor em que cada elemento \u00e9 outro vetor. fa\u00e7a uma implementa\u00e7\u00e3o o mais simples poss\u00edvel. Vamos melhor\u00e1-la nas pr\u00f3ximas tarefas. Resposta leia inteiro N leia vetores X e Y seja D uma matriz NxN para i=1..N: para j=1..N: DX = X[i] - X[j] DY = Y[i] - Y[j] D[i,j] = sqrt(DX*DX + DY*DY) Question Anote abaixo o tempo de execu\u00e7\u00e3o para os arquivos t1-in-*.txt e t1-out-*.txt Question Qual \u00e9 a complexidade computacional de sua implementa\u00e7\u00e3o? Passagem de dados no programa \u00b6 Na parte anterior fizemos nosso programa inteiro no main . Vamos agora organiz\u00e1-lo melhor. Example Crie uma fun\u00e7\u00e3o calcula_distancias que recebe a matriz e os dados recebidos na entrada e a preenche. Sua fun\u00e7\u00e3o n\u00e3o dever\u00e1 retornar nenhum valor. Ao terminar, me\u00e7a o tempo de execu\u00e7\u00e3o para o arquivo t1-out-4.txt . Resposta Aqui podem ocorrer dois problemas: Seu programa deu \"Segmentation Fault\". Seu programa rodou at\u00e9 o fim, mas a sa\u00edda \u00e9 vazia (ou cheia de 0). O problema em si depende de como voc\u00ea fez o for duplo para mostrar os resultados. De qualquer maneira, simplesmente mover c\u00f3digo para uma outra fun\u00e7\u00e3o n\u00e3o funciona neste caso. Ambos problemas descritos na solu\u00e7\u00e3o s\u00e3o previs\u00edveis e ocorrem pela mesma raz\u00e3o: ao passar um vector para uma fun\u00e7\u00e3o \u00e9 feita uma c\u00f3pia de seu conte\u00fado . Ou seja, a matriz usada dentro de calcula_distancias n\u00e3o \u00e9 a mesma do main ! Isto \u00e9 considerado uma feature em C++ : por padr\u00e3o toda vari\u00e1vel \u00e9 passada por c\u00f3pia . Isto evita que uma fun\u00e7\u00e3o modifique um valor sem que o c\u00f3digo chamador fique sabendo. Em C podemos passar vari\u00e1veis por refer\u00eancia passando um ponteiro para elas. Apesar de funcional, isso n\u00e3o \u00e9 muito pr\u00e1tico pois temos que acessar a vari\u00e1vel sempre usando * . Em C++ temos um novo recurso: refer\u00eancias. Ao declarar uma vari\u00e1vel como uma refer\u00eancia crio uma esp\u00e9cie de ponteiro constante que sempre acessa a vari\u00e1vel apontada. Veja o exemplo abaixo. int x = 10 ; int & ref = x ; // refer\u00eancias s\u00e3o declaradas colocando & na frente do nome da vari\u00e1vel // a partir daqui ref e x representam a mesma vari\u00e1vel ref = 15 ; cout << x << \" \\n \" ; // 15 O mesmo poderia ser feito com ponteiros (como mostrado abaixo). A grande vantagem da refer\u00eancia \u00e9 que n\u00e3o precisamos usar *ref para nos referirmos \u00e0 vari\u00e1vel x ! Na atribui\u00e7\u00e3o tamb\u00e9m podemos usar direto int &ref = x , o que torna o c\u00f3digo mais limpo e f\u00e1cil de entender. int x = 10 ; int * ref = & x ; // precisamos de &x para apontar ref para a vari\u00e1vel x * ref = 15 ; // precisamos indicar *ref para atribuir a vari\u00e1vel x cout << x << \" \\n \" ; // 15 Dicas Note que uma refer\u00eancia tem que ser inicializada com a vari\u00e1vel a que ela se refere. Ou seja, ao declarar tenho que j\u00e1 indicar a vari\u00e1vel destino. Example Modifique sua fun\u00e7\u00e3o para usar refer\u00eancias. Verifique que ele volta a funcionar e que seu tempo de execu\u00e7\u00e3o continua parecido com a vers\u00e3o que rodava no main . Resposta Basta adicionar & na frente dos nomes dos argumentos (vetores x, y e matriz). A chamada da fun\u00e7\u00e3o n\u00e3o muda. Dica Em C++ precisamos estar sempre atentos a maneira que passamos os dados. Se n\u00e3o indicarmos ser\u00e1 por c\u00f3pia. Para compartilhar o mesmo objeto entre v\u00e1rias fun\u00e7\u00f5es usamos refer\u00eancias & . Medi\u00e7\u00e3o de tempo com KCachegrind \u00b6 Apesar de podermos medir o tempo que nosso programa demora usando o comando time , n\u00e3o conseguimos nenhuma informa\u00e7\u00e3o importante de qual parte do programa est\u00e1 consumindo mais tempo. Este processo de dissecar um programa e entender exatamente qual parte demora quanto \u00e9 chamada de Profiling . Dica \u00c9 preciso compilar um execut\u00e1vel com profiling habilitado para medir os tempos. Isso \u00e9 feito com a flag -p do g++ . Veja abaixo. g++ -p -g euclides-ingenuo.cpp -o euclides-ingenuo Demonstra\u00e7\u00e3o adslj lkadj Para mostrar os resultados usando o kcachegrind usamos o seguinte comando. kcachegrind callgrind.out.(pid aqui) Na demonstra\u00e7\u00e3o pudemos ver que grande parte do tempo do programa da Tarefa 1 \u00e9 gasto mostrando a sa\u00edda no terminal. Isto nos leva \u00e0 primeira conclus\u00e3o da atividade de hoje: Entrada e sa\u00edda de dados s\u00e3o opera\u00e7\u00f5es muito lentas Com isso em mente, vamos agora otimizar a fun\u00e7\u00e3o calcula_distancias . J\u00e1 sabemos que o efeito no tempo final n\u00e3o ser\u00e1 grande. Nosso objetivo ent\u00e3o ser\u00e1 verificar a seguinte afirma\u00e7\u00e3o. Dois algoritmos de mesma complexidade computacional podem ter tempos de execu\u00e7\u00e3o muito diferentes A otimiza\u00e7\u00e3o que trabalharemos nesse roteiro tentar\u00e1 explorar a simetria da matriz D . Question Como isso poderia ser usado para melhorar o tempo de execu\u00e7\u00e3o de calcula_distancias ? Question Seu programa criado na tarefa 1 consegue ser adaptado para implementar sua ideia da quest\u00e3o anterior? O que precisaria ser modificado? Resposta Duas respostas s\u00e3o poss\u00edveis e corretas aqui: Preciso checar se o i < j e usar o valor j\u00e1 calculado de D[j,i] . \u00c9 preciso alocar a matriz inteira antes de come\u00e7ar. Se formos dando push_back linha a linha n\u00e3o conseguimos atribuir um valor ao mesmo tempo a D[i,j] e D[j,i] , j\u00e1 que um deles ainda n\u00e3o ter\u00e1 sido criado. Vamos come\u00e7ar implementando resposta 1 da pergunta anterior, j\u00e1 que ela envolve uma pequena modifica\u00e7\u00e3o no programa. Question Anote abaixo o consumo absoluto de tempo da fun\u00e7\u00e3o calcula_distancia . Example Adicione uma checagem que verifica se o elemento j\u00e1 foi calculado no \"outro lado\" da matriz e use esse valor ao inv\u00e9s de Question Anote abaixo o consumo absoluto de tempo da sua nova fun\u00e7\u00e3o calcula_distancia . Compare com a pergunta anterior e tente entender seus resultados. Resposta Deve ter havido uma pequena melhora, mas longe de ser a metade do tempo. Question Por que n\u00e3o houve melhora significativa? Voc\u00ea consegue explicar? Resposta A principal raz\u00e3o \u00e9 que o n\u00famero absoluto de instru\u00e7\u00f5es n\u00e3o mudou muito. O for duplo ainda roda n*n vezes e o pr\u00f3prio acesso a mat[i][j] \u00e9 apontado como lento pelo kcachegrind . Com a alternativa 1 descartada, vamos agora para a alternativa 2: atribuir de uma s\u00f3 vez em D[i,j] e D[j,i] . Ou seja, agora nosso loop vai ser executado metade das vezes! Question Supondo que a matriz j\u00e1 esteja inteira alocada, como voc\u00ea implementaria a alternativa 2? Resposta para i=1..N: para j=i..N: DX = X[i] - X[j] DY = Y[i] - Y[j] DIST = sqrt(DX*DX + DY*DY) D[i,j] = DIST D[j,i] = DIST","title":"02 - Detalhes de implementa\u00e7\u00e3o"},{"location":"aulas/02-desempenho/#02-detalhes-de-implementacao","text":"Nesta aula trabalharemos dois objetivos: implementa\u00e7\u00e3o de algoritmos dada uma descri\u00e7\u00e3o de alto n\u00edvel da tarefa a ser implementada t\u00e9cnicas de implementa\u00e7\u00e3o para alto desempenho Software Para esta aula precisaremos dos seguintes pacotes instalados. valgrind - ferramenta de an\u00e1lise de c\u00f3digo execut\u00e1vel kcachegrind - visualizador de resultados do valgrind","title":"02 - Detalhes de implementa\u00e7\u00e3o"},{"location":"aulas/02-desempenho/#o-problema-basico","text":"Dados N pontos com coordenadas (x_i, y_i)_{i=0}^N (x_i, y_i)_{i=0}^N , computar a matriz de dist\u00e2ncias D D tal que D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) Example Implemente um programa que calcule a matriz D acima. Sua entrada dever\u00e1 estar no formato dos arquivos t1-in-*.txt e sua sa\u00edda no formato dos arquivos t1-out-*.txt . Dicas : a maneira mais f\u00e1cil (n\u00e3o necessariamente a melhor) de alocar uma matriz \u00e9 usando um vetor em que cada elemento \u00e9 outro vetor. fa\u00e7a uma implementa\u00e7\u00e3o o mais simples poss\u00edvel. Vamos melhor\u00e1-la nas pr\u00f3ximas tarefas. Resposta leia inteiro N leia vetores X e Y seja D uma matriz NxN para i=1..N: para j=1..N: DX = X[i] - X[j] DY = Y[i] - Y[j] D[i,j] = sqrt(DX*DX + DY*DY) Question Anote abaixo o tempo de execu\u00e7\u00e3o para os arquivos t1-in-*.txt e t1-out-*.txt Question Qual \u00e9 a complexidade computacional de sua implementa\u00e7\u00e3o?","title":"O problema b\u00e1sico"},{"location":"aulas/02-desempenho/#passagem-de-dados-no-programa","text":"Na parte anterior fizemos nosso programa inteiro no main . Vamos agora organiz\u00e1-lo melhor. Example Crie uma fun\u00e7\u00e3o calcula_distancias que recebe a matriz e os dados recebidos na entrada e a preenche. Sua fun\u00e7\u00e3o n\u00e3o dever\u00e1 retornar nenhum valor. Ao terminar, me\u00e7a o tempo de execu\u00e7\u00e3o para o arquivo t1-out-4.txt . Resposta Aqui podem ocorrer dois problemas: Seu programa deu \"Segmentation Fault\". Seu programa rodou at\u00e9 o fim, mas a sa\u00edda \u00e9 vazia (ou cheia de 0). O problema em si depende de como voc\u00ea fez o for duplo para mostrar os resultados. De qualquer maneira, simplesmente mover c\u00f3digo para uma outra fun\u00e7\u00e3o n\u00e3o funciona neste caso. Ambos problemas descritos na solu\u00e7\u00e3o s\u00e3o previs\u00edveis e ocorrem pela mesma raz\u00e3o: ao passar um vector para uma fun\u00e7\u00e3o \u00e9 feita uma c\u00f3pia de seu conte\u00fado . Ou seja, a matriz usada dentro de calcula_distancias n\u00e3o \u00e9 a mesma do main ! Isto \u00e9 considerado uma feature em C++ : por padr\u00e3o toda vari\u00e1vel \u00e9 passada por c\u00f3pia . Isto evita que uma fun\u00e7\u00e3o modifique um valor sem que o c\u00f3digo chamador fique sabendo. Em C podemos passar vari\u00e1veis por refer\u00eancia passando um ponteiro para elas. Apesar de funcional, isso n\u00e3o \u00e9 muito pr\u00e1tico pois temos que acessar a vari\u00e1vel sempre usando * . Em C++ temos um novo recurso: refer\u00eancias. Ao declarar uma vari\u00e1vel como uma refer\u00eancia crio uma esp\u00e9cie de ponteiro constante que sempre acessa a vari\u00e1vel apontada. Veja o exemplo abaixo. int x = 10 ; int & ref = x ; // refer\u00eancias s\u00e3o declaradas colocando & na frente do nome da vari\u00e1vel // a partir daqui ref e x representam a mesma vari\u00e1vel ref = 15 ; cout << x << \" \\n \" ; // 15 O mesmo poderia ser feito com ponteiros (como mostrado abaixo). A grande vantagem da refer\u00eancia \u00e9 que n\u00e3o precisamos usar *ref para nos referirmos \u00e0 vari\u00e1vel x ! Na atribui\u00e7\u00e3o tamb\u00e9m podemos usar direto int &ref = x , o que torna o c\u00f3digo mais limpo e f\u00e1cil de entender. int x = 10 ; int * ref = & x ; // precisamos de &x para apontar ref para a vari\u00e1vel x * ref = 15 ; // precisamos indicar *ref para atribuir a vari\u00e1vel x cout << x << \" \\n \" ; // 15 Dicas Note que uma refer\u00eancia tem que ser inicializada com a vari\u00e1vel a que ela se refere. Ou seja, ao declarar tenho que j\u00e1 indicar a vari\u00e1vel destino. Example Modifique sua fun\u00e7\u00e3o para usar refer\u00eancias. Verifique que ele volta a funcionar e que seu tempo de execu\u00e7\u00e3o continua parecido com a vers\u00e3o que rodava no main . Resposta Basta adicionar & na frente dos nomes dos argumentos (vetores x, y e matriz). A chamada da fun\u00e7\u00e3o n\u00e3o muda. Dica Em C++ precisamos estar sempre atentos a maneira que passamos os dados. Se n\u00e3o indicarmos ser\u00e1 por c\u00f3pia. Para compartilhar o mesmo objeto entre v\u00e1rias fun\u00e7\u00f5es usamos refer\u00eancias & .","title":"Passagem de dados no programa"},{"location":"aulas/02-desempenho/#medicao-de-tempo-com-kcachegrind","text":"Apesar de podermos medir o tempo que nosso programa demora usando o comando time , n\u00e3o conseguimos nenhuma informa\u00e7\u00e3o importante de qual parte do programa est\u00e1 consumindo mais tempo. Este processo de dissecar um programa e entender exatamente qual parte demora quanto \u00e9 chamada de Profiling . Dica \u00c9 preciso compilar um execut\u00e1vel com profiling habilitado para medir os tempos. Isso \u00e9 feito com a flag -p do g++ . Veja abaixo. g++ -p -g euclides-ingenuo.cpp -o euclides-ingenuo Demonstra\u00e7\u00e3o adslj lkadj Para mostrar os resultados usando o kcachegrind usamos o seguinte comando. kcachegrind callgrind.out.(pid aqui) Na demonstra\u00e7\u00e3o pudemos ver que grande parte do tempo do programa da Tarefa 1 \u00e9 gasto mostrando a sa\u00edda no terminal. Isto nos leva \u00e0 primeira conclus\u00e3o da atividade de hoje: Entrada e sa\u00edda de dados s\u00e3o opera\u00e7\u00f5es muito lentas Com isso em mente, vamos agora otimizar a fun\u00e7\u00e3o calcula_distancias . J\u00e1 sabemos que o efeito no tempo final n\u00e3o ser\u00e1 grande. Nosso objetivo ent\u00e3o ser\u00e1 verificar a seguinte afirma\u00e7\u00e3o. Dois algoritmos de mesma complexidade computacional podem ter tempos de execu\u00e7\u00e3o muito diferentes A otimiza\u00e7\u00e3o que trabalharemos nesse roteiro tentar\u00e1 explorar a simetria da matriz D . Question Como isso poderia ser usado para melhorar o tempo de execu\u00e7\u00e3o de calcula_distancias ? Question Seu programa criado na tarefa 1 consegue ser adaptado para implementar sua ideia da quest\u00e3o anterior? O que precisaria ser modificado? Resposta Duas respostas s\u00e3o poss\u00edveis e corretas aqui: Preciso checar se o i < j e usar o valor j\u00e1 calculado de D[j,i] . \u00c9 preciso alocar a matriz inteira antes de come\u00e7ar. Se formos dando push_back linha a linha n\u00e3o conseguimos atribuir um valor ao mesmo tempo a D[i,j] e D[j,i] , j\u00e1 que um deles ainda n\u00e3o ter\u00e1 sido criado. Vamos come\u00e7ar implementando resposta 1 da pergunta anterior, j\u00e1 que ela envolve uma pequena modifica\u00e7\u00e3o no programa. Question Anote abaixo o consumo absoluto de tempo da fun\u00e7\u00e3o calcula_distancia . Example Adicione uma checagem que verifica se o elemento j\u00e1 foi calculado no \"outro lado\" da matriz e use esse valor ao inv\u00e9s de Question Anote abaixo o consumo absoluto de tempo da sua nova fun\u00e7\u00e3o calcula_distancia . Compare com a pergunta anterior e tente entender seus resultados. Resposta Deve ter havido uma pequena melhora, mas longe de ser a metade do tempo. Question Por que n\u00e3o houve melhora significativa? Voc\u00ea consegue explicar? Resposta A principal raz\u00e3o \u00e9 que o n\u00famero absoluto de instru\u00e7\u00f5es n\u00e3o mudou muito. O for duplo ainda roda n*n vezes e o pr\u00f3prio acesso a mat[i][j] \u00e9 apontado como lento pelo kcachegrind . Com a alternativa 1 descartada, vamos agora para a alternativa 2: atribuir de uma s\u00f3 vez em D[i,j] e D[j,i] . Ou seja, agora nosso loop vai ser executado metade das vezes! Question Supondo que a matriz j\u00e1 esteja inteira alocada, como voc\u00ea implementaria a alternativa 2? Resposta para i=1..N: para j=i..N: DX = X[i] - X[j] DY = Y[i] - Y[j] DIST = sqrt(DX*DX + DY*DY) D[i,j] = DIST D[j,i] = DIST","title":"Medi\u00e7\u00e3o de tempo com KCachegrind"},{"location":"projetos/","text":"Travelling Sales Person \u00b6 TODO: descri\u00e7\u00e3o do projeto aqui","title":"Travelling Sales Person"},{"location":"projetos/#travelling-sales-person","text":"TODO: descri\u00e7\u00e3o do projeto aqui","title":"Travelling Sales Person"},{"location":"projetos/checklist/","text":"Checklist de projeto \u00b6 Alguns requisitos de projeto b\u00e1sicos ser\u00e3o verificados em todas as entregas. O objetivo aqui \u00e9 evitar que uma evid\u00eancia importante de aprendizado deixe de ser enviada e prejudique a avalia\u00e7\u00e3o. N\u00e3o cumprir algum desses requisitos implica em reentrega valendo D . Script de compila\u00e7\u00e3o (CMake, Makefile, bash script). Relat\u00f3rio feito em Jupyter Notebook ou PWeave. Vers\u00e3o em PDF (ou HTML) do relat\u00f3rio Instru\u00e7\u00f5es para replicar os testes realizados. Se isto estiver incluso no relat\u00f3rio execut\u00e1vel basta indicar no texto. Se\u00e7\u00e3o explicando onde est\u00e1 e como usar o script de compila\u00e7\u00e3o. Requisitos de qualidade \u00b6 Al\u00e9m dos requisitos acima, que s\u00e3o obrigat\u00f3rios, os seguintes itens procuram medir a qualidade da implementa\u00e7\u00e3o que voc\u00eas desenvolveram. Assim como explicado na aula 01, eles n\u00e3o reprovam, mas diminuem a nota de projeto. Cada item que n\u00e3o for cumprido implica em desconto de 1,0 na nota de projeto. Programa compila sem warnings quando compilado com g++ -O3 -Wall -pedantic -std=c++11 ; Programa n\u00e3o tem warnings detectados pelo clang-tidy . Veja este v\u00eddeo para um breve tutorial de uso; usar os checks read*,performance*,hicpp*,modern*,-modernize-use-trailing-return-type . N\u00e3o h\u00e1 repeti\u00e7\u00e3o desnecess\u00e1ria de c\u00f3digo; Implementaremos v\u00e1rias solu\u00e7\u00f5es para o mesmo problema. \u00c9 importante compartilhar o m\u00e1ximo de c\u00f3digo poss\u00edvel entre todas as implementa\u00e7\u00f5es; Utilizar struct ou class para agregar grupos de vari\u00e1veis que sempre s\u00e3o usadas junto (Exemplo: todos os dados de entrada do programa); Utilizar typdef para renomear tipos com nomes grandes. (Exemplo seria um vector de um struct ou pair ); Utilizar corretamente os recursos de C++. Em geral o que for apresentado em aula e n\u00e3o conflitar com os itens acima \u00e9 OK. Em geral c\u00f3digo copiado da internet n\u00e3o passa nesse quesito. Na d\u00favida pergunte.","title":"Checklist de projeto"},{"location":"projetos/checklist/#checklist-de-projeto","text":"Alguns requisitos de projeto b\u00e1sicos ser\u00e3o verificados em todas as entregas. O objetivo aqui \u00e9 evitar que uma evid\u00eancia importante de aprendizado deixe de ser enviada e prejudique a avalia\u00e7\u00e3o. N\u00e3o cumprir algum desses requisitos implica em reentrega valendo D . Script de compila\u00e7\u00e3o (CMake, Makefile, bash script). Relat\u00f3rio feito em Jupyter Notebook ou PWeave. Vers\u00e3o em PDF (ou HTML) do relat\u00f3rio Instru\u00e7\u00f5es para replicar os testes realizados. Se isto estiver incluso no relat\u00f3rio execut\u00e1vel basta indicar no texto. Se\u00e7\u00e3o explicando onde est\u00e1 e como usar o script de compila\u00e7\u00e3o.","title":"Checklist de projeto"},{"location":"projetos/checklist/#requisitos-de-qualidade","text":"Al\u00e9m dos requisitos acima, que s\u00e3o obrigat\u00f3rios, os seguintes itens procuram medir a qualidade da implementa\u00e7\u00e3o que voc\u00eas desenvolveram. Assim como explicado na aula 01, eles n\u00e3o reprovam, mas diminuem a nota de projeto. Cada item que n\u00e3o for cumprido implica em desconto de 1,0 na nota de projeto. Programa compila sem warnings quando compilado com g++ -O3 -Wall -pedantic -std=c++11 ; Programa n\u00e3o tem warnings detectados pelo clang-tidy . Veja este v\u00eddeo para um breve tutorial de uso; usar os checks read*,performance*,hicpp*,modern*,-modernize-use-trailing-return-type . N\u00e3o h\u00e1 repeti\u00e7\u00e3o desnecess\u00e1ria de c\u00f3digo; Implementaremos v\u00e1rias solu\u00e7\u00f5es para o mesmo problema. \u00c9 importante compartilhar o m\u00e1ximo de c\u00f3digo poss\u00edvel entre todas as implementa\u00e7\u00f5es; Utilizar struct ou class para agregar grupos de vari\u00e1veis que sempre s\u00e3o usadas junto (Exemplo: todos os dados de entrada do programa); Utilizar typdef para renomear tipos com nomes grandes. (Exemplo seria um vector de um struct ou pair ); Utilizar corretamente os recursos de C++. Em geral o que for apresentado em aula e n\u00e3o conflitar com os itens acima \u00e9 OK. Em geral c\u00f3digo copiado da internet n\u00e3o passa nesse quesito. Na d\u00favida pergunte.","title":"Requisitos de qualidade"}]}