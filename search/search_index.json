{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SuperComputa\u00e7\u00e3o \u00b6 Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2021/1. Professores : Igor Montagner (Turma A) Ant\u00f4nio Selvatici (Turma B) Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; O projeto da disciplina ser\u00e1 composto por m\u00faltiplas partes. Mais detalhes na p\u00e1gina de projetos A m\u00e9dia final \u00e9 dada por 55% Projeto 45% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Projeto >= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados) Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Home"},{"location":"#supercomputacao","text":"Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2021/1. Professores : Igor Montagner (Turma A) Ant\u00f4nio Selvatici (Turma B)","title":"SuperComputa\u00e7\u00e3o"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; O projeto da disciplina ser\u00e1 composto por m\u00faltiplas partes. Mais detalhes na p\u00e1gina de projetos A m\u00e9dia final \u00e9 dada por 55% Projeto 45% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Projeto >= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados) Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Avalia\u00e7\u00e3o"},{"location":"enunciado/","text":"Prova Intermedi\u00e1ria \u00b6 Regras da prova \u00b6 Dura\u00e7\u00e3o : 180 minutos Cada quest\u00e3o possui uma pasta onde voc\u00ea dever\u00e1 colocar suas quest\u00f5es. D\u00favidas dos enunciados da prova ser\u00e3o resolvidos via chat. \u00c9 permitido consultar o material da disciplina durante a prova (tudo o que estiver no reposit\u00f3rio da disciplina e o no site https://insper.github.io/supercomp . Isto inclui suas pr\u00f3prias solu\u00e7\u00f5es aos exerc\u00edcios de sala de aula, mas n\u00e3o inclui materiais n\u00e3o digitais . Consultas a outros materias (de outros alunos ou na internet em geral) n\u00e3o s\u00e3o permitidos. \u00c9 poss\u00edvel tamb\u00e9m consultar a documenta\u00e7\u00e3o de C++ nos sites http://cplusplus.com/ e https://cppreference.com A prova \u00e9 individual. Qualquer consulta a outras pessoas durante a prova constitui viola\u00e7\u00e3o ao C\u00f3digo de \u00c9tica do Insper. Parte 1 - cria\u00e7\u00e3o de algoritmos b\u00e1sicos \u00b6 Uma empresa de entregas precisa entregar N pacotes a destinos com dist\u00e2ncia d_i, i=1,\\dots,N d_i, i=1,\\dots,N de sua sede. Para fazer essas entregas ela conta com N fornecedores, cada um cobrando um preco de p_i p_i reais por quil\u00f4metro rodado. Seu trabalho ser\u00e1 encontrar a atribui\u00e7\u00e3o fornecedor-pacote que resulte no menor custo final para realizar todas as entregas. Seu programa dever\u00e1 aceitar entradas no formato abaixo. N d1 ... dN p1 ... pN Sua sa\u00edda dever\u00e1 estar no formato abaixo C f1 ... fN onde C \u00e9 o custo final das entregas e fI \u00e9 o \u00edndice do fornecedor usado para fazer a entrega de dist\u00e2ncia d_i d_i . (1,0) Pergunta Como voc\u00ea resolveria este problema? Descreva em alto n\u00edvel um algoritmo que tenta minimizar o custo final e crie 4 pares de arquivos entrada/sa\u00edda que exemplifiquem a aplica\u00e7\u00e3o de seu algoritmo. (2,0) Tarefa Crie uma implementa\u00e7\u00e3o do seu algoritmo acima. Use suas entradas/sa\u00eddas para testar seu programa. Parte 2 - Projeto \u00b6 No projeto da disciplina estamos desenvolvendo algoritmos para a encontrar solu\u00e7\u00f5es para o problema de aloca\u00e7\u00e3o de recursos chamado de Maximin Share (MMS), no qual devemos particionar uma cole\u00e7\u00e3o de M objetos indivis\u00edveis com diferentes valores v_i v_i , i = 1, 2, \\dots, M i = 1, 2, \\dots, M entre N N pessoas, de forma que a pessoa que tenha recebido a parti\u00e7\u00e3o com menor valor total receba o maior valor poss\u00edvel. Considere agora o problema MMS com diferentes prefer\u00eancias, em que o valor atribu\u00eddo a cada objeto seja diferente para cada pessoa. Por exemplo, se estivermos dividindo um pacote de M M balas sortidas a um grupo de N N crian\u00e7as, algumas crian\u00e7as podem atribuir um valor maior \u00e0s balas de sabor morango, enquanto outras preferem balas sabor caramelo. Assim o valor do objeto j j depende da pessoa i i , de forma que os valores dos objetos s\u00e3o definidos por uma matriz de elementos v_{ij}, i = 1, 2, \\dots, N, j = 1, 2, \\dots, M v_{ij}, i = 1, 2, \\dots, N, j = 1, 2, \\dots, M . Uma consequ\u00eancia dessa modifica\u00e7\u00e3o do problema \u00e9 que o valor da parti\u00e7\u00e3o MMS muda dependendo da perspectiva de cada pessoa envolvida. Vejamos este exemplo do Wikipedia, em que os objetos 1 a 5 devem ser particionados entre tr\u00eas pessoas: Alice, George e Dina. Alice atribui a eles os valores 1,3,5,6,9; George atribui a eles os valores 1,7,2,6,8; Dina atribui a eles os valores 1,1,1,4,17. Cada pessoa possui ent\u00e3o uma parti\u00e7\u00e3o MMS diferente: A de Alice \u00e9 [1, 4], com valor 7; O de George \u00e9 [1,2] ou [3,4] ou [5], todos com valor 8; A de Dina \u00e9 [1,2,3], com valor 3. Aqui, consideramos um particionamento como justo no sentido da MMS se ele entregar a Alice uma parti\u00e7\u00e3o de valor de pelo menos 7, a George uma de valor de pelo menos 8 e a Dina uma de valor de pelo menos 3. Por exemplo, o particionamento [3,4] para Alice, [1,2] para George e [5] para Dina \u00e9 justo, pois os valores atribu\u00eddos s\u00e3o 11, 8 e 17 respectivamente. \u00c9 importante notar que nem sempre podemos garantir um particionamento justo no sentido da MMS. (1,0) Pergunta Considere a estrat\u00e9gia de aloca\u00e7\u00e3o para o problema de MMS com diferentes prefer\u00eancias que entrega primeiro o objeto mais valioso para a pessoa 1 (sob a perspectiva dessa pessoa), depois o mais valioso para a pessoa 2 que ainda n\u00e3o tenha sido alocado, e assim por diante, at\u00e9 acabarem os objetos. Considerando Alice como a pessoa 1, George como a pessoa 2 e Dina como a pessoa 3, e considerando ainda os valores atribu\u00eddos dos objetos fornecidas no enunciado, qual \u00e9 a aloca\u00e7\u00e3o de objetos resultante dessa estrat\u00e9gia? Ela \u00e9 justa no sentido da MMS? Qual \u00e9 o valor da parti\u00e7\u00e3o menos valiosa? (2,0) Tarefa Implemente uma solu\u00e7\u00e3o para o problema de aloca\u00e7\u00e3o de objetos segundo a heur\u00edstica que considera a aloca\u00e7\u00e3o de recursos descrita na Pergunta 1. N\u00e3o se preocupe em estruturar o algoritmo mais eficiente poss\u00edvel, desde que seja execut\u00e1vel em tempo razo\u00e1vel para que possa ser testado durante a prova. Para testar sua implementa\u00e7\u00e3o, use as entradas in1a.txt, in1b.txt, in1c.txt e in1d.txt, que possuem o seguinte formato: M N v11 v12 ... v1M v21 v22 ... v2M ... vN1 vN2 ... vNM onde M \u00e9 o n\u00famero de objetos, N \u00e9 o n\u00famero de pessoas e vIJ \u00e9 o valor atribu\u00eddo ao objeto J pela pessoa I. As respostas esperadas est\u00e3o em out1a.txt, out1b.txt, out1c.txt e out1d.txt que possuem o seguinte formato: MMS Objetos da pessoa 1 (ordenados pelo \u00edndice) ... Objetos da pessoa N (ordenados pelo \u00edndice) (2,0) Tarefa Implemente um programa que verifique se uma determinada aloca\u00e7\u00e3o \u00e9 justa no sentido da MMS. O programa receber\u00e1 uma entrada informando a avalia\u00e7\u00e3o dos objetos por cada pessoa, o MMS de cada pessoa e a aloca\u00e7\u00e3o definida. A sa\u00edda dever\u00e1 ser apenas SIM no caso de a aloca\u00e7\u00e3o ser justa, e NAO no caso contr\u00e1rio. Use as entradas in2a-sim.txt, in2a-nao.txt, in2b-sim.txt, in2b-nao.txt que devem fornecer as sa\u00eddas SIM, NAO, SIM e NAO, respectivamente. As entradas est\u00e3o no formato abaixo: M N v11 v12 ... v1M v21 v22 ... v2M ... vN1 vN2 ... vNM MMS_1 MMS_2 ... MMS_N a1 a2 ... aM onde M \u00e9 o n\u00famero de objetos, N \u00e9 o n\u00famero de pessoas, vIJ \u00e9 o valor atribu\u00eddo ao objeto J pela pessoa I, MMS_I \u00e9 o valor do MMS da pessoa I e aJ \u00e9 o \u00edndice da pessoa que recebeu o objeto J. (1,0) Pergunta No projeto da disciplina, voc\u00eas elaboraram um programa para encontrar o m\u00e1ximo global para o MMS com iguais prefer\u00eancias, ou seja, os objetos s\u00e3o avaliados da mesma forma por todas as pessoas participantes do seu particionamento. Assim, a qualidade de uma poss\u00edvel solu\u00e7\u00e3o era dada simplesmente pelo valor da MMS. Quando consideramos o mesmo objetivo, por\u00e9m admitindo diferentes prefer\u00eancias, solu\u00e7\u00f5es que n\u00e3o sejam justas, por\u00e9m com valor de MMS maior s\u00e3o de pior qualidade do que solu\u00e7\u00f5es justas, por\u00e9m com menor MMS. Se quisermos simplesmente descartar solu\u00e7\u00f5es que n\u00e3o sejam justas, que valor dever\u00edamos atribuir a elas? E como saber se a solu\u00e7\u00e3o final obtida \u00e9 justa? (2,0) Tarefa Implemente um programa que resolva o problema de encontrar a MMS com diferentes prefer\u00eancias, e que garanta uma aloca\u00e7\u00e3o justa no sentido da MMS. Se n\u00e3o for poss\u00edvel obter essa aloca\u00e7\u00e3o, simplesmente informe a resposta \u201cSEM SOLU\u00c7\u00c3O\u201d. Caso contr\u00e1rio, devolva a aloca\u00e7\u00e3o de objetos obtida no formato pedido na Tarefa 1. Use os arquivos in3a.txt, in3b.txt, in3c.txt e in3d.txt, comparando as sa\u00eddas com out3a.txt, out3b.txt, out3c.txt e out3d.txt para testar sua solu\u00e7\u00e3o. Os arquivos de entrada est\u00e3o no formato: M N v11 v12 ... v1M v21 v22 ... v2M ... vN1 vN2 ... vNM MMS_1 MMS_2 ... MMS_N","title":"Prova Intermedi\u00e1ria"},{"location":"enunciado/#prova-intermediaria","text":"","title":"Prova Intermedi\u00e1ria"},{"location":"enunciado/#regras-da-prova","text":"Dura\u00e7\u00e3o : 180 minutos Cada quest\u00e3o possui uma pasta onde voc\u00ea dever\u00e1 colocar suas quest\u00f5es. D\u00favidas dos enunciados da prova ser\u00e3o resolvidos via chat. \u00c9 permitido consultar o material da disciplina durante a prova (tudo o que estiver no reposit\u00f3rio da disciplina e o no site https://insper.github.io/supercomp . Isto inclui suas pr\u00f3prias solu\u00e7\u00f5es aos exerc\u00edcios de sala de aula, mas n\u00e3o inclui materiais n\u00e3o digitais . Consultas a outros materias (de outros alunos ou na internet em geral) n\u00e3o s\u00e3o permitidos. \u00c9 poss\u00edvel tamb\u00e9m consultar a documenta\u00e7\u00e3o de C++ nos sites http://cplusplus.com/ e https://cppreference.com A prova \u00e9 individual. Qualquer consulta a outras pessoas durante a prova constitui viola\u00e7\u00e3o ao C\u00f3digo de \u00c9tica do Insper.","title":"Regras da prova"},{"location":"enunciado/#parte-1-criacao-de-algoritmos-basicos","text":"Uma empresa de entregas precisa entregar N pacotes a destinos com dist\u00e2ncia d_i, i=1,\\dots,N d_i, i=1,\\dots,N de sua sede. Para fazer essas entregas ela conta com N fornecedores, cada um cobrando um preco de p_i p_i reais por quil\u00f4metro rodado. Seu trabalho ser\u00e1 encontrar a atribui\u00e7\u00e3o fornecedor-pacote que resulte no menor custo final para realizar todas as entregas. Seu programa dever\u00e1 aceitar entradas no formato abaixo. N d1 ... dN p1 ... pN Sua sa\u00edda dever\u00e1 estar no formato abaixo C f1 ... fN onde C \u00e9 o custo final das entregas e fI \u00e9 o \u00edndice do fornecedor usado para fazer a entrega de dist\u00e2ncia d_i d_i . (1,0) Pergunta Como voc\u00ea resolveria este problema? Descreva em alto n\u00edvel um algoritmo que tenta minimizar o custo final e crie 4 pares de arquivos entrada/sa\u00edda que exemplifiquem a aplica\u00e7\u00e3o de seu algoritmo. (2,0) Tarefa Crie uma implementa\u00e7\u00e3o do seu algoritmo acima. Use suas entradas/sa\u00eddas para testar seu programa.","title":"Parte 1 - cria\u00e7\u00e3o de algoritmos b\u00e1sicos"},{"location":"enunciado/#parte-2-projeto","text":"No projeto da disciplina estamos desenvolvendo algoritmos para a encontrar solu\u00e7\u00f5es para o problema de aloca\u00e7\u00e3o de recursos chamado de Maximin Share (MMS), no qual devemos particionar uma cole\u00e7\u00e3o de M objetos indivis\u00edveis com diferentes valores v_i v_i , i = 1, 2, \\dots, M i = 1, 2, \\dots, M entre N N pessoas, de forma que a pessoa que tenha recebido a parti\u00e7\u00e3o com menor valor total receba o maior valor poss\u00edvel. Considere agora o problema MMS com diferentes prefer\u00eancias, em que o valor atribu\u00eddo a cada objeto seja diferente para cada pessoa. Por exemplo, se estivermos dividindo um pacote de M M balas sortidas a um grupo de N N crian\u00e7as, algumas crian\u00e7as podem atribuir um valor maior \u00e0s balas de sabor morango, enquanto outras preferem balas sabor caramelo. Assim o valor do objeto j j depende da pessoa i i , de forma que os valores dos objetos s\u00e3o definidos por uma matriz de elementos v_{ij}, i = 1, 2, \\dots, N, j = 1, 2, \\dots, M v_{ij}, i = 1, 2, \\dots, N, j = 1, 2, \\dots, M . Uma consequ\u00eancia dessa modifica\u00e7\u00e3o do problema \u00e9 que o valor da parti\u00e7\u00e3o MMS muda dependendo da perspectiva de cada pessoa envolvida. Vejamos este exemplo do Wikipedia, em que os objetos 1 a 5 devem ser particionados entre tr\u00eas pessoas: Alice, George e Dina. Alice atribui a eles os valores 1,3,5,6,9; George atribui a eles os valores 1,7,2,6,8; Dina atribui a eles os valores 1,1,1,4,17. Cada pessoa possui ent\u00e3o uma parti\u00e7\u00e3o MMS diferente: A de Alice \u00e9 [1, 4], com valor 7; O de George \u00e9 [1,2] ou [3,4] ou [5], todos com valor 8; A de Dina \u00e9 [1,2,3], com valor 3. Aqui, consideramos um particionamento como justo no sentido da MMS se ele entregar a Alice uma parti\u00e7\u00e3o de valor de pelo menos 7, a George uma de valor de pelo menos 8 e a Dina uma de valor de pelo menos 3. Por exemplo, o particionamento [3,4] para Alice, [1,2] para George e [5] para Dina \u00e9 justo, pois os valores atribu\u00eddos s\u00e3o 11, 8 e 17 respectivamente. \u00c9 importante notar que nem sempre podemos garantir um particionamento justo no sentido da MMS. (1,0) Pergunta Considere a estrat\u00e9gia de aloca\u00e7\u00e3o para o problema de MMS com diferentes prefer\u00eancias que entrega primeiro o objeto mais valioso para a pessoa 1 (sob a perspectiva dessa pessoa), depois o mais valioso para a pessoa 2 que ainda n\u00e3o tenha sido alocado, e assim por diante, at\u00e9 acabarem os objetos. Considerando Alice como a pessoa 1, George como a pessoa 2 e Dina como a pessoa 3, e considerando ainda os valores atribu\u00eddos dos objetos fornecidas no enunciado, qual \u00e9 a aloca\u00e7\u00e3o de objetos resultante dessa estrat\u00e9gia? Ela \u00e9 justa no sentido da MMS? Qual \u00e9 o valor da parti\u00e7\u00e3o menos valiosa? (2,0) Tarefa Implemente uma solu\u00e7\u00e3o para o problema de aloca\u00e7\u00e3o de objetos segundo a heur\u00edstica que considera a aloca\u00e7\u00e3o de recursos descrita na Pergunta 1. N\u00e3o se preocupe em estruturar o algoritmo mais eficiente poss\u00edvel, desde que seja execut\u00e1vel em tempo razo\u00e1vel para que possa ser testado durante a prova. Para testar sua implementa\u00e7\u00e3o, use as entradas in1a.txt, in1b.txt, in1c.txt e in1d.txt, que possuem o seguinte formato: M N v11 v12 ... v1M v21 v22 ... v2M ... vN1 vN2 ... vNM onde M \u00e9 o n\u00famero de objetos, N \u00e9 o n\u00famero de pessoas e vIJ \u00e9 o valor atribu\u00eddo ao objeto J pela pessoa I. As respostas esperadas est\u00e3o em out1a.txt, out1b.txt, out1c.txt e out1d.txt que possuem o seguinte formato: MMS Objetos da pessoa 1 (ordenados pelo \u00edndice) ... Objetos da pessoa N (ordenados pelo \u00edndice) (2,0) Tarefa Implemente um programa que verifique se uma determinada aloca\u00e7\u00e3o \u00e9 justa no sentido da MMS. O programa receber\u00e1 uma entrada informando a avalia\u00e7\u00e3o dos objetos por cada pessoa, o MMS de cada pessoa e a aloca\u00e7\u00e3o definida. A sa\u00edda dever\u00e1 ser apenas SIM no caso de a aloca\u00e7\u00e3o ser justa, e NAO no caso contr\u00e1rio. Use as entradas in2a-sim.txt, in2a-nao.txt, in2b-sim.txt, in2b-nao.txt que devem fornecer as sa\u00eddas SIM, NAO, SIM e NAO, respectivamente. As entradas est\u00e3o no formato abaixo: M N v11 v12 ... v1M v21 v22 ... v2M ... vN1 vN2 ... vNM MMS_1 MMS_2 ... MMS_N a1 a2 ... aM onde M \u00e9 o n\u00famero de objetos, N \u00e9 o n\u00famero de pessoas, vIJ \u00e9 o valor atribu\u00eddo ao objeto J pela pessoa I, MMS_I \u00e9 o valor do MMS da pessoa I e aJ \u00e9 o \u00edndice da pessoa que recebeu o objeto J. (1,0) Pergunta No projeto da disciplina, voc\u00eas elaboraram um programa para encontrar o m\u00e1ximo global para o MMS com iguais prefer\u00eancias, ou seja, os objetos s\u00e3o avaliados da mesma forma por todas as pessoas participantes do seu particionamento. Assim, a qualidade de uma poss\u00edvel solu\u00e7\u00e3o era dada simplesmente pelo valor da MMS. Quando consideramos o mesmo objetivo, por\u00e9m admitindo diferentes prefer\u00eancias, solu\u00e7\u00f5es que n\u00e3o sejam justas, por\u00e9m com valor de MMS maior s\u00e3o de pior qualidade do que solu\u00e7\u00f5es justas, por\u00e9m com menor MMS. Se quisermos simplesmente descartar solu\u00e7\u00f5es que n\u00e3o sejam justas, que valor dever\u00edamos atribuir a elas? E como saber se a solu\u00e7\u00e3o final obtida \u00e9 justa? (2,0) Tarefa Implemente um programa que resolva o problema de encontrar a MMS com diferentes prefer\u00eancias, e que garanta uma aloca\u00e7\u00e3o justa no sentido da MMS. Se n\u00e3o for poss\u00edvel obter essa aloca\u00e7\u00e3o, simplesmente informe a resposta \u201cSEM SOLU\u00c7\u00c3O\u201d. Caso contr\u00e1rio, devolva a aloca\u00e7\u00e3o de objetos obtida no formato pedido na Tarefa 1. Use os arquivos in3a.txt, in3b.txt, in3c.txt e in3d.txt, comparando as sa\u00eddas com out3a.txt, out3b.txt, out3c.txt e out3d.txt para testar sua solu\u00e7\u00e3o. Os arquivos de entrada est\u00e3o no formato: M N v11 v12 ... v1M v21 v22 ... v2M ... vN1 vN2 ... vNM MMS_1 MMS_2 ... MMS_N","title":"Parte 2 - Projeto"},{"location":"sobre/","text":"Burocracias \u00b6 Turma B \u00b6 Hor\u00e1rios: TER - 09:45 SEX - 13:30 Atendimento SEX - 15:30 Alunos TBA Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 23/02 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 26/02 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 02/03 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa. 05/03 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 09/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 12/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 16/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 19/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 23/03 Quando uma otimiza\u00e7\u00e3o vale a pena? Qual m\u00e9todo \u00e9 o mais eficaz em resolver um problema? An\u00e1lise de resultados de execu\u00e7\u00e3o 26/03 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 30/03 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 02/04 Feriado Feriado 06/04 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 09/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 13/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 16/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 20/04 nan nan 23/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 27/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 30/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 04/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 07/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 11/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 14/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 18/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 21/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 25/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 28/05 Quiz para PF Quiz para PF 01/06 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 04/06 Feriado Feriado 08/06 nan nan 11/06 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria Turma A \u00b6 Hor\u00e1rios: QUA - 13:30 SEX - 07:30 Atendimento SEX - 09:30 Alunos TBA Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 24/02 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 26/02 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 03/03 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa. 05/03 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 10/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 12/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 17/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 19/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 24/03 Quando uma otimiza\u00e7\u00e3o vale a pena? Qual m\u00e9todo \u00e9 o mais eficaz em resolver um problema? An\u00e1lise de resultados de execu\u00e7\u00e3o 26/03 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 31/03 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 02/04 Feriado Feriado 07/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 09/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 14/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 16/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 21/04 nan nan 23/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 28/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 30/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 05/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 07/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 12/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 14/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 19/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 21/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 26/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 28/05 Quiz para PF Quiz para PF 02/06 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 04/06 Feriado Feriado 09/06 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 11/06 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria","title":"Burocracias"},{"location":"sobre/#burocracias","text":"","title":"Burocracias"},{"location":"sobre/#turma-b","text":"Hor\u00e1rios: TER - 09:45 SEX - 13:30 Atendimento SEX - 15:30 Alunos TBA Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 23/02 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 26/02 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 02/03 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa. 05/03 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 09/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 12/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 16/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 19/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 23/03 Quando uma otimiza\u00e7\u00e3o vale a pena? Qual m\u00e9todo \u00e9 o mais eficaz em resolver um problema? An\u00e1lise de resultados de execu\u00e7\u00e3o 26/03 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 30/03 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 02/04 Feriado Feriado 06/04 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 09/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 13/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 16/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 20/04 nan nan 23/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 27/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 30/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 04/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 07/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 11/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 14/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 18/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 21/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 25/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 28/05 Quiz para PF Quiz para PF 01/06 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 04/06 Feriado Feriado 08/06 nan nan 11/06 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria","title":"Turma B"},{"location":"sobre/#turma-a","text":"Hor\u00e1rios: QUA - 13:30 SEX - 07:30 Atendimento SEX - 09:30 Alunos TBA Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 24/02 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 26/02 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 03/03 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa. 05/03 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 10/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 12/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 17/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 19/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 24/03 Quando uma otimiza\u00e7\u00e3o vale a pena? Qual m\u00e9todo \u00e9 o mais eficaz em resolver um problema? An\u00e1lise de resultados de execu\u00e7\u00e3o 26/03 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 31/03 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 02/04 Feriado Feriado 07/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 09/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 14/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 16/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 21/04 nan nan 23/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 28/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 30/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 05/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 07/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 12/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 14/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 19/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 21/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 26/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 28/05 Quiz para PF Quiz para PF 02/06 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 04/06 Feriado Feriado 09/06 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 11/06 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria","title":"Turma A"},{"location":"aulas/01-introducao/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); 01 - Introdu\u00e7\u00e3o a SuperComputa\u00e7\u00e3o \u00b6 Como vimos na expositiva, uma solu\u00e7\u00e3o de alto desempenho depende de tr\u00eas partes: algoritmos eficientes implementa\u00e7\u00f5es eficientes paralelismo Na atividade de hoje vamos estudar o primeiro ponto e quantificar o efeito de algoritmos eficientes na resolu\u00e7\u00e3o de um problema complexo. Problemas estudados em SuperComputa\u00e7\u00e3o \u00b6 Em Desafios de Programa\u00e7\u00e3o conhecemos a classe dos problemas NP-completo, que s\u00e3o aqueles que acreditamos n\u00e3o existir nenhum algoritmo determin\u00edstico que os resolvem em tempo polinomial. Ou seja, s\u00e3o problemas importantes cuja solu\u00e7\u00e3o \u00e9 dif\u00edcil. Em geral temos classes de algoritmos para resolv\u00ea-los: \u00f3timos globais: algoritmo que encontra a solu\u00e7\u00e3o \"correta\" do problema. \u00f3timos locais: algoritmo que encontra uma solu\u00e7\u00e3o \"boa\" e que n\u00e3o pode ser melhorada por pequenas modifica\u00e7\u00f5es. aproxima\u00e7\u00e3o: algoritmos que garantem estar \"perto o suficiente\" da solu\u00e7\u00e3o \u00f3tima. Este tipo de algoritmo n\u00e3o nos interessa em SuperComputa\u00e7\u00e3o. Iremos analisar hoje 4 execut\u00e1veis que resolvem o problema do Caixeiro Viajante . busca-local-1 - implementa\u00e7\u00e3o de um m\u00e9todo de busca r\u00e1pida, por\u00e9m n\u00e3o \u00f3tima. busca-local-1-par - implementa\u00e7\u00e3o paralela do programa acima. busca-local-2 - implementa\u00e7\u00e3o alternativa do mesmo m\u00e9todo acima. Os resultados de ambos s\u00e3o id\u00eanticos. busca-local-2-par - implementa\u00e7\u00e3o paralela do programa acima. Important N\u00e3o estamos interessados no Caixeiro Viajante em si hoje. Queremos \u00e9 comparar diferentes maneiras de resolv\u00ea-lo para entendermos o papel de t\u00e9cnicas de SuperComputa\u00e7\u00e3o na velocidade de processamento e nos resultados obtidos. Ferramental \u00b6 Realizar testes de maneira automatizada \u00e9 muito importante para quantificar os efeitos de diferentes algoritmos e t\u00e9cnicas de paralelismo. O snippet abaixo executa import subprocess import time with open ( 'entradas-busca-local/in-0.txt' ) as f : start = time . perf_counter () proc = subprocess . run ([ './busca-local-1' ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () print ( 'Sa\u00edda:' , proc . stdout ) print ( 'Stderr:' , proc . stderr ) print ( 'Tempo total(s):' , end - start ) Sa\u00edda: 232.234 0 3 0 4 1 2 Stderr: Tempo total(s): 0.013778032999653078 Vamos agora praticar usar este snippet para executar nossos testes automaticamente. Example Crie uma fun\u00e7\u00e3o roda_com_entrada(executavel, arquivo_in) que roda o primeiro argumento usando como entrada o conte\u00fado do segundo argumento. Teste seu c\u00f3digo com o execut\u00e1vel busca-local-1 e com o arquivo de entrada in-0.txt usado no exemplo acima. Sua fun\u00e7\u00e3o dever\u00e1 devolver uma tupla (stdout,time) com stdout sendo a sa\u00edda do programa e time seu tempo de execu\u00e7\u00e3o em segundos. def roda ( ex , in_f ): with open ( in_f ) as f : start = time . perf_counter () proc = subprocess . run ([ ex ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () return proc . stdout , end - start roda ( './busca-local-1' , 'entradas-busca-local/in-0.txt' ) ('232.234 0\\n3 0 4 1 2 \\n', 0.009169607999865548) Algoritmos sequenciais \u00b6 Com esse c\u00f3digo, vamos criar um relat\u00f3rio interativo que roda nossos testes automaticamente e j\u00e1 plota informa\u00e7\u00f5es prontas para nossas an\u00e1lises. Vamos come\u00e7ar examinando o desempenho do execut\u00e1vel busca-local-1 . Example Rode o busca-local com os arquivos de entrada na pasta entradas-busca-local . Guarde os tempos em uma lista. Example Leia o tamanho das entradas dos arquivos na pasta entradas-busca-local e guarde em uma segunda lista. Example Plote o tempo de execu\u00e7\u00e3o pelo tamanho da entrada usando matplotlib arqs = [ f 'entradas-busca-local/in- { i } .txt' for i in range ( 10 )] tempos = [ roda ( './busca-local-1' , arq )[ 1 ] for arq in arqs ] N = [] for arq in arqs : with open ( arq ) as f : n = int ( f . readlines ()[ 0 ]) N . append ( n ) print ( N ) import matplotlib.pyplot as plt plt . plot ( tempos ) [<matplotlib.lines.Line2D at 0x7fe533947550>] 2021-02-24T14:47:06.578856 image/svg+xml Matplotlib v3.3.4, https://matplotlib.org/ *{stroke-linecap:butt;stroke-linejoin:round;} Example Repita os tr\u00eas passos acima para o execut\u00e1vel busca-local-2 . Finalize plotando os tempos de execu\u00e7\u00e3o de ambos os execut\u00e1veis no mesmo gr\u00e1fico. tempos2 = [ roda ( './busca-local-2' , arq )[ 1 ] for arq in arqs ] plt . plot ( tempos ) plt . plot ( tempos2 ) [<matplotlib.lines.Line2D at 0x7fe5335e47c0>] 2021-02-24T14:48:22.282797 image/svg+xml Matplotlib v3.3.4, https://matplotlib.org/ *{stroke-linecap:butt;stroke-linejoin:round;} Example Segundo uma coleta de dados informal e altamente confi\u00e1vel, 93,17% dos alunos n\u00e3o colocam legendas nem t\u00edtulos nos gr\u00e1ficos gerados. Fa\u00e7a isso agora. Question Interprete o gr\u00e1fico que voc\u00ea gerou na linha de cima. Question Compare manualmente a sa\u00edda dos programas. Existe diferen\u00e7a em seus resultados? Question Resgate seus conhecimentos de Desafios de Programa\u00e7\u00e3o e explique a diferen\u00e7a entre os algoritmos. Algoritmos paralelos \u00b6 Na discuss\u00e3o inicial da expositiva chegamos \u00e0 conclus\u00e3o de que se conseguimos realizar N opera\u00e7\u00f5es em paralelo teremos um ganho de no m\u00e1ximo N vezes no desempenho de nosso programa. Nesta parte iremos estudar esta afirma\u00e7\u00e3o usando implementa\u00e7\u00f5es paralelas dos algoritmos da se\u00e7\u00e3o anterior. Example Execute os algoritmos paralelos com as mesmas entradas e compare com suas vers\u00f5es paralelas. Use um gr\u00e1fico para facilitar as compara\u00e7\u00f5es Question Compare os tempos obtidos. Qual foi o ganho m\u00e9dio? Quantos n\u00facleos a m\u00e1quina que voc\u00ea est\u00e1 usando possui? Responda comparando cada algoritmo sequencial com sua vers\u00e3o paralela. J\u00e1 estabelecemos que busca-local-2 \u00e9 melhor que busca-local-1 por ser utilizar um algoritmo mais eficiente e vimos na pr\u00e1tica a diferen\u00e7a entre um algoritmo O(n^3) O(n^3) e um algoritmo O(n^2) O(n^2) . Vamos agora examinar a seguinte quest\u00e3o. \u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2 ? Example Compare o desempenho de busca-local-1-par com busca-local-2 . Fa\u00e7a um gr\u00e1fico Question Com base em seu gr\u00e1fico acima, responda a pergunta: \"\u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2?\" Vamos agora generalizar a pergunta: Question Dados dois algoritmos com complexidades computacionais diferentes, sendo que o primeiro \u00e9 inferior ao segundo. \u00c9 poss\u00edvel usar paralelismo para tornar o primeiro mais r\u00e1pido que o segundo para todos tamanhos de entrada? Assuma que voc\u00ea possui um n\u00famero fixo de n\u00facleos .","title":"01 - Introdu\u00e7\u00e3o"},{"location":"aulas/01-introducao/#01-introducao-a-supercomputacao","text":"Como vimos na expositiva, uma solu\u00e7\u00e3o de alto desempenho depende de tr\u00eas partes: algoritmos eficientes implementa\u00e7\u00f5es eficientes paralelismo Na atividade de hoje vamos estudar o primeiro ponto e quantificar o efeito de algoritmos eficientes na resolu\u00e7\u00e3o de um problema complexo.","title":"01 - Introdu\u00e7\u00e3o a SuperComputa\u00e7\u00e3o"},{"location":"aulas/01-introducao/#problemas-estudados-em-supercomputacao","text":"Em Desafios de Programa\u00e7\u00e3o conhecemos a classe dos problemas NP-completo, que s\u00e3o aqueles que acreditamos n\u00e3o existir nenhum algoritmo determin\u00edstico que os resolvem em tempo polinomial. Ou seja, s\u00e3o problemas importantes cuja solu\u00e7\u00e3o \u00e9 dif\u00edcil. Em geral temos classes de algoritmos para resolv\u00ea-los: \u00f3timos globais: algoritmo que encontra a solu\u00e7\u00e3o \"correta\" do problema. \u00f3timos locais: algoritmo que encontra uma solu\u00e7\u00e3o \"boa\" e que n\u00e3o pode ser melhorada por pequenas modifica\u00e7\u00f5es. aproxima\u00e7\u00e3o: algoritmos que garantem estar \"perto o suficiente\" da solu\u00e7\u00e3o \u00f3tima. Este tipo de algoritmo n\u00e3o nos interessa em SuperComputa\u00e7\u00e3o. Iremos analisar hoje 4 execut\u00e1veis que resolvem o problema do Caixeiro Viajante . busca-local-1 - implementa\u00e7\u00e3o de um m\u00e9todo de busca r\u00e1pida, por\u00e9m n\u00e3o \u00f3tima. busca-local-1-par - implementa\u00e7\u00e3o paralela do programa acima. busca-local-2 - implementa\u00e7\u00e3o alternativa do mesmo m\u00e9todo acima. Os resultados de ambos s\u00e3o id\u00eanticos. busca-local-2-par - implementa\u00e7\u00e3o paralela do programa acima. Important N\u00e3o estamos interessados no Caixeiro Viajante em si hoje. Queremos \u00e9 comparar diferentes maneiras de resolv\u00ea-lo para entendermos o papel de t\u00e9cnicas de SuperComputa\u00e7\u00e3o na velocidade de processamento e nos resultados obtidos.","title":"Problemas estudados em SuperComputa\u00e7\u00e3o"},{"location":"aulas/01-introducao/#ferramental","text":"Realizar testes de maneira automatizada \u00e9 muito importante para quantificar os efeitos de diferentes algoritmos e t\u00e9cnicas de paralelismo. O snippet abaixo executa import subprocess import time with open ( 'entradas-busca-local/in-0.txt' ) as f : start = time . perf_counter () proc = subprocess . run ([ './busca-local-1' ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () print ( 'Sa\u00edda:' , proc . stdout ) print ( 'Stderr:' , proc . stderr ) print ( 'Tempo total(s):' , end - start ) Sa\u00edda: 232.234 0 3 0 4 1 2 Stderr: Tempo total(s): 0.013778032999653078 Vamos agora praticar usar este snippet para executar nossos testes automaticamente. Example Crie uma fun\u00e7\u00e3o roda_com_entrada(executavel, arquivo_in) que roda o primeiro argumento usando como entrada o conte\u00fado do segundo argumento. Teste seu c\u00f3digo com o execut\u00e1vel busca-local-1 e com o arquivo de entrada in-0.txt usado no exemplo acima. Sua fun\u00e7\u00e3o dever\u00e1 devolver uma tupla (stdout,time) com stdout sendo a sa\u00edda do programa e time seu tempo de execu\u00e7\u00e3o em segundos. def roda ( ex , in_f ): with open ( in_f ) as f : start = time . perf_counter () proc = subprocess . run ([ ex ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () return proc . stdout , end - start roda ( './busca-local-1' , 'entradas-busca-local/in-0.txt' ) ('232.234 0\\n3 0 4 1 2 \\n', 0.009169607999865548)","title":"Ferramental"},{"location":"aulas/01-introducao/#algoritmos-sequenciais","text":"Com esse c\u00f3digo, vamos criar um relat\u00f3rio interativo que roda nossos testes automaticamente e j\u00e1 plota informa\u00e7\u00f5es prontas para nossas an\u00e1lises. Vamos come\u00e7ar examinando o desempenho do execut\u00e1vel busca-local-1 . Example Rode o busca-local com os arquivos de entrada na pasta entradas-busca-local . Guarde os tempos em uma lista. Example Leia o tamanho das entradas dos arquivos na pasta entradas-busca-local e guarde em uma segunda lista. Example Plote o tempo de execu\u00e7\u00e3o pelo tamanho da entrada usando matplotlib arqs = [ f 'entradas-busca-local/in- { i } .txt' for i in range ( 10 )] tempos = [ roda ( './busca-local-1' , arq )[ 1 ] for arq in arqs ] N = [] for arq in arqs : with open ( arq ) as f : n = int ( f . readlines ()[ 0 ]) N . append ( n ) print ( N ) import matplotlib.pyplot as plt plt . plot ( tempos ) [<matplotlib.lines.Line2D at 0x7fe533947550>] 2021-02-24T14:47:06.578856 image/svg+xml Matplotlib v3.3.4, https://matplotlib.org/ *{stroke-linecap:butt;stroke-linejoin:round;} Example Repita os tr\u00eas passos acima para o execut\u00e1vel busca-local-2 . Finalize plotando os tempos de execu\u00e7\u00e3o de ambos os execut\u00e1veis no mesmo gr\u00e1fico. tempos2 = [ roda ( './busca-local-2' , arq )[ 1 ] for arq in arqs ] plt . plot ( tempos ) plt . plot ( tempos2 ) [<matplotlib.lines.Line2D at 0x7fe5335e47c0>] 2021-02-24T14:48:22.282797 image/svg+xml Matplotlib v3.3.4, https://matplotlib.org/ *{stroke-linecap:butt;stroke-linejoin:round;} Example Segundo uma coleta de dados informal e altamente confi\u00e1vel, 93,17% dos alunos n\u00e3o colocam legendas nem t\u00edtulos nos gr\u00e1ficos gerados. Fa\u00e7a isso agora. Question Interprete o gr\u00e1fico que voc\u00ea gerou na linha de cima. Question Compare manualmente a sa\u00edda dos programas. Existe diferen\u00e7a em seus resultados? Question Resgate seus conhecimentos de Desafios de Programa\u00e7\u00e3o e explique a diferen\u00e7a entre os algoritmos.","title":"Algoritmos sequenciais"},{"location":"aulas/01-introducao/#algoritmos-paralelos","text":"Na discuss\u00e3o inicial da expositiva chegamos \u00e0 conclus\u00e3o de que se conseguimos realizar N opera\u00e7\u00f5es em paralelo teremos um ganho de no m\u00e1ximo N vezes no desempenho de nosso programa. Nesta parte iremos estudar esta afirma\u00e7\u00e3o usando implementa\u00e7\u00f5es paralelas dos algoritmos da se\u00e7\u00e3o anterior. Example Execute os algoritmos paralelos com as mesmas entradas e compare com suas vers\u00f5es paralelas. Use um gr\u00e1fico para facilitar as compara\u00e7\u00f5es Question Compare os tempos obtidos. Qual foi o ganho m\u00e9dio? Quantos n\u00facleos a m\u00e1quina que voc\u00ea est\u00e1 usando possui? Responda comparando cada algoritmo sequencial com sua vers\u00e3o paralela. J\u00e1 estabelecemos que busca-local-2 \u00e9 melhor que busca-local-1 por ser utilizar um algoritmo mais eficiente e vimos na pr\u00e1tica a diferen\u00e7a entre um algoritmo O(n^3) O(n^3) e um algoritmo O(n^2) O(n^2) . Vamos agora examinar a seguinte quest\u00e3o. \u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2 ? Example Compare o desempenho de busca-local-1-par com busca-local-2 . Fa\u00e7a um gr\u00e1fico Question Com base em seu gr\u00e1fico acima, responda a pergunta: \"\u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2?\" Vamos agora generalizar a pergunta: Question Dados dois algoritmos com complexidades computacionais diferentes, sendo que o primeiro \u00e9 inferior ao segundo. \u00c9 poss\u00edvel usar paralelismo para tornar o primeiro mais r\u00e1pido que o segundo para todos tamanhos de entrada? Assuma que voc\u00ea possui um n\u00famero fixo de n\u00facleos .","title":"Algoritmos paralelos"},{"location":"aulas/02-03-implementacao-c%2B%2B/","text":"02/03 - Implementa\u00e7\u00e3o em C++ \u00b6 A disciplina utilizar\u00e1 a linguagem C++ para implementa\u00e7\u00e3o dos programas. Ela \u00e9 muito usada em implementa\u00e7\u00f5es de alto desempenho e possui recursos muito \u00fateis e que simplificam a programa\u00e7\u00e3o se comparada com C puro. Nas aulas 02 e 03 aprenderemos alguns desses recursos e os utilizaremos para implementa\u00e7\u00e3o de algoritmos simples. Gabaritos e respostas Este curso n\u00e3o fornece c\u00f3digo de resposta para os exerc\u00edcios de sala. Cada exerc\u00edcio \u00e9 acompanhado de um algoritmo em pseudo-c\u00f3digo e alguns pares de arquivos entrada/sa\u00edda. Isto j\u00e1 \u00e9 suficiente para que voc\u00eas verifiquem se sua solu\u00e7\u00e3o est\u00e1 correta. Boas pr\u00e1ticas de programa\u00e7\u00e3o ser\u00e3o demonstradas em exerc\u00edcios corrigidos pelo professor durante o semestre. Compila\u00e7\u00e3o \u00b6 Programas em C++ s\u00e3o compilados com o comando g++ . Ele funciona igual ao gcc que voc\u00eas j\u00e1 usaram em Desafios e Sistemas Hardware-Software. $> g++ -Wall -O3 arquivo.cpp -o executavel Entrada e sa\u00edda em C++ \u00b6 Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream). A maior vantagem de usar cin e cout \u00e9 que n\u00e3o precisamos mais daquelas strings de formata\u00e7\u00e3o estranhas com %d , %s e afins. Podemos passar vari\u00e1veis diretamente para a sa\u00edda do terminal usando o operador << . Veja um exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << \"Sa\u00edda: \" << a << \";\" << b << \" \\n \" ; Example Crie um arquivo entrada-saida.cpp com uma fun\u00e7\u00e3o main que roda o c\u00f3digo acima. Compile e execute seu programa e verifique que ele mostra o valor correto no terminal. O mesmo vale para a entrada, mas desta vez \"tiramos\" os dados do objeto std::cin . O exemplo abaixo l\u00ea um inteiro e um double do terminal. int a ; double b ; std :: cin >> a >> b ; Example Modifique seu programa entrada-saida.cpp para ler \u00ea um n\u00famero inteiro n e mostrar sua divis\u00e3o fracion\u00e1ria por 2. Ou seja, antes de dividir converta n para double . E esse std:: ? Em C++ podemos ter v\u00e1rias fun\u00e7\u00f5es, vari\u00e1veis e objetos em geral com o mesmo nome. Para evitar que eles colidam e n\u00e3o se saiba a qual estamos nos referindo cada nome deve ser definido um namespace (literalmente espaco de nomes ). Podemos ter namespace s aninhados.Por exemplo, std::chrono cont\u00e9m as fun\u00e7\u00f5es relacionadas contagem de tempo durante a execu\u00e7\u00e3o de um programa. Todas as fun\u00e7\u00f5es, classes e globais na biblioteca padr\u00e3o est\u00e3o definidas no espa\u00e7o std . Se quisermos, podemos omitir escrever std:: toda vez digitando using namespace std . Isso pode ser feito tamb\u00e9m com namespaces aninhados. A implementa\u00e7\u00e3o de algoritmos definidos usando express\u00f5es matem\u00e1ticas \u00e9 uma habilidade importante neste curso. Example Escreva um programa que receba um inteiro n e calcule a seguinte s\u00e9rie. S = \\sum_{i=0}^n \\frac{1}{2^i} S = \\sum_{i=0}^n \\frac{1}{2^i} Mostre as primeiras 15 casas decimais de S . Veja a documenta\u00e7\u00e3o de std::setprecision aqui . Resposta Essa s\u00e9rie converge para o n\u00famero 2, mas sua resposta dever\u00e1 ser sempre menor que este n\u00famero. Logo, quanto maior n mais pr\u00f3xima sua resposta ser\u00e1. Seu programa dever\u00e1 implementar algo como o algoritmo abaixo. leia inteiro n s = 0.0 para i=0 at\u00e9 n s += 1 / (2 elevado a i) print(s) Aloca\u00e7\u00e3o de mem\u00f3ria e vetores em C++ \u00b6 Em C usamos as fun\u00e7\u00f5es malloc e free para alocar mem\u00f3ria dinamicamente. Um inconveniente dessas fun\u00e7\u00f5es \u00e9 que sempre temos que passar o tamanho que queremos em bytes. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m est\u00e3o dispon\u00edveis, mas us\u00e1-las \u00e9 considerado uma m\u00e1 pr\u00e1tica. Ao inv\u00e9s, usamos os operadores new e delete para alocar mem\u00f3ria. Existem duas vantagens em us\u00e1-los. Podemos escrever diretamente o tipo que queremos, em vez de seu tamanho em bytes. A aloca\u00e7\u00e3o de arrays \u00e9 feita de maneira natural usando os colchetes [] . Vejamos o exemplo abaixo. int n ; std :: cin >> n ; double * values = new double [ n ]; /* usar values aqui */ delete [] values ; \u00c9 alocado um vetor de double de tamanho n (lido do terminal). Ap\u00f3s ele ser usado liberamos o espa\u00e7o alocado usando delete[] . E se eu quiser alocar um s\u00f3 valor? \u00c9 simples! \u00c9 s\u00f3 usar new sem os colchetes [] ! Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Resposta Use o programa t4.py para gerar entradas e sa\u00eddas de teste para seu programa. Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas? Resposta M\u00e9dia e vari\u00e2ncia. Apesar do uso de new[] e delete[] mostrado na se\u00e7\u00e3o anterior j\u00e1 ser mais conveniente, ainda s\u00e3o essencialmente um programa em C com sintaxe ligeiramente mais agrad\u00e1vel. Para tornar a programa\u00e7\u00e3o em C++ mais produtiva sua biblioteca padr\u00e3o conta com estruturas de dados prontas para uso. A estrutura std::vector \u00e9 um vetor din\u00e2mico que tem funcionalidades parecidas com a lista de Python ou o ArrayList de Java. O c\u00f3digo abaixo exemplifica seu uso e mostra algumas de suas fun\u00e7\u00f5es. Note que omitimos o uso de std no c\u00f3digo abaixo. int n ; cin >> n ; vector < double > vec ; for ( int i = 0 ; i < n ; i ++ ) { vec . push_back ( i * i ) } cout << \"Tamanho do vetor: \" << vec . size () << \" \\n \" ; cout << \"Primeiro elemento: \" << vec . front () << \" \\n \" ; cout << \"\u00daltimo elemento: \" << vec . back () << \" \\n \" ; cout << \"Elemento 3: \" << vec [ 2 ] << \" \\n \" ; Alguns pontos interessantes deste exemplo: N\u00e3o sabemos o tamanho de vec ao cri\u00e1-lo. O m\u00e9todo push_back aumenta ele quando necess\u00e1rio e n\u00e3o precisamos nos preocupar com isso. O n\u00famero de elementos colocados no vetor \u00e9 retornado pelo m\u00e9todo size() O acesso \u00e9 feito exatamente igual ao array de C, usando os colchetes [] E esse <double> na declara\u00e7\u00e3o? Em C++ tipos passados entre < > s\u00e3o usados para parametrizar tipos gen\u00e9ricos. Ou seja, um vetor pode guardar qualquer tipo de dado e precisamos indicar qual ao cri\u00e1-lo. Note que, portanto, um vetor vector<int> e um vetor vector<double> s\u00e3o considerados de tipos diferentes e n\u00e3o posso passar o primeiro para uma fun\u00e7\u00e3o esperando o segundo. Example Modifique sua Tarefa 4 para usar vector . Verifique que o programa continua produzindo os mesmos resultados. Matrizes (vers\u00e3o 1) \u00b6 Dados N pontos com coordenadas (x_i, y_i)_{i=0}^N (x_i, y_i)_{i=0}^N , computar a matriz de dist\u00e2ncias D D tal que D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) Tip Use t6.py para gerar os arquivos de entrada/sa\u00edda da tarefa abaixo. Example Implemente um programa que calcule a matriz D acima. Sua entrada dever\u00e1 estar no formato dos arquivos t6-in-*.txt e sua sa\u00edda no formato dos arquivos t6-out-*.txt . Mostre as dist\u00e2ncias com 2 casas decimais. Dicas : a maneira mais f\u00e1cil (n\u00e3o necessariamente a melhor) de alocar uma matriz \u00e9 usando um vetor em que cada elemento \u00e9 outro vetor. fa\u00e7a uma implementa\u00e7\u00e3o o mais simples poss\u00edvel. Vamos melhor\u00e1-la nas pr\u00f3ximas tarefas. Resposta leia inteiro N leia vetores X e Y seja D uma matriz NxN para i=1..N: para j=1..N: DX = X[i] - X[j] DY = Y[i] - Y[j] D[i,j] = sqrt(DX*DX + DY*DY) Question Anote abaixo o tempo de execu\u00e7\u00e3o para os arquivos t6-in-*.txt e t6-out-*.txt Question Qual \u00e9 a complexidade computacional de sua implementa\u00e7\u00e3o? Refer\u00eancias e passagem de dados \u00b6 Na parte anterior fizemos nosso programa inteiro no main . Vamos agora organiz\u00e1-lo melhor. Example Crie uma fun\u00e7\u00e3o calcula_distancias que recebe a matriz e os dados recebidos na entrada e a preenche. Sua fun\u00e7\u00e3o n\u00e3o dever\u00e1 retornar nenhum valor. Ao terminar, me\u00e7a o tempo de execu\u00e7\u00e3o para o arquivo t6-out-4.txt . Resposta Aqui podem ocorrer dois problemas: Seu programa deu \"Segmentation Fault\". Seu programa rodou at\u00e9 o fim, mas a sa\u00edda \u00e9 vazia (ou cheia de 0). O problema em si depende de como voc\u00ea fez o for duplo para mostrar os resultados. De qualquer maneira, simplesmente mover c\u00f3digo para uma outra fun\u00e7\u00e3o n\u00e3o funciona neste caso. Ambos problemas descritos na solu\u00e7\u00e3o s\u00e3o previs\u00edveis e ocorrem pela mesma raz\u00e3o: ao passar um vector para uma fun\u00e7\u00e3o \u00e9 feita uma c\u00f3pia de seu conte\u00fado . Ou seja, a matriz usada dentro de calcula_distancias n\u00e3o \u00e9 a mesma do main ! Isto \u00e9 considerado uma feature em C++ : por padr\u00e3o toda vari\u00e1vel \u00e9 passada por c\u00f3pia . Isto evita que uma fun\u00e7\u00e3o modifique um valor sem que o c\u00f3digo chamador fique sabendo. Em C podemos passar vari\u00e1veis por refer\u00eancia passando um ponteiro para elas. Apesar de funcional, isso n\u00e3o \u00e9 muito pr\u00e1tico pois temos que acessar a vari\u00e1vel sempre usando * . Em C++ temos um novo recurso: refer\u00eancias. Ao declarar uma vari\u00e1vel como uma refer\u00eancia crio uma esp\u00e9cie de ponteiro constante que sempre acessa a vari\u00e1vel apontada. Veja o exemplo abaixo. int x = 10 ; int & ref = x ; // refer\u00eancias s\u00e3o declaradas colocando & na frente do nome da vari\u00e1vel // a partir daqui ref e x representam a mesma vari\u00e1vel ref = 15 ; cout << x << \" \\n \" ; // 15 O mesmo poderia ser feito com ponteiros (como mostrado abaixo). A grande vantagem da refer\u00eancia \u00e9 que n\u00e3o precisamos usar *ref para nos referirmos \u00e0 vari\u00e1vel x ! Na atribui\u00e7\u00e3o tamb\u00e9m podemos usar direto int &ref = x , o que torna o c\u00f3digo mais limpo e f\u00e1cil de entender. int x = 10 ; int * ref = & x ; // precisamos de &x para apontar ref para a vari\u00e1vel x * ref = 15 ; // precisamos indicar *ref para atribuir a vari\u00e1vel x cout << x << \" \\n \" ; // 15 Dicas Note que uma refer\u00eancia tem que ser inicializada com a vari\u00e1vel a que ela se refere. Ou seja, ao declarar tenho que j\u00e1 indicar a vari\u00e1vel destino e esse destino n\u00e3o pode ser modificado. Example Modifique sua fun\u00e7\u00e3o para usar refer\u00eancias. Verifique que ele volta a funcionar e que seu tempo de execu\u00e7\u00e3o continua parecido com a vers\u00e3o que rodava no main . Resposta Basta adicionar & na frente dos nomes dos argumentos (vetores x, y e matriz). A chamada da fun\u00e7\u00e3o n\u00e3o muda. Dica Em C++ precisamos estar sempre atentos \u00e0 maneira que passamos os dados. Se n\u00e3o indicarmos ser\u00e1 por c\u00f3pia. Para compartilhar o mesmo objeto entre v\u00e1rias fun\u00e7\u00f5es usamos refer\u00eancias & . Uma primeira otimiza\u00e7\u00e3o \u00b6 Nossa primeira implementa\u00e7\u00e3o \u00e9 bastante direta da defini\u00e7\u00e3o e n\u00e3o tenta ser eficiente. Question Analisando a defini\u00e7ao da Tarefa 1, como seria poss\u00edvel economizar trabalho? Resposta Podemos ver que a matriz D \u00e9 sim\u00e9trica. Ou seja, D[i,j] == D[j,i] . Isso significa que poder\u00edamos calcular s\u00f3 um deles e copiar o valor para a outra posi\u00e7\u00e3o. Question Como isso poderia ser usado para melhorar o tempo de execu\u00e7\u00e3o de calcula_distancias ? Question Seu programa criado na tarefa 1 consegue ser adaptado para implementar sua ideia da quest\u00e3o anterior? O que precisaria ser modificado? Resposta Duas respostas s\u00e3o poss\u00edveis e corretas aqui: Preciso checar se o i > j e usar o valor j\u00e1 calculado de D[j,i] . \u00c9 preciso alocar a matriz inteira antes de come\u00e7ar. Se formos dando push_back linha a linha n\u00e3o conseguimos atribuir um valor ao mesmo tempo a D[i,j] e D[j,i] , j\u00e1 que um deles ainda n\u00e3o ter\u00e1 sido criado. Baseado na resposta acima vamos tentar nossa primeira otimiza\u00e7\u00e3o: s\u00f3 vamos calcular D[i,j] para i <= j (ou seja, s\u00f3 a metade \"de cima\" de D ). Example Use a estrat\u00e9gia acima para evitar calcular a matriz inteira. Verifique se houve melhora no tempo do teste t6-in-3.txt . Dica : tente de novo usar a ideia mais simples poss\u00edvel e implemente adicionando um so if no seu programa. Resposta N\u00e3o dever\u00e1 haver ganho de desempenho significativo. Veremos exatamente o por que na pr\u00f3xima aula.","title":"02/03 - Implementa\u00e7\u00e3o em C++"},{"location":"aulas/02-03-implementacao-c%2B%2B/#0203-implementacao-em-c","text":"A disciplina utilizar\u00e1 a linguagem C++ para implementa\u00e7\u00e3o dos programas. Ela \u00e9 muito usada em implementa\u00e7\u00f5es de alto desempenho e possui recursos muito \u00fateis e que simplificam a programa\u00e7\u00e3o se comparada com C puro. Nas aulas 02 e 03 aprenderemos alguns desses recursos e os utilizaremos para implementa\u00e7\u00e3o de algoritmos simples. Gabaritos e respostas Este curso n\u00e3o fornece c\u00f3digo de resposta para os exerc\u00edcios de sala. Cada exerc\u00edcio \u00e9 acompanhado de um algoritmo em pseudo-c\u00f3digo e alguns pares de arquivos entrada/sa\u00edda. Isto j\u00e1 \u00e9 suficiente para que voc\u00eas verifiquem se sua solu\u00e7\u00e3o est\u00e1 correta. Boas pr\u00e1ticas de programa\u00e7\u00e3o ser\u00e3o demonstradas em exerc\u00edcios corrigidos pelo professor durante o semestre.","title":"02/03 - Implementa\u00e7\u00e3o em C++"},{"location":"aulas/02-03-implementacao-c%2B%2B/#compilacao","text":"Programas em C++ s\u00e3o compilados com o comando g++ . Ele funciona igual ao gcc que voc\u00eas j\u00e1 usaram em Desafios e Sistemas Hardware-Software. $> g++ -Wall -O3 arquivo.cpp -o executavel","title":"Compila\u00e7\u00e3o"},{"location":"aulas/02-03-implementacao-c%2B%2B/#entrada-e-saida-em-c","text":"Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream). A maior vantagem de usar cin e cout \u00e9 que n\u00e3o precisamos mais daquelas strings de formata\u00e7\u00e3o estranhas com %d , %s e afins. Podemos passar vari\u00e1veis diretamente para a sa\u00edda do terminal usando o operador << . Veja um exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << \"Sa\u00edda: \" << a << \";\" << b << \" \\n \" ; Example Crie um arquivo entrada-saida.cpp com uma fun\u00e7\u00e3o main que roda o c\u00f3digo acima. Compile e execute seu programa e verifique que ele mostra o valor correto no terminal. O mesmo vale para a entrada, mas desta vez \"tiramos\" os dados do objeto std::cin . O exemplo abaixo l\u00ea um inteiro e um double do terminal. int a ; double b ; std :: cin >> a >> b ; Example Modifique seu programa entrada-saida.cpp para ler \u00ea um n\u00famero inteiro n e mostrar sua divis\u00e3o fracion\u00e1ria por 2. Ou seja, antes de dividir converta n para double . E esse std:: ? Em C++ podemos ter v\u00e1rias fun\u00e7\u00f5es, vari\u00e1veis e objetos em geral com o mesmo nome. Para evitar que eles colidam e n\u00e3o se saiba a qual estamos nos referindo cada nome deve ser definido um namespace (literalmente espaco de nomes ). Podemos ter namespace s aninhados.Por exemplo, std::chrono cont\u00e9m as fun\u00e7\u00f5es relacionadas contagem de tempo durante a execu\u00e7\u00e3o de um programa. Todas as fun\u00e7\u00f5es, classes e globais na biblioteca padr\u00e3o est\u00e3o definidas no espa\u00e7o std . Se quisermos, podemos omitir escrever std:: toda vez digitando using namespace std . Isso pode ser feito tamb\u00e9m com namespaces aninhados. A implementa\u00e7\u00e3o de algoritmos definidos usando express\u00f5es matem\u00e1ticas \u00e9 uma habilidade importante neste curso. Example Escreva um programa que receba um inteiro n e calcule a seguinte s\u00e9rie. S = \\sum_{i=0}^n \\frac{1}{2^i} S = \\sum_{i=0}^n \\frac{1}{2^i} Mostre as primeiras 15 casas decimais de S . Veja a documenta\u00e7\u00e3o de std::setprecision aqui . Resposta Essa s\u00e9rie converge para o n\u00famero 2, mas sua resposta dever\u00e1 ser sempre menor que este n\u00famero. Logo, quanto maior n mais pr\u00f3xima sua resposta ser\u00e1. Seu programa dever\u00e1 implementar algo como o algoritmo abaixo. leia inteiro n s = 0.0 para i=0 at\u00e9 n s += 1 / (2 elevado a i) print(s)","title":"Entrada e sa\u00edda em C++"},{"location":"aulas/02-03-implementacao-c%2B%2B/#alocacao-de-memoria-e-vetores-em-c","text":"Em C usamos as fun\u00e7\u00f5es malloc e free para alocar mem\u00f3ria dinamicamente. Um inconveniente dessas fun\u00e7\u00f5es \u00e9 que sempre temos que passar o tamanho que queremos em bytes. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m est\u00e3o dispon\u00edveis, mas us\u00e1-las \u00e9 considerado uma m\u00e1 pr\u00e1tica. Ao inv\u00e9s, usamos os operadores new e delete para alocar mem\u00f3ria. Existem duas vantagens em us\u00e1-los. Podemos escrever diretamente o tipo que queremos, em vez de seu tamanho em bytes. A aloca\u00e7\u00e3o de arrays \u00e9 feita de maneira natural usando os colchetes [] . Vejamos o exemplo abaixo. int n ; std :: cin >> n ; double * values = new double [ n ]; /* usar values aqui */ delete [] values ; \u00c9 alocado um vetor de double de tamanho n (lido do terminal). Ap\u00f3s ele ser usado liberamos o espa\u00e7o alocado usando delete[] . E se eu quiser alocar um s\u00f3 valor? \u00c9 simples! \u00c9 s\u00f3 usar new sem os colchetes [] ! Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Resposta Use o programa t4.py para gerar entradas e sa\u00eddas de teste para seu programa. Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas? Resposta M\u00e9dia e vari\u00e2ncia. Apesar do uso de new[] e delete[] mostrado na se\u00e7\u00e3o anterior j\u00e1 ser mais conveniente, ainda s\u00e3o essencialmente um programa em C com sintaxe ligeiramente mais agrad\u00e1vel. Para tornar a programa\u00e7\u00e3o em C++ mais produtiva sua biblioteca padr\u00e3o conta com estruturas de dados prontas para uso. A estrutura std::vector \u00e9 um vetor din\u00e2mico que tem funcionalidades parecidas com a lista de Python ou o ArrayList de Java. O c\u00f3digo abaixo exemplifica seu uso e mostra algumas de suas fun\u00e7\u00f5es. Note que omitimos o uso de std no c\u00f3digo abaixo. int n ; cin >> n ; vector < double > vec ; for ( int i = 0 ; i < n ; i ++ ) { vec . push_back ( i * i ) } cout << \"Tamanho do vetor: \" << vec . size () << \" \\n \" ; cout << \"Primeiro elemento: \" << vec . front () << \" \\n \" ; cout << \"\u00daltimo elemento: \" << vec . back () << \" \\n \" ; cout << \"Elemento 3: \" << vec [ 2 ] << \" \\n \" ; Alguns pontos interessantes deste exemplo: N\u00e3o sabemos o tamanho de vec ao cri\u00e1-lo. O m\u00e9todo push_back aumenta ele quando necess\u00e1rio e n\u00e3o precisamos nos preocupar com isso. O n\u00famero de elementos colocados no vetor \u00e9 retornado pelo m\u00e9todo size() O acesso \u00e9 feito exatamente igual ao array de C, usando os colchetes [] E esse <double> na declara\u00e7\u00e3o? Em C++ tipos passados entre < > s\u00e3o usados para parametrizar tipos gen\u00e9ricos. Ou seja, um vetor pode guardar qualquer tipo de dado e precisamos indicar qual ao cri\u00e1-lo. Note que, portanto, um vetor vector<int> e um vetor vector<double> s\u00e3o considerados de tipos diferentes e n\u00e3o posso passar o primeiro para uma fun\u00e7\u00e3o esperando o segundo. Example Modifique sua Tarefa 4 para usar vector . Verifique que o programa continua produzindo os mesmos resultados.","title":"Aloca\u00e7\u00e3o de mem\u00f3ria e vetores em C++"},{"location":"aulas/02-03-implementacao-c%2B%2B/#matrizes-versao-1","text":"Dados N pontos com coordenadas (x_i, y_i)_{i=0}^N (x_i, y_i)_{i=0}^N , computar a matriz de dist\u00e2ncias D D tal que D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) Tip Use t6.py para gerar os arquivos de entrada/sa\u00edda da tarefa abaixo. Example Implemente um programa que calcule a matriz D acima. Sua entrada dever\u00e1 estar no formato dos arquivos t6-in-*.txt e sua sa\u00edda no formato dos arquivos t6-out-*.txt . Mostre as dist\u00e2ncias com 2 casas decimais. Dicas : a maneira mais f\u00e1cil (n\u00e3o necessariamente a melhor) de alocar uma matriz \u00e9 usando um vetor em que cada elemento \u00e9 outro vetor. fa\u00e7a uma implementa\u00e7\u00e3o o mais simples poss\u00edvel. Vamos melhor\u00e1-la nas pr\u00f3ximas tarefas. Resposta leia inteiro N leia vetores X e Y seja D uma matriz NxN para i=1..N: para j=1..N: DX = X[i] - X[j] DY = Y[i] - Y[j] D[i,j] = sqrt(DX*DX + DY*DY) Question Anote abaixo o tempo de execu\u00e7\u00e3o para os arquivos t6-in-*.txt e t6-out-*.txt Question Qual \u00e9 a complexidade computacional de sua implementa\u00e7\u00e3o?","title":"Matrizes (vers\u00e3o 1)"},{"location":"aulas/02-03-implementacao-c%2B%2B/#referencias-e-passagem-de-dados","text":"Na parte anterior fizemos nosso programa inteiro no main . Vamos agora organiz\u00e1-lo melhor. Example Crie uma fun\u00e7\u00e3o calcula_distancias que recebe a matriz e os dados recebidos na entrada e a preenche. Sua fun\u00e7\u00e3o n\u00e3o dever\u00e1 retornar nenhum valor. Ao terminar, me\u00e7a o tempo de execu\u00e7\u00e3o para o arquivo t6-out-4.txt . Resposta Aqui podem ocorrer dois problemas: Seu programa deu \"Segmentation Fault\". Seu programa rodou at\u00e9 o fim, mas a sa\u00edda \u00e9 vazia (ou cheia de 0). O problema em si depende de como voc\u00ea fez o for duplo para mostrar os resultados. De qualquer maneira, simplesmente mover c\u00f3digo para uma outra fun\u00e7\u00e3o n\u00e3o funciona neste caso. Ambos problemas descritos na solu\u00e7\u00e3o s\u00e3o previs\u00edveis e ocorrem pela mesma raz\u00e3o: ao passar um vector para uma fun\u00e7\u00e3o \u00e9 feita uma c\u00f3pia de seu conte\u00fado . Ou seja, a matriz usada dentro de calcula_distancias n\u00e3o \u00e9 a mesma do main ! Isto \u00e9 considerado uma feature em C++ : por padr\u00e3o toda vari\u00e1vel \u00e9 passada por c\u00f3pia . Isto evita que uma fun\u00e7\u00e3o modifique um valor sem que o c\u00f3digo chamador fique sabendo. Em C podemos passar vari\u00e1veis por refer\u00eancia passando um ponteiro para elas. Apesar de funcional, isso n\u00e3o \u00e9 muito pr\u00e1tico pois temos que acessar a vari\u00e1vel sempre usando * . Em C++ temos um novo recurso: refer\u00eancias. Ao declarar uma vari\u00e1vel como uma refer\u00eancia crio uma esp\u00e9cie de ponteiro constante que sempre acessa a vari\u00e1vel apontada. Veja o exemplo abaixo. int x = 10 ; int & ref = x ; // refer\u00eancias s\u00e3o declaradas colocando & na frente do nome da vari\u00e1vel // a partir daqui ref e x representam a mesma vari\u00e1vel ref = 15 ; cout << x << \" \\n \" ; // 15 O mesmo poderia ser feito com ponteiros (como mostrado abaixo). A grande vantagem da refer\u00eancia \u00e9 que n\u00e3o precisamos usar *ref para nos referirmos \u00e0 vari\u00e1vel x ! Na atribui\u00e7\u00e3o tamb\u00e9m podemos usar direto int &ref = x , o que torna o c\u00f3digo mais limpo e f\u00e1cil de entender. int x = 10 ; int * ref = & x ; // precisamos de &x para apontar ref para a vari\u00e1vel x * ref = 15 ; // precisamos indicar *ref para atribuir a vari\u00e1vel x cout << x << \" \\n \" ; // 15 Dicas Note que uma refer\u00eancia tem que ser inicializada com a vari\u00e1vel a que ela se refere. Ou seja, ao declarar tenho que j\u00e1 indicar a vari\u00e1vel destino e esse destino n\u00e3o pode ser modificado. Example Modifique sua fun\u00e7\u00e3o para usar refer\u00eancias. Verifique que ele volta a funcionar e que seu tempo de execu\u00e7\u00e3o continua parecido com a vers\u00e3o que rodava no main . Resposta Basta adicionar & na frente dos nomes dos argumentos (vetores x, y e matriz). A chamada da fun\u00e7\u00e3o n\u00e3o muda. Dica Em C++ precisamos estar sempre atentos \u00e0 maneira que passamos os dados. Se n\u00e3o indicarmos ser\u00e1 por c\u00f3pia. Para compartilhar o mesmo objeto entre v\u00e1rias fun\u00e7\u00f5es usamos refer\u00eancias & .","title":"Refer\u00eancias e passagem de dados"},{"location":"aulas/02-03-implementacao-c%2B%2B/#uma-primeira-otimizacao","text":"Nossa primeira implementa\u00e7\u00e3o \u00e9 bastante direta da defini\u00e7\u00e3o e n\u00e3o tenta ser eficiente. Question Analisando a defini\u00e7ao da Tarefa 1, como seria poss\u00edvel economizar trabalho? Resposta Podemos ver que a matriz D \u00e9 sim\u00e9trica. Ou seja, D[i,j] == D[j,i] . Isso significa que poder\u00edamos calcular s\u00f3 um deles e copiar o valor para a outra posi\u00e7\u00e3o. Question Como isso poderia ser usado para melhorar o tempo de execu\u00e7\u00e3o de calcula_distancias ? Question Seu programa criado na tarefa 1 consegue ser adaptado para implementar sua ideia da quest\u00e3o anterior? O que precisaria ser modificado? Resposta Duas respostas s\u00e3o poss\u00edveis e corretas aqui: Preciso checar se o i > j e usar o valor j\u00e1 calculado de D[j,i] . \u00c9 preciso alocar a matriz inteira antes de come\u00e7ar. Se formos dando push_back linha a linha n\u00e3o conseguimos atribuir um valor ao mesmo tempo a D[i,j] e D[j,i] , j\u00e1 que um deles ainda n\u00e3o ter\u00e1 sido criado. Baseado na resposta acima vamos tentar nossa primeira otimiza\u00e7\u00e3o: s\u00f3 vamos calcular D[i,j] para i <= j (ou seja, s\u00f3 a metade \"de cima\" de D ). Example Use a estrat\u00e9gia acima para evitar calcular a matriz inteira. Verifique se houve melhora no tempo do teste t6-in-3.txt . Dica : tente de novo usar a ideia mais simples poss\u00edvel e implemente adicionando um so if no seu programa. Resposta N\u00e3o dever\u00e1 haver ganho de desempenho significativo. Veremos exatamente o por que na pr\u00f3xima aula.","title":"Uma primeira otimiza\u00e7\u00e3o"},{"location":"aulas/04-profiling/","text":"04 - Medi\u00e7\u00e3o de desempenho \u00b6 Apesar de podermos medir o tempo que nosso programa demora usando o comando time , n\u00e3o conseguimos nenhuma informa\u00e7\u00e3o importante de qual parte do programa est\u00e1 consumindo mais tempo. Este processo de dissecar um programa e entender exatamente qual parte demora quanto \u00e9 chamada de Profiling . Software Para esta aula precisaremos dos seguintes pacotes instalados. valgrind - ferramenta de an\u00e1lise de c\u00f3digo execut\u00e1vel kcachegrind - visualizador de resultados do valgrind Prepara\u00e7\u00e3o \u00b6 \u00c9 preciso compilar um execut\u00e1vel com profiling habilitado para medir os tempos. g++ -g euclides-ingenuo.cpp -o euclides-ingenuo Ap\u00f3s este passo, devemos executar o programa usando o valgrind com as op\u00e7\u00f5es abaixo. valgrind --tool=callgrind ./seu_exec < entrada > saida Para mostrar os resultados usando o kcachegrind usamos o seguinte comando. kcachegrind callgrind.out.(pid aqui) Medindo os tempos no seu pr\u00f3prio programa \u00b6 Na demonstra\u00e7\u00e3o pudemos ver que grande parte do tempo do programa da Tarefa 1 \u00e9 gasto mostrando a sa\u00edda no terminal. Isto nos leva \u00e0 primeira conclus\u00e3o da atividade de hoje: Entrada e sa\u00edda de dados s\u00e3o opera\u00e7\u00f5es muito lentas Example Fa\u00e7a o teste da demonstra\u00e7\u00e3o em seu pr\u00f3prio programa e anote abaixo, para as duas vers\u00f5es de calcula_distancias , o tempo relativo de execu\u00e7\u00e3o o n\u00famero absoluto de instru\u00e7\u00f5es executadas Question O n\u00famero absoluto de intru\u00e7\u00f5es executadas diminuiu significativamente depois de nossa otimiza\u00e7\u00e3o? Teoricamente s\u00f3 calculamos metade da matriz, esse n\u00famero \u00e9 quase metade da vers\u00e3o n\u00e3o otimizada? Voc\u00ea consegue dizer por que? Resposta Deve ter havido uma diminui\u00e7\u00e3o, mas n\u00e3o chega nem perto de metade. Isso ocorre por v\u00e1rias raz\u00f5es: nosso for duplo continua percorrendo a matriz inteira, apesar de s\u00f3 fazer o c\u00e1lculo em metade das posi\u00e7\u00f5es. alocamos a matriz elemento a elemento enquanto fazemos os c\u00e1lculos. Com isso em mente, vamos agora otimizar a fun\u00e7\u00e3o calcula_distancias . J\u00e1 sabemos que o efeito no tempo final n\u00e3o ser\u00e1 grande. Nosso objetivo ent\u00e3o ser\u00e1 verificar a seguinte afirma\u00e7\u00e3o. Dois algoritmos de mesma complexidade computacional podem ter tempos de execu\u00e7\u00e3o muito diferentes Question A resposta da quest\u00e3o anterior indica que s\u00f3 usar um if para evitar o c\u00e1lculo repetido n\u00e3o \u00e9 suficiente. Precisamos efetivamente fazer um for que percorre s\u00f3 metade da matriz. Supondo que a matriz j\u00e1 esteja inteira alocada, escreva em pseudo-c\u00f3digo como faz\u00ea-lo. Resposta para i=1..N: para j=i..N: DX = X[i] - X[j] DY = Y[i] - Y[j] DIST = sqrt(DX*DX + DY*DY) D[i,j] = DIST D[j,i] = DIST Matrizes (vers\u00e3o 2) \u00b6 Nossa implementa\u00e7\u00e3o usando vector<vector<double>> tem um problema s\u00e9rio: ela aloca elemento a elemento uma estrutura grande que j\u00e1 sabemos o tamanho de in\u00edcio. Seria muito melhor se pud\u00e9ssemos alocar todas as N^2 N^2 posi\u00e7\u00f5es da matriz de uma s\u00f3 vez! Fazemos isso trabalhando com um layout de mem\u00f3ria cont\u00ednuo. Ou seja, armazenaremos a matriz linha a linha como um \u00fanico vetor de tamanho n*n . Temos v\u00e1rias vantagens: tempo de aloca\u00e7\u00e3o de mem\u00f3ria \u00e9 reduzido, j\u00e1 que s\u00f3 fazemos uma chamada podemos acessar qualquer posi\u00e7\u00e3o a qualquer momento melhor desempenho de cache A figura abaixo exemplifica esse layout de mem\u00f3ria: Question Em uma matriz de tamanho 4x7 (4 linhas, 7 colunas), qual \u00e9 o elemento do vetor que representa a posi\u00e7\u00e3o 2x5 (linha 3, coluna 6)? Details Estamos considerando que come\u00e7amos a contar as linhas e colunas do zero. A posi\u00e7\u00e3o do vetor \u00e9 19 . Este n\u00famero \u00e9 obtido pela express\u00e3o i * c + j i \u00e9 a linha a ser acessada j \u00e9 a coluna c \u00e9 o n\u00famero de colunas da matriz 19 = 2 * 7 + 5 Tip Conseguimos redimensionar um vetor usando o m\u00e9todo resize , que recebe o novo n\u00famero de elementos do vetor. Example Fa\u00e7a uma terceira vers\u00e3o de calcula_distancias , desta vez usando o layout de mem\u00f3ria acima. Verifique que o programa continua retornando os mesmos resultados que as vers\u00f5es anteriores. Question Rode novamente os testes de profiling e verifique o n\u00famero de instru\u00e7\u00f5es para esta nova vers\u00e3o. Compare este valor com os anteriores e comente.","title":"04 - Medi\u00e7\u00e3o de desempenho"},{"location":"aulas/04-profiling/#04-medicao-de-desempenho","text":"Apesar de podermos medir o tempo que nosso programa demora usando o comando time , n\u00e3o conseguimos nenhuma informa\u00e7\u00e3o importante de qual parte do programa est\u00e1 consumindo mais tempo. Este processo de dissecar um programa e entender exatamente qual parte demora quanto \u00e9 chamada de Profiling . Software Para esta aula precisaremos dos seguintes pacotes instalados. valgrind - ferramenta de an\u00e1lise de c\u00f3digo execut\u00e1vel kcachegrind - visualizador de resultados do valgrind","title":"04 - Medi\u00e7\u00e3o de desempenho"},{"location":"aulas/04-profiling/#preparacao","text":"\u00c9 preciso compilar um execut\u00e1vel com profiling habilitado para medir os tempos. g++ -g euclides-ingenuo.cpp -o euclides-ingenuo Ap\u00f3s este passo, devemos executar o programa usando o valgrind com as op\u00e7\u00f5es abaixo. valgrind --tool=callgrind ./seu_exec < entrada > saida Para mostrar os resultados usando o kcachegrind usamos o seguinte comando. kcachegrind callgrind.out.(pid aqui)","title":"Prepara\u00e7\u00e3o"},{"location":"aulas/04-profiling/#medindo-os-tempos-no-seu-proprio-programa","text":"Na demonstra\u00e7\u00e3o pudemos ver que grande parte do tempo do programa da Tarefa 1 \u00e9 gasto mostrando a sa\u00edda no terminal. Isto nos leva \u00e0 primeira conclus\u00e3o da atividade de hoje: Entrada e sa\u00edda de dados s\u00e3o opera\u00e7\u00f5es muito lentas Example Fa\u00e7a o teste da demonstra\u00e7\u00e3o em seu pr\u00f3prio programa e anote abaixo, para as duas vers\u00f5es de calcula_distancias , o tempo relativo de execu\u00e7\u00e3o o n\u00famero absoluto de instru\u00e7\u00f5es executadas Question O n\u00famero absoluto de intru\u00e7\u00f5es executadas diminuiu significativamente depois de nossa otimiza\u00e7\u00e3o? Teoricamente s\u00f3 calculamos metade da matriz, esse n\u00famero \u00e9 quase metade da vers\u00e3o n\u00e3o otimizada? Voc\u00ea consegue dizer por que? Resposta Deve ter havido uma diminui\u00e7\u00e3o, mas n\u00e3o chega nem perto de metade. Isso ocorre por v\u00e1rias raz\u00f5es: nosso for duplo continua percorrendo a matriz inteira, apesar de s\u00f3 fazer o c\u00e1lculo em metade das posi\u00e7\u00f5es. alocamos a matriz elemento a elemento enquanto fazemos os c\u00e1lculos. Com isso em mente, vamos agora otimizar a fun\u00e7\u00e3o calcula_distancias . J\u00e1 sabemos que o efeito no tempo final n\u00e3o ser\u00e1 grande. Nosso objetivo ent\u00e3o ser\u00e1 verificar a seguinte afirma\u00e7\u00e3o. Dois algoritmos de mesma complexidade computacional podem ter tempos de execu\u00e7\u00e3o muito diferentes Question A resposta da quest\u00e3o anterior indica que s\u00f3 usar um if para evitar o c\u00e1lculo repetido n\u00e3o \u00e9 suficiente. Precisamos efetivamente fazer um for que percorre s\u00f3 metade da matriz. Supondo que a matriz j\u00e1 esteja inteira alocada, escreva em pseudo-c\u00f3digo como faz\u00ea-lo. Resposta para i=1..N: para j=i..N: DX = X[i] - X[j] DY = Y[i] - Y[j] DIST = sqrt(DX*DX + DY*DY) D[i,j] = DIST D[j,i] = DIST","title":"Medindo os tempos no seu pr\u00f3prio programa"},{"location":"aulas/04-profiling/#matrizes-versao-2","text":"Nossa implementa\u00e7\u00e3o usando vector<vector<double>> tem um problema s\u00e9rio: ela aloca elemento a elemento uma estrutura grande que j\u00e1 sabemos o tamanho de in\u00edcio. Seria muito melhor se pud\u00e9ssemos alocar todas as N^2 N^2 posi\u00e7\u00f5es da matriz de uma s\u00f3 vez! Fazemos isso trabalhando com um layout de mem\u00f3ria cont\u00ednuo. Ou seja, armazenaremos a matriz linha a linha como um \u00fanico vetor de tamanho n*n . Temos v\u00e1rias vantagens: tempo de aloca\u00e7\u00e3o de mem\u00f3ria \u00e9 reduzido, j\u00e1 que s\u00f3 fazemos uma chamada podemos acessar qualquer posi\u00e7\u00e3o a qualquer momento melhor desempenho de cache A figura abaixo exemplifica esse layout de mem\u00f3ria: Question Em uma matriz de tamanho 4x7 (4 linhas, 7 colunas), qual \u00e9 o elemento do vetor que representa a posi\u00e7\u00e3o 2x5 (linha 3, coluna 6)? Details Estamos considerando que come\u00e7amos a contar as linhas e colunas do zero. A posi\u00e7\u00e3o do vetor \u00e9 19 . Este n\u00famero \u00e9 obtido pela express\u00e3o i * c + j i \u00e9 a linha a ser acessada j \u00e9 a coluna c \u00e9 o n\u00famero de colunas da matriz 19 = 2 * 7 + 5 Tip Conseguimos redimensionar um vetor usando o m\u00e9todo resize , que recebe o novo n\u00famero de elementos do vetor. Example Fa\u00e7a uma terceira vers\u00e3o de calcula_distancias , desta vez usando o layout de mem\u00f3ria acima. Verifique que o programa continua retornando os mesmos resultados que as vers\u00f5es anteriores. Question Rode novamente os testes de profiling e verifique o n\u00famero de instru\u00e7\u00f5es para esta nova vers\u00e3o. Compare este valor com os anteriores e comente.","title":"Matrizes (vers\u00e3o 2)"},{"location":"aulas/05-heuristicas/","text":"05 - Heur\u00edsticas \u00b6 A atividade pr\u00e1tica de hoje consiste em implementar heur\u00edsticas para a solu\u00e7\u00e3o do problema da Mochila bin\u00e1ria . Resumo do problema \u00b6 Dados N objetos e uma mochila que comporta at\u00e9 W quilos, cada um com peso w_i w_i e valor v_i v_i , selecionar objetos com o maior valor poss\u00edvel que caibam dentro da mochila. Entrada : N W w1 v1 .... wN vN Sa\u00edda : W V opt o1 ... oT W - peso dos objetos selecionados V - valor dos objetos selecionados opt 0 se for usada uma heur\u00edstica ou busca local 1 se a solu\u00e7\u00e3o for \u00f3timo global oi s\u00e3o os \u00edndices ( em ordem crescente ) dos objetos selecionados Tip Arquivos para verificar a corretude das suas implementa\u00e7\u00f5es est\u00e3o dispon\u00edveis nesta pasta. Eles est\u00e3o nomeados como in-*.txt , mais-caro-out-*.txt e mais-leve-out-*.txt . Mais caro primeiro \u00b6 A ideia desta heur\u00edstica \u00e9 n\u00e3o deixar nenhum objeto valioso para tr\u00e1s! Por isso vamos ser ganaciosos e pegar primeiro os objetos mais caros ! Se um objeto valioso n\u00e3o couber passamos para os mais baratos e prosseguimos at\u00e9 examinar todos objetos. Question Escreva abaixo um algoritmo em pseudo-c\u00f3digo para implementar a heur\u00edstica descrita acima. Resposta ids = // vetor inicializado com ids[i] = i ordene os vetores ids, v e w de acordo com o vetor de valores v peso = 0 valor = 0 resposta = //vetor inicializado com 0 T = 0 // n\u00famero de objetos selecionados para i=1..N se peso + w[i] < W ent\u00e3o resposta[T] = ids[i] peso += w[i] valor += v[i] T += 1 print peso, valor, 0 print resposta[0 .. T] Question Qual \u00e9 a complexidade computacional deste algoritmo? Ele \u00e9 a melhor implementa\u00e7\u00e3o poss\u00edvel? Resposta Se o algoritmo descrito em sua resposta anterior envolver ordena\u00e7\u00e3o, ent\u00e3o ele tem complexidade \\mathcal{O}(n\\log n) \\mathcal{O}(n\\log n) e \u00e9 o melhor poss\u00edvel sim (voc\u00ea consegue explicar por que?). Se voc\u00ea fez um loop duplo que procura pelo maior a cada itera\u00e7\u00e3o ent\u00e3o seu algoritmo \u00e9 \\mathcal{O}(n^2) \\mathcal{O}(n^2) . Example Agora que temos um algoritmo, crie uma implementa\u00e7\u00e3o do programa acima. Dicas : C++ j\u00e1 possui um algoritmo de ordena\u00e7\u00e3o implementado no cabe\u00e7alho <algorithm> . Use-o. Busque por ordena\u00e7\u00e3o indireta para entender como ordenar os tr\u00eas vetores ao mesmo tempo. Pode ser conveniente organizar os dados usando struct . Mais leve primeiro \u00b6 Vamos testar uma abordagem oposta: quantidade agora \u00e9 o foco . Por isso vamos ser pr\u00e1ticos e pegar o maior n\u00famero de objetos poss\u00edvel ! Come\u00e7aremos agora pelos objetos mais leves e vamos torcer para que a quantidade grande de objetos selecionados resulte em uma mochila com alto valor. Question Compare esta heur\u00edstica com a da se\u00e7\u00e3o anterior levando em conta o algoritmo em pseudo-c\u00f3digo e sua complexidade computacional. Question Quais partes do programa da heur\u00edstica anterior podem ser aproveitadas para implementar a descrita acima? Example Implemente agora a heur\u00edstica do mais leve. Chame seu programa de mais_leve , mantendo tamb\u00e9m o c\u00f3digo do anterior. Analisando nossas heur\u00edsticas \u00b6 Question Crie uma entrada em que a heur\u00edstica do mais valioso seja muito melhor que a do mais leve. Escreva abaixo as sa\u00eddas de cada programa. Question Crie uma entrada em que a heur\u00edstica do mais leve seja muito melhor que a do mais valioso. Escreva abaixo as sa\u00eddas de cada programa. Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais valioso \u00e9 melhor? Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais leve \u00e9 melhor?","title":"05 - Heur\u00edsticas"},{"location":"aulas/05-heuristicas/#05-heuristicas","text":"A atividade pr\u00e1tica de hoje consiste em implementar heur\u00edsticas para a solu\u00e7\u00e3o do problema da Mochila bin\u00e1ria .","title":"05 - Heur\u00edsticas"},{"location":"aulas/05-heuristicas/#resumo-do-problema","text":"Dados N objetos e uma mochila que comporta at\u00e9 W quilos, cada um com peso w_i w_i e valor v_i v_i , selecionar objetos com o maior valor poss\u00edvel que caibam dentro da mochila. Entrada : N W w1 v1 .... wN vN Sa\u00edda : W V opt o1 ... oT W - peso dos objetos selecionados V - valor dos objetos selecionados opt 0 se for usada uma heur\u00edstica ou busca local 1 se a solu\u00e7\u00e3o for \u00f3timo global oi s\u00e3o os \u00edndices ( em ordem crescente ) dos objetos selecionados Tip Arquivos para verificar a corretude das suas implementa\u00e7\u00f5es est\u00e3o dispon\u00edveis nesta pasta. Eles est\u00e3o nomeados como in-*.txt , mais-caro-out-*.txt e mais-leve-out-*.txt .","title":"Resumo do problema"},{"location":"aulas/05-heuristicas/#mais-caro-primeiro","text":"A ideia desta heur\u00edstica \u00e9 n\u00e3o deixar nenhum objeto valioso para tr\u00e1s! Por isso vamos ser ganaciosos e pegar primeiro os objetos mais caros ! Se um objeto valioso n\u00e3o couber passamos para os mais baratos e prosseguimos at\u00e9 examinar todos objetos. Question Escreva abaixo um algoritmo em pseudo-c\u00f3digo para implementar a heur\u00edstica descrita acima. Resposta ids = // vetor inicializado com ids[i] = i ordene os vetores ids, v e w de acordo com o vetor de valores v peso = 0 valor = 0 resposta = //vetor inicializado com 0 T = 0 // n\u00famero de objetos selecionados para i=1..N se peso + w[i] < W ent\u00e3o resposta[T] = ids[i] peso += w[i] valor += v[i] T += 1 print peso, valor, 0 print resposta[0 .. T] Question Qual \u00e9 a complexidade computacional deste algoritmo? Ele \u00e9 a melhor implementa\u00e7\u00e3o poss\u00edvel? Resposta Se o algoritmo descrito em sua resposta anterior envolver ordena\u00e7\u00e3o, ent\u00e3o ele tem complexidade \\mathcal{O}(n\\log n) \\mathcal{O}(n\\log n) e \u00e9 o melhor poss\u00edvel sim (voc\u00ea consegue explicar por que?). Se voc\u00ea fez um loop duplo que procura pelo maior a cada itera\u00e7\u00e3o ent\u00e3o seu algoritmo \u00e9 \\mathcal{O}(n^2) \\mathcal{O}(n^2) . Example Agora que temos um algoritmo, crie uma implementa\u00e7\u00e3o do programa acima. Dicas : C++ j\u00e1 possui um algoritmo de ordena\u00e7\u00e3o implementado no cabe\u00e7alho <algorithm> . Use-o. Busque por ordena\u00e7\u00e3o indireta para entender como ordenar os tr\u00eas vetores ao mesmo tempo. Pode ser conveniente organizar os dados usando struct .","title":"Mais caro primeiro"},{"location":"aulas/05-heuristicas/#mais-leve-primeiro","text":"Vamos testar uma abordagem oposta: quantidade agora \u00e9 o foco . Por isso vamos ser pr\u00e1ticos e pegar o maior n\u00famero de objetos poss\u00edvel ! Come\u00e7aremos agora pelos objetos mais leves e vamos torcer para que a quantidade grande de objetos selecionados resulte em uma mochila com alto valor. Question Compare esta heur\u00edstica com a da se\u00e7\u00e3o anterior levando em conta o algoritmo em pseudo-c\u00f3digo e sua complexidade computacional. Question Quais partes do programa da heur\u00edstica anterior podem ser aproveitadas para implementar a descrita acima? Example Implemente agora a heur\u00edstica do mais leve. Chame seu programa de mais_leve , mantendo tamb\u00e9m o c\u00f3digo do anterior.","title":"Mais leve primeiro"},{"location":"aulas/05-heuristicas/#analisando-nossas-heuristicas","text":"Question Crie uma entrada em que a heur\u00edstica do mais valioso seja muito melhor que a do mais leve. Escreva abaixo as sa\u00eddas de cada programa. Question Crie uma entrada em que a heur\u00edstica do mais leve seja muito melhor que a do mais valioso. Escreva abaixo as sa\u00eddas de cada programa. Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais valioso \u00e9 melhor? Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais leve \u00e9 melhor?","title":"Analisando nossas heur\u00edsticas"},{"location":"aulas/06-aleatorizacao/","text":"06 - Algoritmos Aleatorizados \u00b6 Um gerador de n\u00fameros pseudo-aleat\u00f3rios (RNG) \u00e9 um algoritmo determin\u00edstico que gera uma sequ\u00eancia de n\u00fameros que parece aleat\u00f3ria. Essa frase possui dois termos importantes que precisamos destrinchar: determin\u00edstico : Um RNG tipicamente recebe como entrada um inteiro seed (que representa uma sequ\u00eancia de bits \"aleat\u00f3ria\") e gera uma sequ\u00eancia de n\u00fameros baseada no seed . Ou seja, o algoritmo \u00e9 determin\u00edstico pois gera sempre a mesma sequ\u00eancia para uma determinada entrada ( seed ). parece aleat\u00f3ria : Se compararmos duas sequ\u00eancias de n\u00fameros, uma gerada por um RNG e outra por uma distribui\u00e7\u00e3o uniforme de verdade, n\u00e3o conseguimos dizer qual sequ\u00eancia foi gerada pelo RNG . Ou seja, ao escolhermos um seed a sequ\u00eancia gerada ser\u00e1 sempre a mesma, mesmo se executarmos o programa em outras m\u00e1quinas. Isso torna a utiliza\u00e7\u00e3o de RNGs para experimentos bastante interessante: \u00e9 poss\u00edvel reproduzir os resultados feitos por outros desenvolvedores/cientistas. Para isto \u00e9 necess\u00e1rio que o programa permita escolher o seed da simula\u00e7\u00e3o; que o seed usado seja publicado junto com os resultados. Question E se quisermos gerar uma sequ\u00eancia diferente a cada execu\u00e7\u00e3o do programa? Como poder\u00edamos configurar o seed para que isto aconte\u00e7a? Iniciando com RNGs \u00b6 Muitas implementa\u00e7\u00f5es de RNGs s\u00e3o divididas em duas partes: engine / random state : algoritmo que gera um inteiro cujos bits formam uma sequ\u00eancia pseudo-aleat\u00f3ria. distribution : utiliza os bits acima para retornar n\u00fameros que sigam alguma distribui\u00e7\u00e3o estat\u00edstica (como normal ou uniforme). Question A biblioteca padr\u00e3o de C++ disponibiliza diversas fun\u00e7\u00f5es para utiliza\u00e7\u00e3o de *RNG*s (cabe\u00e7alho <random> - documenta\u00e7\u00e3o neste link ). Se voc\u00ea quisesse sortear n\u00fameros aleat\u00f3rios inteiros entre -2 e 5 quais fun\u00e7\u00f5es usaria? Resposta #include <random> ... std::default_random_engine generator; std::uniform_int_distribution<int> distribution(-2,5); distribution(generator); // gera n\u00famero Question E se voc\u00ea quisesse sortear um n\u00famero real entre 0 e 1 ? Resposta #include <random> ... std::default_random_engine generator; std::uniform_real_distribution<double> distribution(0.0, 1.0); distribution(generator); // gera n\u00famero Agora que voc\u00ea j\u00e1 consegue gerar n\u00fameros aleat\u00f3rios, vamos implementar nossa primeira vers\u00e3o de uma heur\u00edstica aleatorizada. Example Adicionaremos a seguinte varia\u00e7\u00e3o na nossa heur\u00edstica: a cada passo de sele\u00e7\u00e3o temos 25% de chance de selecionar um objeto aleat\u00f3rio que ainda n\u00e3o foi utilizado. Ou seja, cada passo do algoritmo segue a seguinte regra Fa\u00e7a um sorteio aleat\u00f3rio Com probabilidade 75% pegue o pr\u00f3ximo objeto n\u00e3o selecionado de acordo com a heur\u00edstica (mais leve ou mais caro) Com probabilidade 25% selecione um objeto qualquer dos que n\u00e3o foram analisados ainda. Note que n\u00e3o mudamos o pr\u00f3ximo elemento ao fazer a sele\u00e7\u00e3o aleat\u00f3ria. Adote seed=10 nesta tarefa. Dica : agora \u00e9 poss\u00edvel que eu olhe um produto mais de uma vez. Voc\u00ea precisar\u00e1 checar isso no seu programa! Resposta Os arquivos in-*.txt cont\u00e9m entradas para teste. Os arquivos out-caro-(rand-?)*.txt cont\u00e9m as sa\u00eddas esperadas para as heur\u00edsticas do mais caro. Note que como estamos falando de uma probabilidade, o sorteio dever\u00e1 ser feito no intervalo [0, 1] . Question Rode a heur\u00edstica aleatorizada 10 vezes (como fazer isso?) e anote os valores das mochilas obtidas. Em m\u00e9dia, \u00e9 melhor ou pior que a heuristca sem aleatoriza\u00e7\u00e3o? Construindo uma solu\u00e7\u00e3o inteira aleat\u00f3ria \u00b6 Vamos agora fazer algo mais absurdo: e se criarmos uma solu\u00e7\u00e3o toda aleat\u00f3ria? Question Como voc\u00ea criaria uma solu\u00e7\u00e3o aleatoriamente? Resposta N\u00e3o existe uma resposta certa aqui. Duas solu\u00e7\u00f5es s\u00e3o mais comuns: passando por cada objeto, pegue-o com probabilidade 50% . percorra a lista em ordem aleat\u00f3ria, fazendo o mesmo algoritmo do mais caro/leve. Example Tente implementar a abordagem 1 da resposta acima. Example Tente implementar a abordagem 2 da resposta acima. Question Rode ambos programas acima com v\u00e1rios seeds diferentes e anote abaixo os resultados. Question Anote aqui coment\u00e1rios sobre a qualidade das solu\u00e7\u00f5es aleat\u00f3rias. Considere tanto o valor dos objetos selecionados quanto o peso. Warning Iremos discutir esses resultados na pr\u00f3xima aula.","title":"06 - Algoritmos Aleatorizados"},{"location":"aulas/06-aleatorizacao/#06-algoritmos-aleatorizados","text":"Um gerador de n\u00fameros pseudo-aleat\u00f3rios (RNG) \u00e9 um algoritmo determin\u00edstico que gera uma sequ\u00eancia de n\u00fameros que parece aleat\u00f3ria. Essa frase possui dois termos importantes que precisamos destrinchar: determin\u00edstico : Um RNG tipicamente recebe como entrada um inteiro seed (que representa uma sequ\u00eancia de bits \"aleat\u00f3ria\") e gera uma sequ\u00eancia de n\u00fameros baseada no seed . Ou seja, o algoritmo \u00e9 determin\u00edstico pois gera sempre a mesma sequ\u00eancia para uma determinada entrada ( seed ). parece aleat\u00f3ria : Se compararmos duas sequ\u00eancias de n\u00fameros, uma gerada por um RNG e outra por uma distribui\u00e7\u00e3o uniforme de verdade, n\u00e3o conseguimos dizer qual sequ\u00eancia foi gerada pelo RNG . Ou seja, ao escolhermos um seed a sequ\u00eancia gerada ser\u00e1 sempre a mesma, mesmo se executarmos o programa em outras m\u00e1quinas. Isso torna a utiliza\u00e7\u00e3o de RNGs para experimentos bastante interessante: \u00e9 poss\u00edvel reproduzir os resultados feitos por outros desenvolvedores/cientistas. Para isto \u00e9 necess\u00e1rio que o programa permita escolher o seed da simula\u00e7\u00e3o; que o seed usado seja publicado junto com os resultados. Question E se quisermos gerar uma sequ\u00eancia diferente a cada execu\u00e7\u00e3o do programa? Como poder\u00edamos configurar o seed para que isto aconte\u00e7a?","title":"06 - Algoritmos Aleatorizados"},{"location":"aulas/06-aleatorizacao/#iniciando-com-rngs","text":"Muitas implementa\u00e7\u00f5es de RNGs s\u00e3o divididas em duas partes: engine / random state : algoritmo que gera um inteiro cujos bits formam uma sequ\u00eancia pseudo-aleat\u00f3ria. distribution : utiliza os bits acima para retornar n\u00fameros que sigam alguma distribui\u00e7\u00e3o estat\u00edstica (como normal ou uniforme). Question A biblioteca padr\u00e3o de C++ disponibiliza diversas fun\u00e7\u00f5es para utiliza\u00e7\u00e3o de *RNG*s (cabe\u00e7alho <random> - documenta\u00e7\u00e3o neste link ). Se voc\u00ea quisesse sortear n\u00fameros aleat\u00f3rios inteiros entre -2 e 5 quais fun\u00e7\u00f5es usaria? Resposta #include <random> ... std::default_random_engine generator; std::uniform_int_distribution<int> distribution(-2,5); distribution(generator); // gera n\u00famero Question E se voc\u00ea quisesse sortear um n\u00famero real entre 0 e 1 ? Resposta #include <random> ... std::default_random_engine generator; std::uniform_real_distribution<double> distribution(0.0, 1.0); distribution(generator); // gera n\u00famero Agora que voc\u00ea j\u00e1 consegue gerar n\u00fameros aleat\u00f3rios, vamos implementar nossa primeira vers\u00e3o de uma heur\u00edstica aleatorizada. Example Adicionaremos a seguinte varia\u00e7\u00e3o na nossa heur\u00edstica: a cada passo de sele\u00e7\u00e3o temos 25% de chance de selecionar um objeto aleat\u00f3rio que ainda n\u00e3o foi utilizado. Ou seja, cada passo do algoritmo segue a seguinte regra Fa\u00e7a um sorteio aleat\u00f3rio Com probabilidade 75% pegue o pr\u00f3ximo objeto n\u00e3o selecionado de acordo com a heur\u00edstica (mais leve ou mais caro) Com probabilidade 25% selecione um objeto qualquer dos que n\u00e3o foram analisados ainda. Note que n\u00e3o mudamos o pr\u00f3ximo elemento ao fazer a sele\u00e7\u00e3o aleat\u00f3ria. Adote seed=10 nesta tarefa. Dica : agora \u00e9 poss\u00edvel que eu olhe um produto mais de uma vez. Voc\u00ea precisar\u00e1 checar isso no seu programa! Resposta Os arquivos in-*.txt cont\u00e9m entradas para teste. Os arquivos out-caro-(rand-?)*.txt cont\u00e9m as sa\u00eddas esperadas para as heur\u00edsticas do mais caro. Note que como estamos falando de uma probabilidade, o sorteio dever\u00e1 ser feito no intervalo [0, 1] . Question Rode a heur\u00edstica aleatorizada 10 vezes (como fazer isso?) e anote os valores das mochilas obtidas. Em m\u00e9dia, \u00e9 melhor ou pior que a heuristca sem aleatoriza\u00e7\u00e3o?","title":"Iniciando com RNGs"},{"location":"aulas/06-aleatorizacao/#construindo-uma-solucao-inteira-aleatoria","text":"Vamos agora fazer algo mais absurdo: e se criarmos uma solu\u00e7\u00e3o toda aleat\u00f3ria? Question Como voc\u00ea criaria uma solu\u00e7\u00e3o aleatoriamente? Resposta N\u00e3o existe uma resposta certa aqui. Duas solu\u00e7\u00f5es s\u00e3o mais comuns: passando por cada objeto, pegue-o com probabilidade 50% . percorra a lista em ordem aleat\u00f3ria, fazendo o mesmo algoritmo do mais caro/leve. Example Tente implementar a abordagem 1 da resposta acima. Example Tente implementar a abordagem 2 da resposta acima. Question Rode ambos programas acima com v\u00e1rios seeds diferentes e anote abaixo os resultados. Question Anote aqui coment\u00e1rios sobre a qualidade das solu\u00e7\u00f5es aleat\u00f3rias. Considere tanto o valor dos objetos selecionados quanto o peso. Warning Iremos discutir esses resultados na pr\u00f3xima aula.","title":"Construindo uma solu\u00e7\u00e3o inteira aleat\u00f3ria"},{"location":"aulas/07-busca-local/","text":"07 - Busca local \u00b6 Nesta aula trabalharemos com um algoritmo chamado \"Busca local\", que consiste basicamente em fazer pequenas atualiza\u00e7\u00f5es que melhoram sucessivamente uma solu\u00e7\u00e3o. Solu\u00e7\u00e3o aleatorizada \u00b6 Vamos iniciar criando solu\u00e7\u00f5es aleat\u00f3rias. Isto nos permitiria criar uma grande quantidade de solu\u00e7\u00f5es e, eventualmente, pegar a melhor delas. Apesar de ser muito mais simples que a busca heur\u00edstica, a quantidade massiva de solu\u00e7\u00f5es geradas tem potencial de encontrar boas solu\u00e7\u00f5es. Vamos trabalhar com um algoritmo bem simples para gerar solu\u00e7\u00f5es aleat\u00f3rias: Para cada objeto, selecione-o com probabilidade 0.5 . Se o objeto for selecionado, coloque-o na mochile se couber. Question Supondo que s\u00f3 existe uma solu\u00e7\u00e3o \u00f3tima global, qual \u00e9 a chance de a encontrarmos repetindo o algoritmo acima? Question Supondo que todos os objetos caibam na mochila, quantos s\u00e3o selecionados em m\u00e9dia? Example Implemente o algoritmo acima. Use seed=10 . Example Repita o algoritmo 10 vezes e pegue somente a melhor solu\u00e7\u00e3o. Tip Use os arquivos de entrada/sa\u00edda disponibilizados nas aulas passadas. Busca local \u00b6 Vamos agora implementar uma busca local para a Mochila Bin\u00e1ria seguindo os dois algoritmos vistos na expositiva. Mochila cheia \u00b6 Para implementar a Mochila cheia iremos adotar a seguinte estrat\u00e9gia: Gere uma solu\u00e7\u00e3o aleat\u00f3ria. Percorre novamente todos os objetos (na ordem da entrada) Se um objeto couber na mochila, inclua-o. Example Implemente o algoritmo acima. Example Rode a Mochila cheia 10 vezes e retorne a melhor solu\u00e7\u00e3o. Question Houve melhoria em rela\u00e7\u00e3o ao aleat\u00f3rio sozinho? Foi significativa? Fechamento \u00b6 Question Como voc\u00ea avalia os ganhos obtidos pela busca local em rela\u00e7\u00e3o ao aleat\u00f3rio? E em rela\u00e7\u00e3o a heur\u00edstica?","title":"07 - Busca local"},{"location":"aulas/07-busca-local/#07-busca-local","text":"Nesta aula trabalharemos com um algoritmo chamado \"Busca local\", que consiste basicamente em fazer pequenas atualiza\u00e7\u00f5es que melhoram sucessivamente uma solu\u00e7\u00e3o.","title":"07 - Busca local"},{"location":"aulas/07-busca-local/#solucao-aleatorizada","text":"Vamos iniciar criando solu\u00e7\u00f5es aleat\u00f3rias. Isto nos permitiria criar uma grande quantidade de solu\u00e7\u00f5es e, eventualmente, pegar a melhor delas. Apesar de ser muito mais simples que a busca heur\u00edstica, a quantidade massiva de solu\u00e7\u00f5es geradas tem potencial de encontrar boas solu\u00e7\u00f5es. Vamos trabalhar com um algoritmo bem simples para gerar solu\u00e7\u00f5es aleat\u00f3rias: Para cada objeto, selecione-o com probabilidade 0.5 . Se o objeto for selecionado, coloque-o na mochile se couber. Question Supondo que s\u00f3 existe uma solu\u00e7\u00e3o \u00f3tima global, qual \u00e9 a chance de a encontrarmos repetindo o algoritmo acima? Question Supondo que todos os objetos caibam na mochila, quantos s\u00e3o selecionados em m\u00e9dia? Example Implemente o algoritmo acima. Use seed=10 . Example Repita o algoritmo 10 vezes e pegue somente a melhor solu\u00e7\u00e3o. Tip Use os arquivos de entrada/sa\u00edda disponibilizados nas aulas passadas.","title":"Solu\u00e7\u00e3o aleatorizada"},{"location":"aulas/07-busca-local/#busca-local","text":"Vamos agora implementar uma busca local para a Mochila Bin\u00e1ria seguindo os dois algoritmos vistos na expositiva.","title":"Busca local"},{"location":"aulas/07-busca-local/#mochila-cheia","text":"Para implementar a Mochila cheia iremos adotar a seguinte estrat\u00e9gia: Gere uma solu\u00e7\u00e3o aleat\u00f3ria. Percorre novamente todos os objetos (na ordem da entrada) Se um objeto couber na mochila, inclua-o. Example Implemente o algoritmo acima. Example Rode a Mochila cheia 10 vezes e retorne a melhor solu\u00e7\u00e3o. Question Houve melhoria em rela\u00e7\u00e3o ao aleat\u00f3rio sozinho? Foi significativa?","title":"Mochila cheia"},{"location":"aulas/07-busca-local/#fechamento","text":"Question Como voc\u00ea avalia os ganhos obtidos pela busca local em rela\u00e7\u00e3o ao aleat\u00f3rio? E em rela\u00e7\u00e3o a heur\u00edstica?","title":"Fechamento"},{"location":"aulas/08-busca-global/","text":"08 - Busca exaustiva \u00b6 Pseudo-c\u00f3digo \u00b6 Vamos iniciar tentando escrever um algoritmo em pseudo-c\u00f3digo para a seguinte ideia: Iniciando com o objeto 0: N\u00e3o inclua ele na mochila: resolva o problema com o restante dos objetos e retorne esse resultado Inclua ele na mochila: resolva o problema com o restante dos objetos e uma mochila de capacidade C - p[0] . Retorne o resultado + v[0] . Escolhe a melhor das duas op\u00e7\u00f5es acima e retorne. Tip Note que pedimos para resolver o problema de novo, mas com menos objetos. Parece que esse \u00e9 um algoritmo recursivo! Question Escreva um algoritmo recursivo em pseudo-c\u00f3digo para resolver o problema da mochila. Seu algoritmo dever\u00e1 retornar o valor da mochila \u00f3tima, mas N\u00c3O precisa ainda retornar a mochila que tem esse valor. Question Adapte seu algoritmo acima para, al\u00e9m de retornar a melhor solu\u00e7\u00e3o, tamb\u00e9m retornar a mochila que tem esse valor. Dica : pode ser \u00fatil passar um vetor para guardar a melhor solu\u00e7\u00e3o encontrada. Implementa\u00e7\u00e3o \u00b6 Vamos agora tentar implementar o algoritmo de busca global que fizemos. Example Implemente em C++ seu algoritmo acima. Question Teste o seu programa com a entrada in-aula.txt (que \u00e9 a entrada dos slides). Voc\u00ea consegue agora responder \u00e0 pergunta Existe mochila com valor maior que 13 ? Fechamento \u00b6 Question Como voc\u00ea avalia os ganhos obtidos pela busca global em rela\u00e7\u00e3o \u00e0 busca local?","title":"08 - Busca exaustiva"},{"location":"aulas/08-busca-global/#08-busca-exaustiva","text":"","title":"08 - Busca exaustiva"},{"location":"aulas/08-busca-global/#pseudo-codigo","text":"Vamos iniciar tentando escrever um algoritmo em pseudo-c\u00f3digo para a seguinte ideia: Iniciando com o objeto 0: N\u00e3o inclua ele na mochila: resolva o problema com o restante dos objetos e retorne esse resultado Inclua ele na mochila: resolva o problema com o restante dos objetos e uma mochila de capacidade C - p[0] . Retorne o resultado + v[0] . Escolhe a melhor das duas op\u00e7\u00f5es acima e retorne. Tip Note que pedimos para resolver o problema de novo, mas com menos objetos. Parece que esse \u00e9 um algoritmo recursivo! Question Escreva um algoritmo recursivo em pseudo-c\u00f3digo para resolver o problema da mochila. Seu algoritmo dever\u00e1 retornar o valor da mochila \u00f3tima, mas N\u00c3O precisa ainda retornar a mochila que tem esse valor. Question Adapte seu algoritmo acima para, al\u00e9m de retornar a melhor solu\u00e7\u00e3o, tamb\u00e9m retornar a mochila que tem esse valor. Dica : pode ser \u00fatil passar um vetor para guardar a melhor solu\u00e7\u00e3o encontrada.","title":"Pseudo-c\u00f3digo"},{"location":"aulas/08-busca-global/#implementacao","text":"Vamos agora tentar implementar o algoritmo de busca global que fizemos. Example Implemente em C++ seu algoritmo acima. Question Teste o seu programa com a entrada in-aula.txt (que \u00e9 a entrada dos slides). Voc\u00ea consegue agora responder \u00e0 pergunta Existe mochila com valor maior que 13 ?","title":"Implementa\u00e7\u00e3o"},{"location":"aulas/08-busca-global/#fechamento","text":"Question Como voc\u00ea avalia os ganhos obtidos pela busca global em rela\u00e7\u00e3o \u00e0 busca local?","title":"Fechamento"},{"location":"aulas/09-busca-global-II/","text":"09 - Compara\u00e7\u00e3o de resultados \u00b6 J\u00e1 implementamos diversos algoritmos para o problema da mochila bin\u00e1ria e chegou a hora de compararmos os resultados por eles obtidos. Nossa ideia aqui \u00e9 exercitar nossa capacidade de responder perguntas abertas com base em dados. At\u00e9 qual tamanho de mochila a busca global resolve r\u00e1pido? \u00b6 O algoritmo de busca local \u00e9 melhor que as heur\u00edsticas? \u00b6 Vale a pena esperar pela busca global? At\u00e9 que ponto? \u00b6 Formulando a pergunta com precis\u00e3o \u00b6 Todas as perguntas acima s\u00e3o abertas. Elas admitem diferentes respostas dependendo de nossa interpreta\u00e7\u00e3o. Nesta se\u00e7\u00e3o iremos aprender a reformul\u00e1-las de maneira (mais) precisa e a planejar uma s\u00e9rie de experimentos que possam apoiar nossa resposta. Question Escolha uma das quest\u00f5es acima para trabalhar nesta quest\u00e3o. Question Alguns qualificadores comumente usados em discursos informais s\u00e3o considerados \"vazios\" quanto usados em um contexto mais cient\u00edfico, onde \u00e9 importante ser preciso nas mensagens. Express\u00f5es como \"A melhor que B\" \"r\u00e1pido, devagar, significativo\" \"vale a pena\" s\u00e3o ruins pois n\u00e3o deixam expl\u00edcito as expectativas de quem as escreveu. Por exemplo, poder\u00edamos ainda perguntar: \"A \u00e9 melhor que B\"** sob qual m\u00e9trica**? O que \u00e9 considerado \"r\u00e1pido, devagar ou significativo\"? 1 minuto \u00e9 r\u00e1pido ou devagar (depende da aplica\u00e7\u00e3o) Qual \u00e9 o crit\u00e9rio usado para \"valer a pena\"? Tempo? Valor da mochila? O qu\u00e3o pr\u00f3ximo do \u00f3timo vale a pena? Reescreva a pergunta escolhida agora especificando exatamente o que voc\u00ea gostaria de responder. Importante N\u00e3o existe resposta certa para a pergunta acima. Desde que voc\u00ea seja preciso em sua formula\u00e7\u00e3o a resposta est\u00e1 correta. Ou seja, neste momento n\u00e3o estamos questionando se a pergunta faz sentido , somente se ela est\u00e1 bem formulada . Agora que temos uma pergunta mais precisamente formulada, vamos planejar Question Temos dispon\u00edvel na aula 08 um gerador de entradas para a mochila. Como voc\u00ea o usaria para gerar dados que te ajudem a responder a pergunta escolhida? Especifique tamanhos de entrada e comente por que voc\u00ea faria estes testes. Question Com os dados da quest\u00e3o acima em m\u00e3os, que ferramentas visuais voc\u00ea usaria para facilitar a comunica\u00e7\u00e3o dos resultados? Se sua resposta incluir tabelas, diga o que ser\u00e1 mostrado em cada eixo e qual sua interpreta\u00e7\u00e3o dos dados. Se sua resposta incluir gr\u00e1ficos, explique qual tipo e qual informa\u00e7\u00e3o voc\u00ea estaria colocando em evid\u00eancia. Implementando de maneira reprodut\u00edvel \u00b6 Vamos agora tentar implementar seu plano acima de maneira reprodut\u00edvel. Ou seja, qualquer pessoa com a infra necess\u00e1ria poderia reexecutar seus experimentos e obter os mesmos dados que voc\u00ea. Example Re\u00fana todos os arquivos de entrada usados em uma pasta in . Example Crie um script python que executa seu programa para todas as entradas acima. Dicas : reveja a nossa aula 01 e relembre como criar testes reprodut\u00edveis. Example Salve os resultados acima em um dataframe do Pandas . Se quiser, salve seus resultados correntes para um arquivo CSV . Example Crie tabelas ou gr\u00e1ficos a partir do dataframe criado. Question Usando as tabelas e gr\u00e1ficos criados, responda \u00e0 pergunta escolhida no in\u00edcio do handout.","title":"09 - Compara\u00e7\u00e3o de resultados"},{"location":"aulas/09-busca-global-II/#09-comparacao-de-resultados","text":"J\u00e1 implementamos diversos algoritmos para o problema da mochila bin\u00e1ria e chegou a hora de compararmos os resultados por eles obtidos. Nossa ideia aqui \u00e9 exercitar nossa capacidade de responder perguntas abertas com base em dados.","title":"09 - Compara\u00e7\u00e3o de resultados"},{"location":"aulas/09-busca-global-II/#ate-qual-tamanho-de-mochila-a-busca-global-resolve-rapido","text":"","title":"At\u00e9 qual tamanho de mochila a busca global resolve r\u00e1pido?"},{"location":"aulas/09-busca-global-II/#o-algoritmo-de-busca-local-e-melhor-que-as-heuristicas","text":"","title":"O algoritmo de busca local \u00e9 melhor que as heur\u00edsticas?"},{"location":"aulas/09-busca-global-II/#vale-a-pena-esperar-pela-busca-global-ate-que-ponto","text":"","title":"Vale a pena esperar pela busca global? At\u00e9 que ponto?"},{"location":"aulas/09-busca-global-II/#formulando-a-pergunta-com-precisao","text":"Todas as perguntas acima s\u00e3o abertas. Elas admitem diferentes respostas dependendo de nossa interpreta\u00e7\u00e3o. Nesta se\u00e7\u00e3o iremos aprender a reformul\u00e1-las de maneira (mais) precisa e a planejar uma s\u00e9rie de experimentos que possam apoiar nossa resposta. Question Escolha uma das quest\u00f5es acima para trabalhar nesta quest\u00e3o. Question Alguns qualificadores comumente usados em discursos informais s\u00e3o considerados \"vazios\" quanto usados em um contexto mais cient\u00edfico, onde \u00e9 importante ser preciso nas mensagens. Express\u00f5es como \"A melhor que B\" \"r\u00e1pido, devagar, significativo\" \"vale a pena\" s\u00e3o ruins pois n\u00e3o deixam expl\u00edcito as expectativas de quem as escreveu. Por exemplo, poder\u00edamos ainda perguntar: \"A \u00e9 melhor que B\"** sob qual m\u00e9trica**? O que \u00e9 considerado \"r\u00e1pido, devagar ou significativo\"? 1 minuto \u00e9 r\u00e1pido ou devagar (depende da aplica\u00e7\u00e3o) Qual \u00e9 o crit\u00e9rio usado para \"valer a pena\"? Tempo? Valor da mochila? O qu\u00e3o pr\u00f3ximo do \u00f3timo vale a pena? Reescreva a pergunta escolhida agora especificando exatamente o que voc\u00ea gostaria de responder. Importante N\u00e3o existe resposta certa para a pergunta acima. Desde que voc\u00ea seja preciso em sua formula\u00e7\u00e3o a resposta est\u00e1 correta. Ou seja, neste momento n\u00e3o estamos questionando se a pergunta faz sentido , somente se ela est\u00e1 bem formulada . Agora que temos uma pergunta mais precisamente formulada, vamos planejar Question Temos dispon\u00edvel na aula 08 um gerador de entradas para a mochila. Como voc\u00ea o usaria para gerar dados que te ajudem a responder a pergunta escolhida? Especifique tamanhos de entrada e comente por que voc\u00ea faria estes testes. Question Com os dados da quest\u00e3o acima em m\u00e3os, que ferramentas visuais voc\u00ea usaria para facilitar a comunica\u00e7\u00e3o dos resultados? Se sua resposta incluir tabelas, diga o que ser\u00e1 mostrado em cada eixo e qual sua interpreta\u00e7\u00e3o dos dados. Se sua resposta incluir gr\u00e1ficos, explique qual tipo e qual informa\u00e7\u00e3o voc\u00ea estaria colocando em evid\u00eancia.","title":"Formulando a pergunta com precis\u00e3o"},{"location":"aulas/09-busca-global-II/#implementando-de-maneira-reprodutivel","text":"Vamos agora tentar implementar seu plano acima de maneira reprodut\u00edvel. Ou seja, qualquer pessoa com a infra necess\u00e1ria poderia reexecutar seus experimentos e obter os mesmos dados que voc\u00ea. Example Re\u00fana todos os arquivos de entrada usados em uma pasta in . Example Crie um script python que executa seu programa para todas as entradas acima. Dicas : reveja a nossa aula 01 e relembre como criar testes reprodut\u00edveis. Example Salve os resultados acima em um dataframe do Pandas . Se quiser, salve seus resultados correntes para um arquivo CSV . Example Crie tabelas ou gr\u00e1ficos a partir do dataframe criado. Question Usando as tabelas e gr\u00e1ficos criados, responda \u00e0 pergunta escolhida no in\u00edcio do handout.","title":"Implementando de maneira reprodut\u00edvel"},{"location":"aulas/10-branch-and-bound/","text":"10 - Branch and Bound \u00b6 Vamos come\u00e7ar nossa atividade instrumentando nossa busca exaustiva. Dado que a promessa do nosso algoritmo Branch and Bound \u00e9 evitar chegar at\u00e9 o fim de uma solu\u00e7\u00e3o parcial que n\u00e3o tem chance de ser \u00f3tima, faz todo sentido ent\u00e3o contarmos quantas vezes chegamos at\u00e9 o fim. Example Vamos adicionar dois contadores ao nosso programa num_leaf conta quantas vezes uma solu\u00e7\u00e3o completa foi comparada com a melhor poss\u00edvel num_copy conta quantas vezes foi encontrada uma solu\u00e7\u00e3o melhor que a atual. Question Rode para o exemplo in150.txt e anote os valores obtidos abaixo. Um bound simples: ignorar peso \u00b6 Nesta se\u00e7\u00e3o implementaremos um Branch and Bound simples com a seguinte ideia: BOUND Complete uma solu\u00e7\u00e3o parcial incluindo na mochila todos os objetos n\u00e3o selecionados. Isto \u00e9 equivalente a relaxar a restri\u00e7\u00e3o do peso . Question Os contadores num_leaf e num_copy se modificariam ao implementar o Branch and Bound ? Se sim, quais deles? Resposta Somente num_leaf , j\u00e1 que deixamos de chegar em folhas que n\u00e3o tem chance de serem \u00f3timos globais. num_copy continua igual, j\u00e1 que conta o n\u00famero de vezes que o melhor foi atualizado. Example Implemente no seu c\u00f3digo o Branch and Bound usando o Bound acima. Ou seja, voc\u00ea dever\u00e1, ao chegar em um objeto Checar se a soma da solu\u00e7\u00e3o atual mais o bound \u00e9 melhor que o melhor poss\u00edvel. Se n\u00e3o for retorna Se for prossegue fazendo a escolha para o objeto atual. Example Adicione ao seu programa um contador num_bounds que conta o n\u00famero de vezes em que evitamos de testar uma solu\u00e7\u00e3o parcial at\u00e9 o fim. Question Teste seu programa novamente com a entrada in150.txt . Anote abaixo os contadores e interprete seu resultado. Analisando nosso bound \u00b6 Conseguimos algum ganho de desempenho ao criar o \u00faltimo bound. Vamos agora descobrir se ele \u00e9 bom mesmo. Question Como voc\u00ea mediria a altura em que o bound agiu? Seria melhor cortar mais para cima ou mais para baixo? O valor num_bound n\u00e3o ajuda muito a entender se o bound \u00e9 bom, j\u00e1 que cortar muito pode significar faz\u00ea-lo pr\u00f3ximo das folhas (e isto gera ganho pequeno de desempenho). Example Fa\u00e7a seu programa contar o n\u00famero de vezes em que o bound \u00e9 ativado em cada n\u00edvel da recurs\u00e3o. Mostre esses valores no terminal. Question Interprete os resultados acima. Implementa\u00e7\u00e3o eficiente do bound \u00b6 Question O bound Ignorar peso depende das escolhas feitas at\u00e9 o momento? Ou seja, se tenho 4 objetos, o bound da solu\u00e7\u00e3o parcial (1, 0, -, -) \u00e9 igual ou diferente do bound da solu\u00e7\u00e3o parcial (1, 1, -, -) ? Question Como voc\u00ea poderia economizar trabalho ao calcular o bound? \u00c9 poss\u00edvel pr\u00e9-calcular algo? Example Reimplemente seu bound, desta vez pr\u00e9-calculando tudo antes de iniciar a busca_exaustiva. Question Rode novamente com a entrada in150.txt e verifique se houve ganho de tempo de execu\u00e7\u00e3o. Avan\u00e7ado: o qu\u00e3o justo \u00e9 um bound? \u00b6 Podemos medir qu\u00e3o justo \u00e9 um bound verificando a diferen\u00e7a entre seu valor e o valor real da melhor solu\u00e7\u00e3o da sub\u00e1rvore de recurs\u00e3o atual. Ou seja, comparamos nossa estimativa otimista com o que aconteceu de verdade ao examinar todas essas solu\u00e7\u00f5es. Example Fa\u00e7a seu programa guardar a diferen\u00e7a m\u00e9dia entre o valor do bound (que \u00e9 uma estimativa da qualidade final de uma solu\u00e7\u00e3o) e o melhor valor encontrado para aquele ramo da recurs\u00e3o. Dica : voc\u00ea vai precisar retornar o valor da melhor mochila encontrada em cada parte. Question Interprete os resultados acima.","title":"10 - Branch and Bound"},{"location":"aulas/10-branch-and-bound/#10-branch-and-bound","text":"Vamos come\u00e7ar nossa atividade instrumentando nossa busca exaustiva. Dado que a promessa do nosso algoritmo Branch and Bound \u00e9 evitar chegar at\u00e9 o fim de uma solu\u00e7\u00e3o parcial que n\u00e3o tem chance de ser \u00f3tima, faz todo sentido ent\u00e3o contarmos quantas vezes chegamos at\u00e9 o fim. Example Vamos adicionar dois contadores ao nosso programa num_leaf conta quantas vezes uma solu\u00e7\u00e3o completa foi comparada com a melhor poss\u00edvel num_copy conta quantas vezes foi encontrada uma solu\u00e7\u00e3o melhor que a atual. Question Rode para o exemplo in150.txt e anote os valores obtidos abaixo.","title":"10 - Branch and Bound"},{"location":"aulas/10-branch-and-bound/#um-bound-simples-ignorar-peso","text":"Nesta se\u00e7\u00e3o implementaremos um Branch and Bound simples com a seguinte ideia: BOUND Complete uma solu\u00e7\u00e3o parcial incluindo na mochila todos os objetos n\u00e3o selecionados. Isto \u00e9 equivalente a relaxar a restri\u00e7\u00e3o do peso . Question Os contadores num_leaf e num_copy se modificariam ao implementar o Branch and Bound ? Se sim, quais deles? Resposta Somente num_leaf , j\u00e1 que deixamos de chegar em folhas que n\u00e3o tem chance de serem \u00f3timos globais. num_copy continua igual, j\u00e1 que conta o n\u00famero de vezes que o melhor foi atualizado. Example Implemente no seu c\u00f3digo o Branch and Bound usando o Bound acima. Ou seja, voc\u00ea dever\u00e1, ao chegar em um objeto Checar se a soma da solu\u00e7\u00e3o atual mais o bound \u00e9 melhor que o melhor poss\u00edvel. Se n\u00e3o for retorna Se for prossegue fazendo a escolha para o objeto atual. Example Adicione ao seu programa um contador num_bounds que conta o n\u00famero de vezes em que evitamos de testar uma solu\u00e7\u00e3o parcial at\u00e9 o fim. Question Teste seu programa novamente com a entrada in150.txt . Anote abaixo os contadores e interprete seu resultado.","title":"Um bound simples: ignorar peso"},{"location":"aulas/10-branch-and-bound/#analisando-nosso-bound","text":"Conseguimos algum ganho de desempenho ao criar o \u00faltimo bound. Vamos agora descobrir se ele \u00e9 bom mesmo. Question Como voc\u00ea mediria a altura em que o bound agiu? Seria melhor cortar mais para cima ou mais para baixo? O valor num_bound n\u00e3o ajuda muito a entender se o bound \u00e9 bom, j\u00e1 que cortar muito pode significar faz\u00ea-lo pr\u00f3ximo das folhas (e isto gera ganho pequeno de desempenho). Example Fa\u00e7a seu programa contar o n\u00famero de vezes em que o bound \u00e9 ativado em cada n\u00edvel da recurs\u00e3o. Mostre esses valores no terminal. Question Interprete os resultados acima.","title":"Analisando nosso bound"},{"location":"aulas/10-branch-and-bound/#implementacao-eficiente-do-bound","text":"Question O bound Ignorar peso depende das escolhas feitas at\u00e9 o momento? Ou seja, se tenho 4 objetos, o bound da solu\u00e7\u00e3o parcial (1, 0, -, -) \u00e9 igual ou diferente do bound da solu\u00e7\u00e3o parcial (1, 1, -, -) ? Question Como voc\u00ea poderia economizar trabalho ao calcular o bound? \u00c9 poss\u00edvel pr\u00e9-calcular algo? Example Reimplemente seu bound, desta vez pr\u00e9-calculando tudo antes de iniciar a busca_exaustiva. Question Rode novamente com a entrada in150.txt e verifique se houve ganho de tempo de execu\u00e7\u00e3o.","title":"Implementa\u00e7\u00e3o eficiente do bound"},{"location":"aulas/10-branch-and-bound/#avancado-o-quao-justo-e-um-bound","text":"Podemos medir qu\u00e3o justo \u00e9 um bound verificando a diferen\u00e7a entre seu valor e o valor real da melhor solu\u00e7\u00e3o da sub\u00e1rvore de recurs\u00e3o atual. Ou seja, comparamos nossa estimativa otimista com o que aconteceu de verdade ao examinar todas essas solu\u00e7\u00f5es. Example Fa\u00e7a seu programa guardar a diferen\u00e7a m\u00e9dia entre o valor do bound (que \u00e9 uma estimativa da qualidade final de uma solu\u00e7\u00e3o) e o melhor valor encontrado para aquele ramo da recurs\u00e3o. Dica : voc\u00ea vai precisar retornar o valor da melhor mochila encontrada em cada parte. Question Interprete os resultados acima.","title":"Avan\u00e7ado: o qu\u00e3o justo \u00e9 um bound?"},{"location":"aulas/11-branch-and-bound/","text":"11 - Branch and Bound II \u00b6 Vimos na expositiva que um bound justo \u00e9 importante para conseguir ganhos grandes de desempenho no Branch and Bound. A mochila fracion\u00e1ria \u00b6 Nosso relaxamento de restri\u00e7\u00e3o permite que um objeto seja incluido em fra\u00e7\u00f5es. Como vimos na aula, existe um algoritmo simples que d\u00e1 a solu\u00e7\u00e3o \u00f3tima: ordene os objetos por propor\u00e7\u00e3o valor/kg. pegue os objetos nesta ordem at\u00e9 n\u00e3o caber mais na mochila se um objeto n\u00e3o couber inteiro, pegue a maior fra\u00e7\u00e3o poss\u00edvel A resposta da Mochila fracion\u00e1ria provavelmente n\u00e3o ser\u00e1 uma Mochila bin\u00e1ria vi\u00e1vel. Mesmo assim, provamos na aula que ela \u00e9 um limitante superior para a Mochila bin\u00e1ria . Example Implemente a mochila fracion\u00e1ria e execute-a para nossa entrada in150.txt . Sua sa\u00edda deve estar no formato abaixo. valor (fracao_do_objeto1) .... (fracao_do_objetoN) Veja o arquivo out150.txt para a resposta esperada neste exerc\u00edcio. A ordem importa? Estrat\u00e9gia Best-first \u00b6 Antes de incorporar o bound usando mochila fracion\u00e1ria vamos observar o efeito da ordem de an\u00e1lise das solu\u00e7\u00f5es. Na nossa primeira tentativa fizemos a busca exaustiva na ordem que os objetos foram apresentados na entrada. Isso resultava nos seguintes indicadores num_leaf 770786731 num_copy 44 Question Suponha que agora voc\u00ea ir\u00e1 analisar os objetos na ordem usada na Mochila fracion\u00e1ria . Voc\u00ea espera que num_leaf continue igual, aumente ou diminua? Question Suponha que agora voc\u00ea ir\u00e1 analisar os objetos na ordem usada na Mochila fracion\u00e1ria . Voc\u00ea espera que num_copy continue igual, aumente ou diminua? Example Implemente esta estrat\u00e9gia e verifique se os seus resultados se confirmaram. Resposta Assim como voc\u00ea deve ter respondido nas duas primeiras quest\u00f5es, num_leaf deve continuar igual, mas num_copy vai diminuir muito. O bound Mochila fracion\u00e1ria \u00b6 Vamos agora juntar tudo e implementar o bound Mochila fracion\u00e1ria examinando os objetos na ordem da parte anterior. Question Levando em conta que a ordem anterior fez apenas 3 c\u00f3pias, qual sua expectativa em rela\u00e7\u00e3o aos poss\u00edveis ganhos de desempenho que implementar o bound Mochila fracion\u00e1ria pode trazer? Example Implemente o bound. Question Quais os valores de num_leaf , num_copy e num_bound para in150.txt ? Analisando o bound \u00b6 Vamos agora analisar nossas medidas de efetividade do bound. Question Compare os valores de num_bound para Ignorar peso e Mochila fracion\u00e1ria . Voc\u00ea consegue tirar conclus\u00f5es a partir deste valor? Resposta A dica de que tem algo estranho \u00e9 que num_bound \u00e9 muito menor. Ou seja, a conclus\u00e3o de que quanto menor o num_bound melhor \u00e9 claramente problem\u00e1tica, j\u00e1 que contraria a intui\u00e7\u00e3o de que um bound teria que estar ocorrendo v\u00e1rias vezes. Por outro lado, o programa \u00e9 realmente muito mais r\u00e1pido, ent\u00e3o deve haver algo que n\u00e3o est\u00e1 sendo medido corretamente. Example Implemente no seu c\u00f3digo a contagem de quantas vezes o bound foi feito por n\u00edvel da recurs\u00e3o. Question Compare o resultado acima com o obtido no mesmo teste na aula anterior. Agora voc\u00ea consegue explicar a raz\u00e3o do desempenho da nova implementa\u00e7\u00e3o ter sido t\u00e3o melhor? Resposta para a aula anterior 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 43 32830 536970 250518 792810 1550819 2119857 2475746 2710403 56370234 16347241 14514859 63885823 22061564 111961043 25164499 79575293 47368277 2373877 0 17059720 2265050 423517","title":"11 - Branch and Bound II"},{"location":"aulas/11-branch-and-bound/#11-branch-and-bound-ii","text":"Vimos na expositiva que um bound justo \u00e9 importante para conseguir ganhos grandes de desempenho no Branch and Bound.","title":"11 - Branch and Bound II"},{"location":"aulas/11-branch-and-bound/#a-mochila-fracionaria","text":"Nosso relaxamento de restri\u00e7\u00e3o permite que um objeto seja incluido em fra\u00e7\u00f5es. Como vimos na aula, existe um algoritmo simples que d\u00e1 a solu\u00e7\u00e3o \u00f3tima: ordene os objetos por propor\u00e7\u00e3o valor/kg. pegue os objetos nesta ordem at\u00e9 n\u00e3o caber mais na mochila se um objeto n\u00e3o couber inteiro, pegue a maior fra\u00e7\u00e3o poss\u00edvel A resposta da Mochila fracion\u00e1ria provavelmente n\u00e3o ser\u00e1 uma Mochila bin\u00e1ria vi\u00e1vel. Mesmo assim, provamos na aula que ela \u00e9 um limitante superior para a Mochila bin\u00e1ria . Example Implemente a mochila fracion\u00e1ria e execute-a para nossa entrada in150.txt . Sua sa\u00edda deve estar no formato abaixo. valor (fracao_do_objeto1) .... (fracao_do_objetoN) Veja o arquivo out150.txt para a resposta esperada neste exerc\u00edcio.","title":"A mochila fracion\u00e1ria"},{"location":"aulas/11-branch-and-bound/#a-ordem-importa-estrategia-best-first","text":"Antes de incorporar o bound usando mochila fracion\u00e1ria vamos observar o efeito da ordem de an\u00e1lise das solu\u00e7\u00f5es. Na nossa primeira tentativa fizemos a busca exaustiva na ordem que os objetos foram apresentados na entrada. Isso resultava nos seguintes indicadores num_leaf 770786731 num_copy 44 Question Suponha que agora voc\u00ea ir\u00e1 analisar os objetos na ordem usada na Mochila fracion\u00e1ria . Voc\u00ea espera que num_leaf continue igual, aumente ou diminua? Question Suponha que agora voc\u00ea ir\u00e1 analisar os objetos na ordem usada na Mochila fracion\u00e1ria . Voc\u00ea espera que num_copy continue igual, aumente ou diminua? Example Implemente esta estrat\u00e9gia e verifique se os seus resultados se confirmaram. Resposta Assim como voc\u00ea deve ter respondido nas duas primeiras quest\u00f5es, num_leaf deve continuar igual, mas num_copy vai diminuir muito.","title":"A ordem importa? Estrat\u00e9gia Best-first"},{"location":"aulas/11-branch-and-bound/#o-bound-mochila-fracionaria","text":"Vamos agora juntar tudo e implementar o bound Mochila fracion\u00e1ria examinando os objetos na ordem da parte anterior. Question Levando em conta que a ordem anterior fez apenas 3 c\u00f3pias, qual sua expectativa em rela\u00e7\u00e3o aos poss\u00edveis ganhos de desempenho que implementar o bound Mochila fracion\u00e1ria pode trazer? Example Implemente o bound. Question Quais os valores de num_leaf , num_copy e num_bound para in150.txt ?","title":"O bound Mochila fracion\u00e1ria"},{"location":"aulas/11-branch-and-bound/#analisando-o-bound","text":"Vamos agora analisar nossas medidas de efetividade do bound. Question Compare os valores de num_bound para Ignorar peso e Mochila fracion\u00e1ria . Voc\u00ea consegue tirar conclus\u00f5es a partir deste valor? Resposta A dica de que tem algo estranho \u00e9 que num_bound \u00e9 muito menor. Ou seja, a conclus\u00e3o de que quanto menor o num_bound melhor \u00e9 claramente problem\u00e1tica, j\u00e1 que contraria a intui\u00e7\u00e3o de que um bound teria que estar ocorrendo v\u00e1rias vezes. Por outro lado, o programa \u00e9 realmente muito mais r\u00e1pido, ent\u00e3o deve haver algo que n\u00e3o est\u00e1 sendo medido corretamente. Example Implemente no seu c\u00f3digo a contagem de quantas vezes o bound foi feito por n\u00edvel da recurs\u00e3o. Question Compare o resultado acima com o obtido no mesmo teste na aula anterior. Agora voc\u00ea consegue explicar a raz\u00e3o do desempenho da nova implementa\u00e7\u00e3o ter sido t\u00e3o melhor? Resposta para a aula anterior 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 43 32830 536970 250518 792810 1550819 2119857 2475746 2710403 56370234 16347241 14514859 63885823 22061564 111961043 25164499 79575293 47368277 2373877 0 17059720 2265050 423517","title":"Analisando o bound"},{"location":"aulas/12-paralelismo/","text":"12 - Introdu\u00e7\u00e3o a paralelismo \u00b6 OpenMP \u00e9 uma tecnologia de computa\u00e7\u00e3o multi-core usada para paralelizar programas. Sua principal vantagem \u00e9 oferecer uma transi\u00e7\u00e3o suave entre c\u00f3digo sequencial e c\u00f3digo paralelo. Primeiros passos \u00b6 Nesta parte do roteiro usaremos 4 chamadas do OpenMP para criar nossas primeiras threads. #pragma omp parallel cria um conjunto de threads. Deve ser aplicado acima de um bloco de c\u00f3digo limitado por { } int omp_get_num_threads(); retorna o n\u00famero de threads criadas (dentro de uma regi\u00e3o paralela) int omp_get_max_threads(); retorna o n\u00famero de m\u00e1ximo de threads (fora de uma regi\u00e3o paralela) int omp_get_thread_num(); retorna o id da thread atual (entre 0 e o valor acima, dentro de uma regi\u00e3o paralela) O c\u00f3digo abaixo ( exemplo1.cpp ) ilustra como utilizar OpenMP para criar um conjunto de threads que rodam em paralelo. #pragma omp parallel { std :: cout << \"ID:\" << omp_get_thread_num () << \"/\" << omp_get_num_threads () << \" \\n \" ; } Vamos agora fazer alguns experimentos com esse exemplo b\u00e1sico para entender como OpenMP funciona. Example Compile o programa de exemplo usando a seguinte linha de comando e rode-o. $ g++ -O3 exemplo1.cpp -o exemplo1 -fopenmp Question O OpenMP permite alterar o n\u00famero m\u00e1ximo de threads criados usando a vari\u00e1vel de ambiente OMP_NUM_THREADS . Rode exemplo1 como abaixo. OMP_NUM_THREADS=2 ./exemplo1 Quantas threads foram criadas? Details 2 threads. Question Rode agora sem a vari\u00e1vel de ambiente. Qual \u00e9 o valor padr\u00e3o assumido pelo OpenMP? \u00c9 uma boa ideia usar mais threads que o valor padr\u00e3o? Details O valor padr\u00e3o \u00e9 o n\u00famero de threads que o processador pode rodar simult\u00e2neamente. A utiliza\u00e7\u00e3o de OMP_NUM_THREADS ajuda a realizar testes de modo a compreender os ganhos de desempenho de um programa conforme mais threads s\u00e3o utilizadas. Quando uma regi\u00e3o paralela inicia s\u00e3o criadas OMP_NUM_THREADS threads e cada uma roda o bloco de c\u00f3digo imediatamente abaixo de maneira independents. Escopo de vari\u00e1veis \u00b6 Levando em conta o c\u00f3digo abaixo, responda as quest\u00f5es abaixo. double res = 0 ; #pragma omp parallel { double temp = 10 ; res *= temp ; } Question Quantas c\u00f3pias da vari\u00e1vel res existem? 1 1 para cada thread criada Nenhuma das anteriores Details S\u00f3 uma vari\u00e1vel res existe, pois ela foi declarada fora da regi\u00e3o paralela. Question Quantas c\u00f3pias da vari\u00e1vel temp existem? 1 1 para cada thread criada Nenhuma das anteriores Resposta Existem N c\u00f3pias de temp , uma criada para cada thread existente. Question Qual o valor de res ao final do c\u00f3digo abaixo? int res = 1 ; #pragma omp parallel { for ( int i = 0 ; i < 10000 ; i ++ ) { res += 1 ; } } 10000 N * 10000 Indefinido Example Rode o c\u00f3digo acima (arquivo exemplo2.cpp ) e veja se suas expectativas se cumprem. Aproveite e verifique se o programa retorna o mesmo resultado se executado v\u00e1rias vezes. Chame o professor se voc\u00ea se surpreender com o resultado. Resposta O c\u00f3digo dar\u00e1 resultados estranhos, com res n\u00e3o assumindo o valor N * 10000 . Quanto maior o n\u00famero de threads mais distante do correto o valor resultante ser\u00e1. Question Mude o limite do for para 1000 . Os resultados agora s\u00e3o os esperados? Por que? Details Nesse caso funciona, mas \u00e9 por acaso. O valor pequeno do N faz com que a chance de conflitos diminua, mas ainda \u00e9 poss\u00edvel. Este tipo de erro \"escondido\" assim \u00e9 muito dif\u00edcil de encontrar. Danger Nos dois exemplos acima as vari\u00e1veis res eram usadas por m\u00faltiplas threads! Ou seja, cada thread possui uma depend\u00eancia em rela\u00e7\u00e3o a res . Escrever c\u00f3digo sem levar em conta as depend\u00eancias \u00e9 um problema que ser\u00e1 abordado nas pr\u00f3ximas aulas, mas j\u00e1 podemos ver que se duas threads tem uma depend\u00eancia de escrita na mesma vari\u00e1vel coisas ruins acontecer\u00e3o. Avan\u00e7ado \u00b6 Question Suponha que voc\u00ea tenha um for que percorre um vetor vec de 1000 elementos e que precisa chamar duas fun\u00e7\u00f5es func1 e func2 neste vetor. As duas fun\u00e7\u00f5es n\u00e3o possuem depend\u00eancias entre si, logo poderiam ser executadas simult\u00e2neamente. Como voc\u00ea usaria omp parallel para execut\u00e1-las em paralelo? Dica : use omp_get_thread_num() . Paralelismo de tarefas \u00b6 Vamos agora criar tarefas que podem ser executadas em paralelo. Defini\u00e7\u00e3o Uma tarefa \u00e9 um bloco de c\u00f3digo que \u00e9 rodado de maneira paralela usando OpenMP. Tarefas s\u00e3o agendadas para cada uma das threads criadas em um regi\u00e3o paralela. N\u00e3o existe uma associa\u00e7\u00e3o 1-1 entre threads e tarefas . Posso ter mais tarefas que threads e mais threads que tarefas . Veja abaixo um exemplo de cria\u00e7\u00e3o de tarefas. #pragma omp parallel { #pragma omp task { std :: cout << \"Estou rodando na tarefa \" << omp_get_thread_num () << \" \\n \" ; } } std :: cout << \"eu s\u00f3 rodo quanto TODAS tarefas acabarem. \\n \" ; Question O exemplo acima cria quantas tarefas, supondo que OMP_NUM_THREADS=4 ? 1 4, uma para cada thread Nenhuma das anteriores Details Como cada thread roda o c\u00f3digo da regi\u00e3o paralela, cada uma cria exatamente um tarefa. Para controlar a cria\u00e7\u00e3o de tarefas em geral usamos a diretiva master , que executa somente na thread de \u00edndice 0 . Assim conseguimos criar c\u00f3digo leg\u00edvel e que deixa bem claro quantas e quais tarefas s\u00e3o criadas. #pragma omp parallel { #pragma omp master { std :: cout << \"s\u00f3 roda uma vez na thread:\" << omp_get_thread_num () << \" \\n \" ; #pragma omp task { std :: cout << \"Estou rodando na thread:\" << omp_get_thread_num () << \" \\n \" ; } } } Somente lendo o c\u00f3digo acima, responda as quest\u00f5es abaixo. Question Quantas tarefas s\u00e3o criadas no exemplo acima? 1 N, uma para cada thread Nenhuma das anteriores Question A(s) tarefa(s) criada(s) roda(m) em qual thread? 0 1 Imposs\u00edvel dizer. Em cada execu\u00e7\u00e3o rodar\u00e1 em uma thread diferente. Example Agora roda o c\u00f3digo em exemplo3.cpp v\u00e1rias vezes e compare suas respostas com a execu\u00e7\u00e3o do programa. Example Complete exercicio1.cpp criando duas tarefas. A primeira dever\u00e1 rodar funcao1 e a segunda funcao2 . Salve seus resultados nas vari\u00e1veis indicadas no c\u00f3digo. Question Leia o c\u00f3digo e responda. Quanto tempo o c\u00f3digo sequencial demora? E o paralelo? Verifique que sua implementa\u00e7\u00e3o est\u00e1 de acordo com suas expectativas. Details Sequencial demora a soma dos tempos das duas fun\u00e7\u00f5es. Paralelo demora o tempo da maior delas.","title":"12 - Introdu\u00e7\u00e3o a paralelismo"},{"location":"aulas/12-paralelismo/#12-introducao-a-paralelismo","text":"OpenMP \u00e9 uma tecnologia de computa\u00e7\u00e3o multi-core usada para paralelizar programas. Sua principal vantagem \u00e9 oferecer uma transi\u00e7\u00e3o suave entre c\u00f3digo sequencial e c\u00f3digo paralelo.","title":"12 - Introdu\u00e7\u00e3o a paralelismo"},{"location":"aulas/12-paralelismo/#primeiros-passos","text":"Nesta parte do roteiro usaremos 4 chamadas do OpenMP para criar nossas primeiras threads. #pragma omp parallel cria um conjunto de threads. Deve ser aplicado acima de um bloco de c\u00f3digo limitado por { } int omp_get_num_threads(); retorna o n\u00famero de threads criadas (dentro de uma regi\u00e3o paralela) int omp_get_max_threads(); retorna o n\u00famero de m\u00e1ximo de threads (fora de uma regi\u00e3o paralela) int omp_get_thread_num(); retorna o id da thread atual (entre 0 e o valor acima, dentro de uma regi\u00e3o paralela) O c\u00f3digo abaixo ( exemplo1.cpp ) ilustra como utilizar OpenMP para criar um conjunto de threads que rodam em paralelo. #pragma omp parallel { std :: cout << \"ID:\" << omp_get_thread_num () << \"/\" << omp_get_num_threads () << \" \\n \" ; } Vamos agora fazer alguns experimentos com esse exemplo b\u00e1sico para entender como OpenMP funciona. Example Compile o programa de exemplo usando a seguinte linha de comando e rode-o. $ g++ -O3 exemplo1.cpp -o exemplo1 -fopenmp Question O OpenMP permite alterar o n\u00famero m\u00e1ximo de threads criados usando a vari\u00e1vel de ambiente OMP_NUM_THREADS . Rode exemplo1 como abaixo. OMP_NUM_THREADS=2 ./exemplo1 Quantas threads foram criadas? Details 2 threads. Question Rode agora sem a vari\u00e1vel de ambiente. Qual \u00e9 o valor padr\u00e3o assumido pelo OpenMP? \u00c9 uma boa ideia usar mais threads que o valor padr\u00e3o? Details O valor padr\u00e3o \u00e9 o n\u00famero de threads que o processador pode rodar simult\u00e2neamente. A utiliza\u00e7\u00e3o de OMP_NUM_THREADS ajuda a realizar testes de modo a compreender os ganhos de desempenho de um programa conforme mais threads s\u00e3o utilizadas. Quando uma regi\u00e3o paralela inicia s\u00e3o criadas OMP_NUM_THREADS threads e cada uma roda o bloco de c\u00f3digo imediatamente abaixo de maneira independents.","title":"Primeiros passos"},{"location":"aulas/12-paralelismo/#escopo-de-variaveis","text":"Levando em conta o c\u00f3digo abaixo, responda as quest\u00f5es abaixo. double res = 0 ; #pragma omp parallel { double temp = 10 ; res *= temp ; } Question Quantas c\u00f3pias da vari\u00e1vel res existem? 1 1 para cada thread criada Nenhuma das anteriores Details S\u00f3 uma vari\u00e1vel res existe, pois ela foi declarada fora da regi\u00e3o paralela. Question Quantas c\u00f3pias da vari\u00e1vel temp existem? 1 1 para cada thread criada Nenhuma das anteriores Resposta Existem N c\u00f3pias de temp , uma criada para cada thread existente. Question Qual o valor de res ao final do c\u00f3digo abaixo? int res = 1 ; #pragma omp parallel { for ( int i = 0 ; i < 10000 ; i ++ ) { res += 1 ; } } 10000 N * 10000 Indefinido Example Rode o c\u00f3digo acima (arquivo exemplo2.cpp ) e veja se suas expectativas se cumprem. Aproveite e verifique se o programa retorna o mesmo resultado se executado v\u00e1rias vezes. Chame o professor se voc\u00ea se surpreender com o resultado. Resposta O c\u00f3digo dar\u00e1 resultados estranhos, com res n\u00e3o assumindo o valor N * 10000 . Quanto maior o n\u00famero de threads mais distante do correto o valor resultante ser\u00e1. Question Mude o limite do for para 1000 . Os resultados agora s\u00e3o os esperados? Por que? Details Nesse caso funciona, mas \u00e9 por acaso. O valor pequeno do N faz com que a chance de conflitos diminua, mas ainda \u00e9 poss\u00edvel. Este tipo de erro \"escondido\" assim \u00e9 muito dif\u00edcil de encontrar. Danger Nos dois exemplos acima as vari\u00e1veis res eram usadas por m\u00faltiplas threads! Ou seja, cada thread possui uma depend\u00eancia em rela\u00e7\u00e3o a res . Escrever c\u00f3digo sem levar em conta as depend\u00eancias \u00e9 um problema que ser\u00e1 abordado nas pr\u00f3ximas aulas, mas j\u00e1 podemos ver que se duas threads tem uma depend\u00eancia de escrita na mesma vari\u00e1vel coisas ruins acontecer\u00e3o.","title":"Escopo de vari\u00e1veis"},{"location":"aulas/12-paralelismo/#avancado","text":"Question Suponha que voc\u00ea tenha um for que percorre um vetor vec de 1000 elementos e que precisa chamar duas fun\u00e7\u00f5es func1 e func2 neste vetor. As duas fun\u00e7\u00f5es n\u00e3o possuem depend\u00eancias entre si, logo poderiam ser executadas simult\u00e2neamente. Como voc\u00ea usaria omp parallel para execut\u00e1-las em paralelo? Dica : use omp_get_thread_num() .","title":"Avan\u00e7ado"},{"location":"aulas/12-paralelismo/#paralelismo-de-tarefas","text":"Vamos agora criar tarefas que podem ser executadas em paralelo. Defini\u00e7\u00e3o Uma tarefa \u00e9 um bloco de c\u00f3digo que \u00e9 rodado de maneira paralela usando OpenMP. Tarefas s\u00e3o agendadas para cada uma das threads criadas em um regi\u00e3o paralela. N\u00e3o existe uma associa\u00e7\u00e3o 1-1 entre threads e tarefas . Posso ter mais tarefas que threads e mais threads que tarefas . Veja abaixo um exemplo de cria\u00e7\u00e3o de tarefas. #pragma omp parallel { #pragma omp task { std :: cout << \"Estou rodando na tarefa \" << omp_get_thread_num () << \" \\n \" ; } } std :: cout << \"eu s\u00f3 rodo quanto TODAS tarefas acabarem. \\n \" ; Question O exemplo acima cria quantas tarefas, supondo que OMP_NUM_THREADS=4 ? 1 4, uma para cada thread Nenhuma das anteriores Details Como cada thread roda o c\u00f3digo da regi\u00e3o paralela, cada uma cria exatamente um tarefa. Para controlar a cria\u00e7\u00e3o de tarefas em geral usamos a diretiva master , que executa somente na thread de \u00edndice 0 . Assim conseguimos criar c\u00f3digo leg\u00edvel e que deixa bem claro quantas e quais tarefas s\u00e3o criadas. #pragma omp parallel { #pragma omp master { std :: cout << \"s\u00f3 roda uma vez na thread:\" << omp_get_thread_num () << \" \\n \" ; #pragma omp task { std :: cout << \"Estou rodando na thread:\" << omp_get_thread_num () << \" \\n \" ; } } } Somente lendo o c\u00f3digo acima, responda as quest\u00f5es abaixo. Question Quantas tarefas s\u00e3o criadas no exemplo acima? 1 N, uma para cada thread Nenhuma das anteriores Question A(s) tarefa(s) criada(s) roda(m) em qual thread? 0 1 Imposs\u00edvel dizer. Em cada execu\u00e7\u00e3o rodar\u00e1 em uma thread diferente. Example Agora roda o c\u00f3digo em exemplo3.cpp v\u00e1rias vezes e compare suas respostas com a execu\u00e7\u00e3o do programa. Example Complete exercicio1.cpp criando duas tarefas. A primeira dever\u00e1 rodar funcao1 e a segunda funcao2 . Salve seus resultados nas vari\u00e1veis indicadas no c\u00f3digo. Question Leia o c\u00f3digo e responda. Quanto tempo o c\u00f3digo sequencial demora? E o paralelo? Verifique que sua implementa\u00e7\u00e3o est\u00e1 de acordo com suas expectativas. Details Sequencial demora a soma dos tempos das duas fun\u00e7\u00f5es. Paralelo demora o tempo da maior delas.","title":"Paralelismo de tarefas"},{"location":"aulas/13-paralelismo-tarefas-dados/","text":"13 - Paralelismo de dados \u00b6 Nesta pr\u00e1tica iremos usar a contru\u00e7\u00e3o omp parallel for para tratar casos de paralelismo de dados. Revis\u00e3o - tarefas \u00b6 O c\u00f3digo pi-numeric-integration.cpp calcula o pi usando uma t\u00e9cnica chamada integra\u00e7\u00e3o num\u00e9rica. Question Examine o arquivo acima. Onde haveriam oportunidades de paraleliza\u00e7\u00e3o? Details O for da linha 13 calcula o pi. Ele roda muitas vezes, ent\u00e3o \u00e9 um bom candidato a paralelismo. Question Suponha que voc\u00ea ir\u00e1 tentar dividir os c\u00e1lculos do programa em duas partes. Como voc\u00ea faria isso? Details Poder\u00edamos dividir o for na metade e fazer cada metade em uma tarefa. Example Fa\u00e7a a divis\u00e3o do c\u00e1lculo do pi em duas tarefas. Sua primeira tarefa dever\u00e1 guardar seu resultado na vari\u00e1vel res_parte1 . A segunda tarefa dever\u00e1 guardar seu resultado na vari\u00e1vel res_parte2 . Voc\u00ea dever\u00e1 somar os dois resultados ap\u00f3s as tarefas acabarem. Question Me\u00e7a o tempo do programa paralelizado e compare com o original. Verifique tamb\u00e9m que os resultados continuam iguais. O for paralelo \u00b6 Vamos come\u00e7ar nosso estudo do for paralelo executando alguns programas e entendendo como essa constru\u00e7\u00e3o divide as itera\u00e7\u00f5es entre threads. Question Voc\u00ea consegue predizer o resultado do c\u00f3digo abaixo? Se sim, qual seria sua sa\u00edda? Se n\u00e3o, explique por que. #pragma omp parallel for for ( int i = 0 ; i < 16 ; i ++ ) { std :: cout << \"Eu rodei na thread: \" << omp_get_thread_num () << \" \\n \" ; } Example O c\u00f3digo acima est\u00e1 no programa exemplo1.cpp . Execute-o v\u00e1rias vezes e veja se sua resposta acima \u00e9 condizente com a realidade. Resposta N\u00e3o \u00e9 poss\u00edvel predizer. No caso acima o loop foi dividido igualmente entre as threads, mas isso \u00e9 uma decis\u00e3o do compilador e n\u00e3o temos controle sobre qual ser\u00e1 seu comportamento. Isso pode variar de compilador para compilador. O comportamento autom\u00e1tico funciona bem na maioria das vezes. Question Examine o c\u00f3digo abaixo e responda. #pragma omp parallel for schedule(dynamic, 4) for ( int i = 0 ; i < 16 ; i ++ ) { std :: cout << \"Eu rodei na thread: \" << omp_get_thread_num () << \" \\n \" ; } Quantos cores, no m\u00e1ximo, ser\u00e3o usados? Voc\u00ea consegue dizer em qual thread cada itera\u00e7\u00e3o rodar\u00e1? Voc\u00ea consegue dizer quantas itera\u00e7\u00f5es cada thread rodar\u00e1? Suponha que a thread 4 iniciou a itera\u00e7\u00e3o i=4 . Ela processar\u00e1 somente essa itera\u00e7\u00e3o isoladamente? Se sim, explique por que. Se n\u00e3o, diga at\u00e9 qual valor de i ela executar\u00e1. As aloca\u00e7\u00f5es mudam a cada execu\u00e7\u00e3o do programa? Example O c\u00f3digo acima est\u00e1 no programa exemplo2.cpp . Execute-o v\u00e1rias vezes e veja se sua resposta acima \u00e9 condizente com a realidade. Question Examine o c\u00f3digo abaixo e responda. #pragma omp parallel for schedule(static, 1) for ( int i = 0 ; i < 16 ; i ++ ) { std :: cout << \"Eu rodei na thread: \" << omp_get_thread_num () << \" \\n \" ; } Quantos cores, no m\u00e1ximo, ser\u00e3o usados? Voc\u00ea consegue dizer em qual thread cada itera\u00e7\u00e3o rodar\u00e1? Voc\u00ea consegue dizer quantas itera\u00e7\u00f5es cada thread rodar\u00e1? As aloca\u00e7\u00f5es mudam a cada execu\u00e7\u00e3o do programa? Example O c\u00f3digo acima est\u00e1 no programa exemplo3.cpp . Execute-o v\u00e1rias vezes e veja se sua resposta acima \u00e9 condizente com a realidade. Aplicando for paralelo \u00b6 Example Agora que j\u00e1 vimos a constru\u00e7\u00e3o reduce , use-a para paralelizar o problema do arquivo pi-numeric-integration.cpp","title":"13 - Paralelismo de dados"},{"location":"aulas/13-paralelismo-tarefas-dados/#13-paralelismo-de-dados","text":"Nesta pr\u00e1tica iremos usar a contru\u00e7\u00e3o omp parallel for para tratar casos de paralelismo de dados.","title":"13 - Paralelismo de dados"},{"location":"aulas/13-paralelismo-tarefas-dados/#revisao-tarefas","text":"O c\u00f3digo pi-numeric-integration.cpp calcula o pi usando uma t\u00e9cnica chamada integra\u00e7\u00e3o num\u00e9rica. Question Examine o arquivo acima. Onde haveriam oportunidades de paraleliza\u00e7\u00e3o? Details O for da linha 13 calcula o pi. Ele roda muitas vezes, ent\u00e3o \u00e9 um bom candidato a paralelismo. Question Suponha que voc\u00ea ir\u00e1 tentar dividir os c\u00e1lculos do programa em duas partes. Como voc\u00ea faria isso? Details Poder\u00edamos dividir o for na metade e fazer cada metade em uma tarefa. Example Fa\u00e7a a divis\u00e3o do c\u00e1lculo do pi em duas tarefas. Sua primeira tarefa dever\u00e1 guardar seu resultado na vari\u00e1vel res_parte1 . A segunda tarefa dever\u00e1 guardar seu resultado na vari\u00e1vel res_parte2 . Voc\u00ea dever\u00e1 somar os dois resultados ap\u00f3s as tarefas acabarem. Question Me\u00e7a o tempo do programa paralelizado e compare com o original. Verifique tamb\u00e9m que os resultados continuam iguais.","title":"Revis\u00e3o - tarefas"},{"location":"aulas/13-paralelismo-tarefas-dados/#o-for-paralelo","text":"Vamos come\u00e7ar nosso estudo do for paralelo executando alguns programas e entendendo como essa constru\u00e7\u00e3o divide as itera\u00e7\u00f5es entre threads. Question Voc\u00ea consegue predizer o resultado do c\u00f3digo abaixo? Se sim, qual seria sua sa\u00edda? Se n\u00e3o, explique por que. #pragma omp parallel for for ( int i = 0 ; i < 16 ; i ++ ) { std :: cout << \"Eu rodei na thread: \" << omp_get_thread_num () << \" \\n \" ; } Example O c\u00f3digo acima est\u00e1 no programa exemplo1.cpp . Execute-o v\u00e1rias vezes e veja se sua resposta acima \u00e9 condizente com a realidade. Resposta N\u00e3o \u00e9 poss\u00edvel predizer. No caso acima o loop foi dividido igualmente entre as threads, mas isso \u00e9 uma decis\u00e3o do compilador e n\u00e3o temos controle sobre qual ser\u00e1 seu comportamento. Isso pode variar de compilador para compilador. O comportamento autom\u00e1tico funciona bem na maioria das vezes. Question Examine o c\u00f3digo abaixo e responda. #pragma omp parallel for schedule(dynamic, 4) for ( int i = 0 ; i < 16 ; i ++ ) { std :: cout << \"Eu rodei na thread: \" << omp_get_thread_num () << \" \\n \" ; } Quantos cores, no m\u00e1ximo, ser\u00e3o usados? Voc\u00ea consegue dizer em qual thread cada itera\u00e7\u00e3o rodar\u00e1? Voc\u00ea consegue dizer quantas itera\u00e7\u00f5es cada thread rodar\u00e1? Suponha que a thread 4 iniciou a itera\u00e7\u00e3o i=4 . Ela processar\u00e1 somente essa itera\u00e7\u00e3o isoladamente? Se sim, explique por que. Se n\u00e3o, diga at\u00e9 qual valor de i ela executar\u00e1. As aloca\u00e7\u00f5es mudam a cada execu\u00e7\u00e3o do programa? Example O c\u00f3digo acima est\u00e1 no programa exemplo2.cpp . Execute-o v\u00e1rias vezes e veja se sua resposta acima \u00e9 condizente com a realidade. Question Examine o c\u00f3digo abaixo e responda. #pragma omp parallel for schedule(static, 1) for ( int i = 0 ; i < 16 ; i ++ ) { std :: cout << \"Eu rodei na thread: \" << omp_get_thread_num () << \" \\n \" ; } Quantos cores, no m\u00e1ximo, ser\u00e3o usados? Voc\u00ea consegue dizer em qual thread cada itera\u00e7\u00e3o rodar\u00e1? Voc\u00ea consegue dizer quantas itera\u00e7\u00f5es cada thread rodar\u00e1? As aloca\u00e7\u00f5es mudam a cada execu\u00e7\u00e3o do programa? Example O c\u00f3digo acima est\u00e1 no programa exemplo3.cpp . Execute-o v\u00e1rias vezes e veja se sua resposta acima \u00e9 condizente com a realidade.","title":"O for paralelo"},{"location":"aulas/13-paralelismo-tarefas-dados/#aplicando-for-paralelo","text":"Example Agora que j\u00e1 vimos a constru\u00e7\u00e3o reduce , use-a para paralelizar o problema do arquivo pi-numeric-integration.cpp","title":"Aplicando for paralelo"},{"location":"aulas/14-exercicios/","text":"14 - Exerc\u00edcio pr\u00e1tico \u00b6 Agora que j\u00e1 conseguimos resolver problemas simples usando duas abordagens diferentes, vamos aumentar a complexidade dos problemas tratados. Vimos duas abordagens parallel for - \u00fatil para quando precisamos executar a mesma opera\u00e7\u00e3o em um conjunto grande de dados tasks - \u00fatil para paralelizar tarefas heterog\u00eaneas. Teremos ent\u00e3o dois desafios relacionados a paralelizar programas que n\u00e3o s\u00e3o obviamente paraleliz\u00e1veis. C\u00e1lculo do pi recursivo \u00b6 Vamos iniciar com um c\u00f3digo recursivo para c\u00e1lculo do pi. Example Examine o c\u00f3digo em pi_recursivo.cpp . Procure entender bem o que est\u00e1 acontecendo antes de prosseguir. Question Onde est\u00e3o as oportunidades de paralelismo? O c\u00f3digo tem depend\u00eancias? Question Se o c\u00f3digo tiver depend\u00eancias, \u00e9 poss\u00edvel refator\u00e1-lo para elimin\u00e1-las? Question Quantas n\u00edveis de chamadas recursivas s\u00e3o feitas? Quando o programa para de chamar recursivamente e faz sequencial? Vamos agora tentar paralelizar o programa usando as duas t\u00e9cnicas. Usando for paralelo \u00b6 Question Em quais linhas pode haver oportunidade para usar parallel for ? Example Crie uma implementa\u00e7\u00e3o do pi_recursivo usando for paralelo. Me\u00e7a seu tempo e anote. Example O n\u00famero MIN_BLK afeta seu algoritmo? \u00c9 melhor aument\u00e1-lo ou diminu\u00ed-lo? Question Os ganhos de desempenho foram significativos? Question Como voc\u00ea fez o paralelismo? Precisou definir o n\u00famero do for manualmente ou conseguiu realizar a divis\u00e3o automaticamente? Comente abaixo sua implementa\u00e7\u00e3o. Usando task \u00b6 Agora vamos usar task . Neste caso \u00e9 vamos adotar a seguinte estrat\u00e9gia: usaremos tarefas para paralelizar as chamadas recursivas feitas em pi_recursivo.cpp . Example Crie uma implementa\u00e7\u00e3o do pi_recursivo usando tarefas. Me\u00e7a seu tempo e anote. Dica : se voc\u00ea precisar esperar tarefas pode usar a diretiva #pragma omp taskwait . Ela espera por todas as tarefas criadas pela thread atual. Example No seu programa acima quantas tarefas foram criadas? Dica : relacione num_steps com MIN_BLK . Question Os ganhos de desempenho foram significativos? Question Quantas tarefas foram criadas? Voc\u00ea escolheu essa valor como? Example Tente n\u00fameros diferentes de tarefas e verifique se o desempenho melhora ou piora. Anote suas conclus\u00f5es abaixo. Compara\u00e7\u00e3o \u00b6 Question Compare seus resultados das duas abordagens. Anote abaixo seus resultados. Warning \u00c9 poss\u00edvel conseguir tempos muito parecidos com ambas, ent\u00e3o se uma delas ficou muito mais lenta \u00e9 hora de rever o que foi feito.","title":"14 - Exerc\u00edcio pr\u00e1tico"},{"location":"aulas/14-exercicios/#14-exercicio-pratico","text":"Agora que j\u00e1 conseguimos resolver problemas simples usando duas abordagens diferentes, vamos aumentar a complexidade dos problemas tratados. Vimos duas abordagens parallel for - \u00fatil para quando precisamos executar a mesma opera\u00e7\u00e3o em um conjunto grande de dados tasks - \u00fatil para paralelizar tarefas heterog\u00eaneas. Teremos ent\u00e3o dois desafios relacionados a paralelizar programas que n\u00e3o s\u00e3o obviamente paraleliz\u00e1veis.","title":"14 - Exerc\u00edcio pr\u00e1tico"},{"location":"aulas/14-exercicios/#calculo-do-pi-recursivo","text":"Vamos iniciar com um c\u00f3digo recursivo para c\u00e1lculo do pi. Example Examine o c\u00f3digo em pi_recursivo.cpp . Procure entender bem o que est\u00e1 acontecendo antes de prosseguir. Question Onde est\u00e3o as oportunidades de paralelismo? O c\u00f3digo tem depend\u00eancias? Question Se o c\u00f3digo tiver depend\u00eancias, \u00e9 poss\u00edvel refator\u00e1-lo para elimin\u00e1-las? Question Quantas n\u00edveis de chamadas recursivas s\u00e3o feitas? Quando o programa para de chamar recursivamente e faz sequencial? Vamos agora tentar paralelizar o programa usando as duas t\u00e9cnicas.","title":"C\u00e1lculo do pi recursivo"},{"location":"aulas/14-exercicios/#usando-for-paralelo","text":"Question Em quais linhas pode haver oportunidade para usar parallel for ? Example Crie uma implementa\u00e7\u00e3o do pi_recursivo usando for paralelo. Me\u00e7a seu tempo e anote. Example O n\u00famero MIN_BLK afeta seu algoritmo? \u00c9 melhor aument\u00e1-lo ou diminu\u00ed-lo? Question Os ganhos de desempenho foram significativos? Question Como voc\u00ea fez o paralelismo? Precisou definir o n\u00famero do for manualmente ou conseguiu realizar a divis\u00e3o automaticamente? Comente abaixo sua implementa\u00e7\u00e3o.","title":"Usando for paralelo"},{"location":"aulas/14-exercicios/#usando-task","text":"Agora vamos usar task . Neste caso \u00e9 vamos adotar a seguinte estrat\u00e9gia: usaremos tarefas para paralelizar as chamadas recursivas feitas em pi_recursivo.cpp . Example Crie uma implementa\u00e7\u00e3o do pi_recursivo usando tarefas. Me\u00e7a seu tempo e anote. Dica : se voc\u00ea precisar esperar tarefas pode usar a diretiva #pragma omp taskwait . Ela espera por todas as tarefas criadas pela thread atual. Example No seu programa acima quantas tarefas foram criadas? Dica : relacione num_steps com MIN_BLK . Question Os ganhos de desempenho foram significativos? Question Quantas tarefas foram criadas? Voc\u00ea escolheu essa valor como? Example Tente n\u00fameros diferentes de tarefas e verifique se o desempenho melhora ou piora. Anote suas conclus\u00f5es abaixo.","title":"Usando task"},{"location":"aulas/14-exercicios/#comparacao","text":"Question Compare seus resultados das duas abordagens. Anote abaixo seus resultados. Warning \u00c9 poss\u00edvel conseguir tempos muito parecidos com ambas, ent\u00e3o se uma delas ficou muito mais lenta \u00e9 hora de rever o que foi feito.","title":"Compara\u00e7\u00e3o"},{"location":"aulas/15-efeitos-colaterais/","text":"15 - Efeitos Colaterais \u00b6 Agora que j\u00e1 conseguimos resolver um problema um pouco mais complexo usando duas abordagens diferentes, vamos aumentar um pouco mais a complexidade dos problemas tratados. No c\u00f3digo pi_recursivo.cpp t\u00ednhamos uma vari\u00e1vel global que podia ser eliminada do c\u00f3digo mudando a fun\u00e7\u00e3o recursiva. Isso, por\u00e9m, nem sempre \u00e9 poss\u00edvel e precisamos lidar com estas situa\u00e7\u00f5es. Um primeiro teste \u00b6 Vamos iniciar trabalhando com o seguinte trecho de c\u00f3digo (arquivo vetor_insert.cpp ): std :: vector < double > vec ; for ( int i = 0 ; i < N ; i ++ ) { vec . push_back ( conta_complexa ( i )); } Vamos supor agora que usaremos o seguinte comando para paralelizar o c\u00f3digo acima usando OpenMP: #pragma omp parallel for Question A vari\u00e1vel i \u00e9 shared private firstprivate Question A vari\u00e1vel vec \u00e9 shared private firstprivate Question O c\u00f3digo paralelizado rodaria sem dar erros? Os resultados seriam os esperados? Sim, o vector \u00e9 capaz de gerenciar os acessos simult\u00e2neos O c\u00f3digo acima roda sem erros, mas o conte\u00fado do vetor pode n\u00e3o estar correto ao fim do programa N\u00e3o, o c\u00f3digo acima d\u00e1 erro ao executar. Resposta Rode e veja o que acontece ;) Progress Clique ap\u00f3s rodar o programa Agora que vimos o que acontece, vamos consertar isso! Danger Nosso c\u00f3digo d\u00e1 erro pois a opera\u00e7\u00e3o push_back modifica o vetor ! Ou seja, \u00e9 equivalente \u00e0s opera\u00e7\u00f5es de escrita que faz\u00edamos nas aulas anteriores (e que tamb\u00e9m davam errado). Vamos ver ent\u00e3o duas abordagens importantes para contornar esse problema. Se\u00e7\u00f5es cr\u00edticas \u00b6 Antes de come\u00e7ar, vamos aprender mais um aspecto de OpenMP: diretivas para compartilhamento de dados. J\u00e1 vimos na aula 13 as 3 principais op\u00e7\u00f5es: shared private firstprivate O que n\u00e3o falamos ainda \u00e9 que podemos for\u00e7ar a especifica\u00e7\u00e3o de diretivas de compartilhamento para todas as vari\u00e1veis usadas nas constru\u00e7\u00f5es omp parallel , omp task e omp parallel for . Tip Ao adicionarmos default(none) logo ap\u00f3s as diretivas acima precisaremos especificar, para cada vari\u00e1vel usada, sua diretiva de compartilhamento. Isso torna muito mais f\u00e1cil identificar casos de compartilhamento indevido de dados. A partir desse ponto estaremos supondo que todo c\u00f3digo criado usar\u00e1 default(none) . A primeira abordagem usada ter\u00e1 a miss\u00e3o de indicar que um conjunto de linhas cont\u00e9m uma opera\u00e7\u00e3o que possui efeitos colaterais. Dessa maneira, podemos evitar conflitos se s\u00f3 permitirmos que essa regi\u00e3o rode em uma thread por vez . Fazemos isso usando a diretiva omp critical : #pragma omp critical { // c\u00f3digo aqui dentro roda somente em uma thread por vez. } Se duas threads chegam ao mesmo tempo no bloco critical , uma delas ficar\u00e1 esperando at\u00e9 a outra acabar o bloco. Quando isso ocorrer a thread que esperou poder\u00e1 prosseguir. Vamos tentar aplicar isso ao c\u00f3digo de vetor_insert.cpp . Example Use omp critical para solucionar os problemas de concorr\u00eancia do c\u00f3digo acima. Question Escreva abaixo o tempo que seu c\u00f3digo levou para rodar. Progress Clique ap\u00f3s rodar seu c\u00f3digo Se sua implementa\u00e7\u00e3o se parecer com o c\u00f3digo abaixo, ent\u00e3o \u00e9 bem prov\u00e1vel que a vers\u00e3o paralela na verdade tenha demorado o mesmo tempo ou mais que o original. .... #pragma omp parallel for default(none) shared(vec) for ( int i = 0 ; i < N ; i ++ ) { #pragma omp critical { vec . push_back ( conta_complexa ( i )); } } .... Question Analise o c\u00f3digo novamene e tente explicar por que o programa n\u00e3o ganhou velocidade. Resposta A opera\u00e7\u00e3o que produz efeitos colaterais \u00e9 vec.push_back , mas nossa se\u00e7\u00e3o cr\u00edtica envolve tamb\u00e9m a chamada conta_complexa(i) . Example Modifique seu c\u00f3digo de acordo com a resposta acima. Me\u00e7a o desempenho e veja que agora h\u00e1 melhora. Vamos analisar agora a ordem dos dados em vec . Question A ordem se mant\u00e9m igual ao programa sequencial? Voc\u00ea consegue explicar por que? Resposta N\u00e3o se mant\u00e9m. Cada thread chega ao push_back em um momento diferente, logo a ordem em que os dados s\u00e3o adicionados no vetor muda. Manejo de conflitos usando pr\u00e9-aloca\u00e7\u00e3o de mem\u00f3ria \u00b6 Se\u00e7\u00f5es cr\u00edticas s\u00e3o muito \u00fateis quando n\u00e3o conseguimos evitar o compartilhamento de dados. Por\u00e9m, elas s\u00e3o caras e e feitas especialmente para situa\u00e7\u00f5es em que regi\u00e3o cr\u00edtica \u00e9 pequena e chamada um n\u00famero relativamente pequeno de vezes. Como regra, desejamos entrar na regi\u00e3o cr\u00edtica o menor n\u00famero poss\u00edvel de vezes. Question Reveja o c\u00f3digo do in\u00edcio da aula. Seria poss\u00edvel reescrev\u00ea-lo para n\u00e3o usar push_back ? Resposta Sim, bastaria alocar o vetor com tamanho N ao cri\u00e1-lo. Assim poder\u00edamos atribuir conta_complexa direto para a posi\u00e7\u00e3o de mem\u00f3ria desejada. A estrat\u00e9gia acima \u00e9 muito importante em alto desempenho e representa uma maneira de evitar se\u00e7\u00f5es cr\u00edticas e sincroniza\u00e7\u00e3o. \u00c9 sempre melhor alocar mem\u00f3ria em blocos grandes antes do paralelismo do que alocar mem\u00f3ria frequentemente dentro de regi\u00f5es paralelas. Note que fizemos isso na parte de tarefas: ao criarmos vari\u00e1veis para cada tarefa preencher evitamos a necessidade de usar sincroniza\u00e7\u00e3o. Example Modifique o programa para usar a ideia da quest\u00e3o anterior. Me\u00e7a o desempenho e verifique que tudo funciona normalmente e mais r\u00e1pido que o original.","title":"15 - Efeitos Colaterais"},{"location":"aulas/15-efeitos-colaterais/#15-efeitos-colaterais","text":"Agora que j\u00e1 conseguimos resolver um problema um pouco mais complexo usando duas abordagens diferentes, vamos aumentar um pouco mais a complexidade dos problemas tratados. No c\u00f3digo pi_recursivo.cpp t\u00ednhamos uma vari\u00e1vel global que podia ser eliminada do c\u00f3digo mudando a fun\u00e7\u00e3o recursiva. Isso, por\u00e9m, nem sempre \u00e9 poss\u00edvel e precisamos lidar com estas situa\u00e7\u00f5es.","title":"15 - Efeitos Colaterais"},{"location":"aulas/15-efeitos-colaterais/#um-primeiro-teste","text":"Vamos iniciar trabalhando com o seguinte trecho de c\u00f3digo (arquivo vetor_insert.cpp ): std :: vector < double > vec ; for ( int i = 0 ; i < N ; i ++ ) { vec . push_back ( conta_complexa ( i )); } Vamos supor agora que usaremos o seguinte comando para paralelizar o c\u00f3digo acima usando OpenMP: #pragma omp parallel for Question A vari\u00e1vel i \u00e9 shared private firstprivate Question A vari\u00e1vel vec \u00e9 shared private firstprivate Question O c\u00f3digo paralelizado rodaria sem dar erros? Os resultados seriam os esperados? Sim, o vector \u00e9 capaz de gerenciar os acessos simult\u00e2neos O c\u00f3digo acima roda sem erros, mas o conte\u00fado do vetor pode n\u00e3o estar correto ao fim do programa N\u00e3o, o c\u00f3digo acima d\u00e1 erro ao executar. Resposta Rode e veja o que acontece ;) Progress Clique ap\u00f3s rodar o programa Agora que vimos o que acontece, vamos consertar isso! Danger Nosso c\u00f3digo d\u00e1 erro pois a opera\u00e7\u00e3o push_back modifica o vetor ! Ou seja, \u00e9 equivalente \u00e0s opera\u00e7\u00f5es de escrita que faz\u00edamos nas aulas anteriores (e que tamb\u00e9m davam errado). Vamos ver ent\u00e3o duas abordagens importantes para contornar esse problema.","title":"Um primeiro teste"},{"location":"aulas/15-efeitos-colaterais/#secoes-criticas","text":"Antes de come\u00e7ar, vamos aprender mais um aspecto de OpenMP: diretivas para compartilhamento de dados. J\u00e1 vimos na aula 13 as 3 principais op\u00e7\u00f5es: shared private firstprivate O que n\u00e3o falamos ainda \u00e9 que podemos for\u00e7ar a especifica\u00e7\u00e3o de diretivas de compartilhamento para todas as vari\u00e1veis usadas nas constru\u00e7\u00f5es omp parallel , omp task e omp parallel for . Tip Ao adicionarmos default(none) logo ap\u00f3s as diretivas acima precisaremos especificar, para cada vari\u00e1vel usada, sua diretiva de compartilhamento. Isso torna muito mais f\u00e1cil identificar casos de compartilhamento indevido de dados. A partir desse ponto estaremos supondo que todo c\u00f3digo criado usar\u00e1 default(none) . A primeira abordagem usada ter\u00e1 a miss\u00e3o de indicar que um conjunto de linhas cont\u00e9m uma opera\u00e7\u00e3o que possui efeitos colaterais. Dessa maneira, podemos evitar conflitos se s\u00f3 permitirmos que essa regi\u00e3o rode em uma thread por vez . Fazemos isso usando a diretiva omp critical : #pragma omp critical { // c\u00f3digo aqui dentro roda somente em uma thread por vez. } Se duas threads chegam ao mesmo tempo no bloco critical , uma delas ficar\u00e1 esperando at\u00e9 a outra acabar o bloco. Quando isso ocorrer a thread que esperou poder\u00e1 prosseguir. Vamos tentar aplicar isso ao c\u00f3digo de vetor_insert.cpp . Example Use omp critical para solucionar os problemas de concorr\u00eancia do c\u00f3digo acima. Question Escreva abaixo o tempo que seu c\u00f3digo levou para rodar. Progress Clique ap\u00f3s rodar seu c\u00f3digo Se sua implementa\u00e7\u00e3o se parecer com o c\u00f3digo abaixo, ent\u00e3o \u00e9 bem prov\u00e1vel que a vers\u00e3o paralela na verdade tenha demorado o mesmo tempo ou mais que o original. .... #pragma omp parallel for default(none) shared(vec) for ( int i = 0 ; i < N ; i ++ ) { #pragma omp critical { vec . push_back ( conta_complexa ( i )); } } .... Question Analise o c\u00f3digo novamene e tente explicar por que o programa n\u00e3o ganhou velocidade. Resposta A opera\u00e7\u00e3o que produz efeitos colaterais \u00e9 vec.push_back , mas nossa se\u00e7\u00e3o cr\u00edtica envolve tamb\u00e9m a chamada conta_complexa(i) . Example Modifique seu c\u00f3digo de acordo com a resposta acima. Me\u00e7a o desempenho e veja que agora h\u00e1 melhora. Vamos analisar agora a ordem dos dados em vec . Question A ordem se mant\u00e9m igual ao programa sequencial? Voc\u00ea consegue explicar por que? Resposta N\u00e3o se mant\u00e9m. Cada thread chega ao push_back em um momento diferente, logo a ordem em que os dados s\u00e3o adicionados no vetor muda.","title":"Se\u00e7\u00f5es cr\u00edticas"},{"location":"aulas/15-efeitos-colaterais/#manejo-de-conflitos-usando-pre-alocacao-de-memoria","text":"Se\u00e7\u00f5es cr\u00edticas s\u00e3o muito \u00fateis quando n\u00e3o conseguimos evitar o compartilhamento de dados. Por\u00e9m, elas s\u00e3o caras e e feitas especialmente para situa\u00e7\u00f5es em que regi\u00e3o cr\u00edtica \u00e9 pequena e chamada um n\u00famero relativamente pequeno de vezes. Como regra, desejamos entrar na regi\u00e3o cr\u00edtica o menor n\u00famero poss\u00edvel de vezes. Question Reveja o c\u00f3digo do in\u00edcio da aula. Seria poss\u00edvel reescrev\u00ea-lo para n\u00e3o usar push_back ? Resposta Sim, bastaria alocar o vetor com tamanho N ao cri\u00e1-lo. Assim poder\u00edamos atribuir conta_complexa direto para a posi\u00e7\u00e3o de mem\u00f3ria desejada. A estrat\u00e9gia acima \u00e9 muito importante em alto desempenho e representa uma maneira de evitar se\u00e7\u00f5es cr\u00edticas e sincroniza\u00e7\u00e3o. \u00c9 sempre melhor alocar mem\u00f3ria em blocos grandes antes do paralelismo do que alocar mem\u00f3ria frequentemente dentro de regi\u00f5es paralelas. Note que fizemos isso na parte de tarefas: ao criarmos vari\u00e1veis para cada tarefa preencher evitamos a necessidade de usar sincroniza\u00e7\u00e3o. Example Modifique o programa para usar a ideia da quest\u00e3o anterior. Me\u00e7a o desempenho e verifique que tudo funciona normalmente e mais r\u00e1pido que o original.","title":"Manejo de conflitos usando pr\u00e9-aloca\u00e7\u00e3o de mem\u00f3ria"},{"location":"aulas/15-exercicios-rng/","text":"Um problema pr\u00e1tico \u00b6 Vamos agora aplicar esses conhecimentos no exemplo do c\u00e1lculo do pi da aula passada. Example Modifique o c\u00f3digo sequencial para usar as constru\u00e7\u00f5es parallel for e reduce . Os resultados se mantiveram iguais? E o tempo? Example Multiplique num_steps por 10 e tente novamente. E agora? Os ganhos s\u00e3o mais aparentes? Se voc\u00ea achou f\u00e1cil \u00e9 por que \u00e9 mesmo. OpenMP \u00e9 ideal para situa\u00e7\u00f5es como esta: pouca ou nenhuma depend\u00eancia de dados pouca ou nenhuma sincroniza\u00e7\u00e3o loop que roda uma grande quantidade de vezes o mesmo c\u00f3digo. Tamb\u00e9m vimos a maior vantagem do OpenMP : uma pequena modifica\u00e7\u00e3o no c\u00f3digo produz paralelismo eficiente. O maior desafio \u00e9 entender onde est\u00e3o as oportunidades de paralelismo . Com isso identificado, adicionar as anota\u00e7\u00f5es no c\u00f3digo \u00e9 r\u00e1pido. Exerc\u00edcio pr\u00e1tico \u00b6 Vamos agora trabalhar com imagens e paralelizar alguns processamentos de imagem. A ideia ser\u00e1 programar alguns processamentos simples e verificar se o OpenMP traz ganhos de desempenho. Nossa primeira opera\u00e7\u00e3o ser\u00e1 adicionar ru\u00eddo a uma imagem . Isto \u00e9 um pr\u00e9-processamento comum feito para testar a robustez de algoritmos de processamento de imagens a pequenos defeitos. Nosso algoritmo ser\u00e1 o seguinte: para cada ponto da imagem sortearemos um n\u00famero entre 1 e 10 inclusive. Se o n\u00famero for 1 a cor atual deve ser substitu\u00edda por preto. Se o n\u00famero for 10 a cor atual deve ser substitu\u00edda por branco. Caso contr\u00e1rio n\u00e3o mexa na cor atual. Question Examine o cabe\u00e7alho imagem.hpp e verifique como usar a classe Imagem . Onde est\u00e3o armazenados o tamanho da imagem? E os pontos? Como acessar o elemento i, j da imagem? Qual \u00e9 o valor de um pixel branco? E de um pixel preto? Example Fa\u00e7a uma vers\u00e3o sequencial do algoritmo acima, colocando sua solu\u00e7\u00e3o no arquivo exercicio1.cpp . Teste-a com as imagens da pasta atual e veja se as sa\u00eddas incluem pontos brancos/pretos. Vamos agora tentar paralelizar seu programa acima. Question Identique quais partes do programa s\u00e3o paraleliz\u00e1veis. Existe alguma depend\u00eancia de dados? Qual? Question \u00c9 poss\u00edvel desfazer a depend\u00eancia acima? Ou ao menos evitar que ela estrague nosso programa? Como voc\u00ea faria isso? Resposta O gerador de n\u00fameros aleat\u00f3rios depende da ordem de uso para funcionar! Se as itera\u00e7\u00f5es rodarem fora de ordem ent\u00e3o o resultado do nosso programa ser\u00e1 imprevis\u00edvel! Example Antes de prosseguir, tente paralelizar seu programa usando OpenMP. Por enquanto, ignore as depend\u00eancias identificadas acima e finja que tudo dar\u00e1 certo. Question Execute o programa paralelo duas vezes. Os resultados s\u00e3o id\u00eanticos? E se executar o programa sequencial? Nossa solu\u00e7\u00e3o ser\u00e1 baseada em \"enganar\" o gerador de n\u00fameros aleat\u00f3rios para que ele continue gerando n\u00fameros a partir de um certo local de sua sequ\u00eancia. Question Na itera\u00e7\u00e3o i=300 do seu c\u00f3digo anterior, quantos n\u00fameros aleat\u00f3rios j\u00e1 foram gerados? Resposta J\u00e1 foram gerados 299 n\u00fameros. Question Veja a documenta\u00e7\u00e3o do m\u00e9todo discard de default random engine . Como esse m\u00e9todo pode nos ajudar? Resposta Podemos criar um novo gerador a cada passo e avan\u00e7\u00e1-lo para onde ele estaria no c\u00f3digo sequencial. Example Implemente o programa da resposta acima. Voc\u00ea dever\u00e1 usar discard para que os resultados sejam id\u00eanticos aos do programa sequencial. Danger Se seu programa ficou muito mais lento mas resultados id\u00eanticos, prossiga. Question Volte na documenta\u00e7\u00e3o de discard e procure por sua complexidade computacional. Voc\u00ea consegue explicar a raz\u00e3o do programa ter ficado mais lento? Done Se voc\u00ea chegou at\u00e9 aqui ent\u00e3o finalizamos nossa aula. Apesar de parecer simples, utilizar OpenMP para paralelizar c\u00f3digo pode ser bastante complexo. Isso \u00e9 especialmente verdade conforme nosso c\u00f3digo tem mais depend\u00eancias de dados. Na pr\u00f3xima aula falaremos de algumas t\u00e9cnicas que podemos usar para melhorar nossos programas.","title":"Index"},{"location":"aulas/15-exercicios-rng/#um-problema-pratico","text":"Vamos agora aplicar esses conhecimentos no exemplo do c\u00e1lculo do pi da aula passada. Example Modifique o c\u00f3digo sequencial para usar as constru\u00e7\u00f5es parallel for e reduce . Os resultados se mantiveram iguais? E o tempo? Example Multiplique num_steps por 10 e tente novamente. E agora? Os ganhos s\u00e3o mais aparentes? Se voc\u00ea achou f\u00e1cil \u00e9 por que \u00e9 mesmo. OpenMP \u00e9 ideal para situa\u00e7\u00f5es como esta: pouca ou nenhuma depend\u00eancia de dados pouca ou nenhuma sincroniza\u00e7\u00e3o loop que roda uma grande quantidade de vezes o mesmo c\u00f3digo. Tamb\u00e9m vimos a maior vantagem do OpenMP : uma pequena modifica\u00e7\u00e3o no c\u00f3digo produz paralelismo eficiente. O maior desafio \u00e9 entender onde est\u00e3o as oportunidades de paralelismo . Com isso identificado, adicionar as anota\u00e7\u00f5es no c\u00f3digo \u00e9 r\u00e1pido.","title":"Um problema pr\u00e1tico"},{"location":"aulas/15-exercicios-rng/#exercicio-pratico","text":"Vamos agora trabalhar com imagens e paralelizar alguns processamentos de imagem. A ideia ser\u00e1 programar alguns processamentos simples e verificar se o OpenMP traz ganhos de desempenho. Nossa primeira opera\u00e7\u00e3o ser\u00e1 adicionar ru\u00eddo a uma imagem . Isto \u00e9 um pr\u00e9-processamento comum feito para testar a robustez de algoritmos de processamento de imagens a pequenos defeitos. Nosso algoritmo ser\u00e1 o seguinte: para cada ponto da imagem sortearemos um n\u00famero entre 1 e 10 inclusive. Se o n\u00famero for 1 a cor atual deve ser substitu\u00edda por preto. Se o n\u00famero for 10 a cor atual deve ser substitu\u00edda por branco. Caso contr\u00e1rio n\u00e3o mexa na cor atual. Question Examine o cabe\u00e7alho imagem.hpp e verifique como usar a classe Imagem . Onde est\u00e3o armazenados o tamanho da imagem? E os pontos? Como acessar o elemento i, j da imagem? Qual \u00e9 o valor de um pixel branco? E de um pixel preto? Example Fa\u00e7a uma vers\u00e3o sequencial do algoritmo acima, colocando sua solu\u00e7\u00e3o no arquivo exercicio1.cpp . Teste-a com as imagens da pasta atual e veja se as sa\u00eddas incluem pontos brancos/pretos. Vamos agora tentar paralelizar seu programa acima. Question Identique quais partes do programa s\u00e3o paraleliz\u00e1veis. Existe alguma depend\u00eancia de dados? Qual? Question \u00c9 poss\u00edvel desfazer a depend\u00eancia acima? Ou ao menos evitar que ela estrague nosso programa? Como voc\u00ea faria isso? Resposta O gerador de n\u00fameros aleat\u00f3rios depende da ordem de uso para funcionar! Se as itera\u00e7\u00f5es rodarem fora de ordem ent\u00e3o o resultado do nosso programa ser\u00e1 imprevis\u00edvel! Example Antes de prosseguir, tente paralelizar seu programa usando OpenMP. Por enquanto, ignore as depend\u00eancias identificadas acima e finja que tudo dar\u00e1 certo. Question Execute o programa paralelo duas vezes. Os resultados s\u00e3o id\u00eanticos? E se executar o programa sequencial? Nossa solu\u00e7\u00e3o ser\u00e1 baseada em \"enganar\" o gerador de n\u00fameros aleat\u00f3rios para que ele continue gerando n\u00fameros a partir de um certo local de sua sequ\u00eancia. Question Na itera\u00e7\u00e3o i=300 do seu c\u00f3digo anterior, quantos n\u00fameros aleat\u00f3rios j\u00e1 foram gerados? Resposta J\u00e1 foram gerados 299 n\u00fameros. Question Veja a documenta\u00e7\u00e3o do m\u00e9todo discard de default random engine . Como esse m\u00e9todo pode nos ajudar? Resposta Podemos criar um novo gerador a cada passo e avan\u00e7\u00e1-lo para onde ele estaria no c\u00f3digo sequencial. Example Implemente o programa da resposta acima. Voc\u00ea dever\u00e1 usar discard para que os resultados sejam id\u00eanticos aos do programa sequencial. Danger Se seu programa ficou muito mais lento mas resultados id\u00eanticos, prossiga. Question Volte na documenta\u00e7\u00e3o de discard e procure por sua complexidade computacional. Voc\u00ea consegue explicar a raz\u00e3o do programa ter ficado mais lento? Done Se voc\u00ea chegou at\u00e9 aqui ent\u00e3o finalizamos nossa aula. Apesar de parecer simples, utilizar OpenMP para paralelizar c\u00f3digo pode ser bastante complexo. Isso \u00e9 especialmente verdade conforme nosso c\u00f3digo tem mais depend\u00eancias de dados. Na pr\u00f3xima aula falaremos de algumas t\u00e9cnicas que podemos usar para melhorar nossos programas.","title":"Exerc\u00edcio pr\u00e1tico"},{"location":"aulas/16-efeitos-colaterais-II/","text":"16 - Efeitos Colaterais II \u00b6 Na aula de hoje iremos trabalhar com um algoritmo de sorteios aleat\u00f3rios para calcular o pi . Ele \u00e9 baseado em uma t\u00e9cnica de Otimiza\u00e7\u00e3o, Simula\u00e7\u00e3o e Estima\u00e7\u00e3o Param\u00e9trica chamada Monte Carlos . O algoritmo sequencial se baseia em sorteios de pontos dentro de um quadrado de lado 2 . Se a dist\u00e2ncia entre o ponto e o centro do quadrado for menor que 1 ent\u00e3o o ponto cai dentro do c\u00edrculo inscrito no quadrado. A quantidade de pontos que caem dentro do quadrado \u00e9 proporcional a \\pi \\pi . Veja abaixo um resumo do algoritmo. sum = 0 De i=0 at\u00e9 N : sorteie pontos x,y \\in [0,1] x,y \\in [0,1] se x^2 + y^2 \\leq 1 x^2 + y^2 \\leq 1 , sum += 1 devolva 4 * sum / N Example Fa\u00e7a uma implementa\u00e7\u00e3o sequencial desse algoritmo. Chama seu programa de pi_montecarlo.cpp . Para fins de debug das pr\u00f3ximas vers\u00f5es, mostre o valor de sum na sa\u00edda de erros. Adote N=100 000 . \u00c9 poss\u00edvel paralelizar o problema? \u00b6 Vamos iniciar pensando um pouco sobre o problema acima. Question O algoritmo acima \u00e9 paraleliz\u00e1vel? Qual t\u00e9cnica voc\u00ea utilizaria para paraleliz\u00e1-lo? Resposta O for paralelo parece encaixar muito bem neste problema, com a vari\u00e1vel sum sendo usada na op\u00e7\u00e3o reduction Question Al\u00e9m da vari\u00e1vel sum , existe outra opera\u00e7\u00e3o que gera efeitos colaterais no c\u00f3digo acima? Qual? Resposta O sorteio de pontos! Lembramos da aula 06 que a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 um processo sequencial que depende dos n\u00fameros anteriormente sorteados. Progress Continuar Agora que sabemos que gerar n\u00fameros aleat\u00f3rios \u00e9 um processo sequencial, vamos considerar o quanto isso atrapalha nosso programa. Nas pr\u00f3ximas quest\u00f5es leve em conta que o gerador de n\u00fameros aleat\u00f3rios \u00e9 uma vari\u00e1vel compartilhada. Question Como evitar\u00edamos problemas ao compartilhar o gerador de n\u00fameros aleat\u00f3rios? Resposta Podemos envolver o passo 2a do algoritmo em uma se\u00e7\u00e3o cr\u00edtica usando omp critical Question Se o for acima rodar em uma ordem completamente diferente os resultados se alterar\u00e3o? Resposta Desde de que os pares x,y sorteados sejam os mesmos ent\u00e3o n\u00e3o haver\u00e1 problema. Example Com base em todas as suas respostas dos exerc\u00edcios anteriores, fa\u00e7a uma implementa\u00e7\u00e3o paralela do pi_montecarlo.cpp . Verifique que o valor de sum \u00e9 igual ao sequencial. Por enquanto, n\u00e3o se preocupe com o tempo de execu\u00e7\u00e3o . Question Anote o tempo de execu\u00e7\u00e3o sequencial e paralelo para o programa acima. Progress Vamos discutir esse resultado juntos! Paralelizando processos inerentemente sequenciais \u00b6 Como discutimos agora h\u00e1 pouco, a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 um processo inerentemente sequencial. N\u00e3o \u00e9 que seja imposs\u00edvel paraleliz\u00e1-lo eficientemente, \u00e9 que \u00e9 imposs\u00edvel paraleliz\u00e1-lo at all . Vamos tentar contornar isso ent\u00e3o usando a resposta da Quest\u00e3o 4 : O for do algoritmo depende dos pontos gerados, n\u00e3o da ordem que eles foram gerados. Vamos ent\u00e3o adotar uma solu\u00e7\u00e3o simples: a cada itera\u00e7\u00e3o do for criamos um novo gerador de n\u00fameros aleat\u00f3rios e sorteamos um par de pontos dele. Primeira tentativa \u00b6 Question Sabemos que um gerador de n\u00fameros aleat\u00f3rios gera sempre a mesma sequ\u00eancia de n\u00fameros, dado um par\u00e2metro seed fixo. O qu\u00ea acontece se usarmos o mesmo seed em todas as itera\u00e7\u00f5es? Como consertar isso? Resposta Sortearemos o mesmo ponto em todas as itera\u00e7\u00f5es. Para consertar isso podemos fazer o seed ser baseado no i da itera\u00e7\u00e3o atual. Example Crie uma implementa\u00e7\u00e3o baseada na ideia acima. Question Anote abaixo o valor do pi encontrado e o tempo de execu\u00e7\u00e3o. Question Os resultados obtidos s\u00e3o id\u00eanticos aos do programa original? S\u00e3o pr\u00f3ximos? Progress Vamos discutir esse resultado. Segunda tentativa \u00b6 O problema da nossa tentativa anterior \u00e9 que n\u00e3o temos de verdade sequ\u00eancias de pontos aleat\u00f3rias. Bom, na verdade nunca temos, mas o problema \u00e9 que violamos a promessa que o RNG faz. Ele promete que dado um seed fixo, a sequ\u00eancia de n\u00fameros geradas \u00e9 indistingu\u00edvel de uma sequ\u00eancia aleat\u00f3ria de verdade Ele n\u00e3o promete que, se criarmos v\u00e1rios RNG s, a sequ\u00eancia formada pelo primeiro par de n\u00fameros gerados por cada um ser\u00e1 aleat\u00f3ria. Vamos agora tentar uma nova ideia: Cada thread ir\u00e1 gerar N/NUM_THREADS n\u00fameros aleat\u00f3rios, atualizando sum com os pontos dentro do semi-c\u00edrculo. Question Como esta ideia melhora o algoritmo acima? Resposta Agora teremos NUM_THREADS sequ\u00eancias pseudo-aleat\u00f3rias \"v\u00e1lidas\" e junt\u00e1-las passa a ser um problema menor. Continuamos precisando usar uma seed para cada, mas ao menos agora temos um n\u00famero pequeno de RNG s. Example Fa\u00e7a uma implementa\u00e7\u00e3o da ideia acima. Voc\u00ea pode usar os comandos do OpenMP que quiser. Question Anote o tempo de execu\u00e7\u00e3o e o pi encontrado.","title":"16 - Efeitos Colaterais II"},{"location":"aulas/16-efeitos-colaterais-II/#16-efeitos-colaterais-ii","text":"Na aula de hoje iremos trabalhar com um algoritmo de sorteios aleat\u00f3rios para calcular o pi . Ele \u00e9 baseado em uma t\u00e9cnica de Otimiza\u00e7\u00e3o, Simula\u00e7\u00e3o e Estima\u00e7\u00e3o Param\u00e9trica chamada Monte Carlos . O algoritmo sequencial se baseia em sorteios de pontos dentro de um quadrado de lado 2 . Se a dist\u00e2ncia entre o ponto e o centro do quadrado for menor que 1 ent\u00e3o o ponto cai dentro do c\u00edrculo inscrito no quadrado. A quantidade de pontos que caem dentro do quadrado \u00e9 proporcional a \\pi \\pi . Veja abaixo um resumo do algoritmo. sum = 0 De i=0 at\u00e9 N : sorteie pontos x,y \\in [0,1] x,y \\in [0,1] se x^2 + y^2 \\leq 1 x^2 + y^2 \\leq 1 , sum += 1 devolva 4 * sum / N Example Fa\u00e7a uma implementa\u00e7\u00e3o sequencial desse algoritmo. Chama seu programa de pi_montecarlo.cpp . Para fins de debug das pr\u00f3ximas vers\u00f5es, mostre o valor de sum na sa\u00edda de erros. Adote N=100 000 .","title":"16 - Efeitos Colaterais II"},{"location":"aulas/16-efeitos-colaterais-II/#e-possivel-paralelizar-o-problema","text":"Vamos iniciar pensando um pouco sobre o problema acima. Question O algoritmo acima \u00e9 paraleliz\u00e1vel? Qual t\u00e9cnica voc\u00ea utilizaria para paraleliz\u00e1-lo? Resposta O for paralelo parece encaixar muito bem neste problema, com a vari\u00e1vel sum sendo usada na op\u00e7\u00e3o reduction Question Al\u00e9m da vari\u00e1vel sum , existe outra opera\u00e7\u00e3o que gera efeitos colaterais no c\u00f3digo acima? Qual? Resposta O sorteio de pontos! Lembramos da aula 06 que a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 um processo sequencial que depende dos n\u00fameros anteriormente sorteados. Progress Continuar Agora que sabemos que gerar n\u00fameros aleat\u00f3rios \u00e9 um processo sequencial, vamos considerar o quanto isso atrapalha nosso programa. Nas pr\u00f3ximas quest\u00f5es leve em conta que o gerador de n\u00fameros aleat\u00f3rios \u00e9 uma vari\u00e1vel compartilhada. Question Como evitar\u00edamos problemas ao compartilhar o gerador de n\u00fameros aleat\u00f3rios? Resposta Podemos envolver o passo 2a do algoritmo em uma se\u00e7\u00e3o cr\u00edtica usando omp critical Question Se o for acima rodar em uma ordem completamente diferente os resultados se alterar\u00e3o? Resposta Desde de que os pares x,y sorteados sejam os mesmos ent\u00e3o n\u00e3o haver\u00e1 problema. Example Com base em todas as suas respostas dos exerc\u00edcios anteriores, fa\u00e7a uma implementa\u00e7\u00e3o paralela do pi_montecarlo.cpp . Verifique que o valor de sum \u00e9 igual ao sequencial. Por enquanto, n\u00e3o se preocupe com o tempo de execu\u00e7\u00e3o . Question Anote o tempo de execu\u00e7\u00e3o sequencial e paralelo para o programa acima. Progress Vamos discutir esse resultado juntos!","title":"\u00c9 poss\u00edvel paralelizar o problema?"},{"location":"aulas/16-efeitos-colaterais-II/#paralelizando-processos-inerentemente-sequenciais","text":"Como discutimos agora h\u00e1 pouco, a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 um processo inerentemente sequencial. N\u00e3o \u00e9 que seja imposs\u00edvel paraleliz\u00e1-lo eficientemente, \u00e9 que \u00e9 imposs\u00edvel paraleliz\u00e1-lo at all . Vamos tentar contornar isso ent\u00e3o usando a resposta da Quest\u00e3o 4 : O for do algoritmo depende dos pontos gerados, n\u00e3o da ordem que eles foram gerados. Vamos ent\u00e3o adotar uma solu\u00e7\u00e3o simples: a cada itera\u00e7\u00e3o do for criamos um novo gerador de n\u00fameros aleat\u00f3rios e sorteamos um par de pontos dele.","title":"Paralelizando processos inerentemente sequenciais"},{"location":"aulas/16-efeitos-colaterais-II/#primeira-tentativa","text":"Question Sabemos que um gerador de n\u00fameros aleat\u00f3rios gera sempre a mesma sequ\u00eancia de n\u00fameros, dado um par\u00e2metro seed fixo. O qu\u00ea acontece se usarmos o mesmo seed em todas as itera\u00e7\u00f5es? Como consertar isso? Resposta Sortearemos o mesmo ponto em todas as itera\u00e7\u00f5es. Para consertar isso podemos fazer o seed ser baseado no i da itera\u00e7\u00e3o atual. Example Crie uma implementa\u00e7\u00e3o baseada na ideia acima. Question Anote abaixo o valor do pi encontrado e o tempo de execu\u00e7\u00e3o. Question Os resultados obtidos s\u00e3o id\u00eanticos aos do programa original? S\u00e3o pr\u00f3ximos? Progress Vamos discutir esse resultado.","title":"Primeira tentativa"},{"location":"aulas/16-efeitos-colaterais-II/#segunda-tentativa","text":"O problema da nossa tentativa anterior \u00e9 que n\u00e3o temos de verdade sequ\u00eancias de pontos aleat\u00f3rias. Bom, na verdade nunca temos, mas o problema \u00e9 que violamos a promessa que o RNG faz. Ele promete que dado um seed fixo, a sequ\u00eancia de n\u00fameros geradas \u00e9 indistingu\u00edvel de uma sequ\u00eancia aleat\u00f3ria de verdade Ele n\u00e3o promete que, se criarmos v\u00e1rios RNG s, a sequ\u00eancia formada pelo primeiro par de n\u00fameros gerados por cada um ser\u00e1 aleat\u00f3ria. Vamos agora tentar uma nova ideia: Cada thread ir\u00e1 gerar N/NUM_THREADS n\u00fameros aleat\u00f3rios, atualizando sum com os pontos dentro do semi-c\u00edrculo. Question Como esta ideia melhora o algoritmo acima? Resposta Agora teremos NUM_THREADS sequ\u00eancias pseudo-aleat\u00f3rias \"v\u00e1lidas\" e junt\u00e1-las passa a ser um problema menor. Continuamos precisando usar uma seed para cada, mas ao menos agora temos um n\u00famero pequeno de RNG s. Example Fa\u00e7a uma implementa\u00e7\u00e3o da ideia acima. Voc\u00ea pode usar os comandos do OpenMP que quiser. Question Anote o tempo de execu\u00e7\u00e3o e o pi encontrado.","title":"Segunda tentativa"},{"location":"aulas/17-intro-gpu/","text":"17 - Introdu\u00e7\u00e3o a GPU \u00b6 Como visto em aula, programa\u00e7\u00e3o para GPU requer ferramentas especializadas capazes de gerar c\u00f3digo que rode parte na CPU (chamada de host ) e parte na GPU (chamada de target ). Nesta parte introdut\u00f3ria usaremos a biblioteca cuda::thrust . Ela possui um pequeno conjunto de opera\u00e7\u00f5es otimizadas para GPU e que podem ser customizadas para diversos prop\u00f3sitos. Documenta\u00e7\u00e3o oficial A documenta\u00e7\u00e3o oficial da Thrust est\u00e1 dispon\u00edvel no endere\u00e7o https://thrust.github.io/doc/modules.html . Tamb\u00e9m vamos focar em usar m\u00e1quinas pr\u00e9-configuradas. Compila\u00e7\u00e3o para GPU \u00b6 Para compilar programas para rodar na GPU devemos usar o compilador nvcc . Ele identifica quais por\u00e7\u00f5es do c\u00f3digo dever\u00e3o ser compiladas para a GPU. O restante do c\u00f3digo, que roda exclusivamente na CPU, \u00e9 passado diretamente para um compilador C++ regular e um \u00fanico execut\u00e1vel \u00e9 gerado contendo o c\u00f3digo para CPU e chamadas inseridas pelo nvcc para invocar as fun\u00e7\u00f5es que rodam na GPU. O nvcc e todas as bibliotecas que precisamos est\u00e3o dispon\u00edveis no pacote nvidia-cuda-toolkit pronto para instala\u00e7\u00e3o via apt . A vers\u00e3o disponibilizada n\u00e3o \u00e9 a mais atual, mas tudo funciona de maneira integrada e n\u00e3o \u00e9 necess\u00e1rio instalar nada manualmente. Se voc\u00ea usar as VMs do Insper ent\u00e3o n\u00e3o precisa fazer nada. Todas as ferramentas j\u00e1 est\u00e3o instaladas l\u00e1 e a VM j\u00e1 vem pronta para uso. Example Verifique que sua instala\u00e7\u00e3o funciona compilando o arquivo abaixo. $ nvcc -arch=sm_70 -std=c++14 exemplo1-criacao-iteracao.cu -o exemplo1 Se der tudo certo a execu\u00e7\u00e3o do programa acima dever\u00e1 gerar um execut\u00e1vel exemplo1 que roda e produz o seguinte resultado. Host vector: 0 0 12 0 35 Device vector 0 0 0 0 35 Compila\u00e7\u00e3o para CPU \u00b6 Se voc\u00ea ainda n\u00e3o tem uma GPU pode usar o suporte da thrust para OpenMP nas nossas primeiras aulas. Todos os trabalhos ser\u00e3o corrigidos usando GPU usando nvcc . Esta alternativa \u00e9 importante somente para as primeiras aulas, em que nem todos ter\u00e3o acesso ainda a uma GPU. Usaremos isso somente para facilitar o primeiro contato, mas essa op\u00e7\u00e3o n\u00e3o \u00e9 v\u00e1lida para avalia\u00e7\u00f5es. baixar o c\u00f3digo fonte da thrust no github . adicionar as seguintes flags no g++ -DTHRUST_DEVICE_SYSTEM=THRUST_DEVICE_SYSTEM_OMP : diz que a paraleliza\u00e7\u00e3o de device_vetor ser\u00e1 usando OpenMP -I/home/.... : o caminho passado ser\u00e1 usado na busca por include s. Coloque o caminho do reposit\u00f3rio da thrust -fopenmp : j\u00e1 conhecemos este ;) -x c++ : for\u00e7a a compila\u00e7\u00e3o de arquivos .cu como c\u00f3digo fonte C++ Example Verifique que sua instala\u00e7\u00e3o funciona compilando o arquivo abaixo. $ g++ -DTHRUST_DEVICE_SYSTEM=THRUST_DEVICE_SYSTEM_OMP -I/caminho/para/thrust/ -fopenmp -x c++ exemplo1-criacao-iteracao.cu -o exemplo1-cpu Se der tudo certo a execu\u00e7\u00e3o do programa acima dever\u00e1 gerar um execut\u00e1vel exemplo1-cpu que roda e produz o seguinte resultado. Host vector: 0 0 12 0 35 Device vector 0 0 0 0 35 Nem tudo o que roda usando thrust/OpenMP roda em GPU. Por essa raz\u00e3o, esse recurso ser\u00e1 usado somente para testes e nunca para avalia\u00e7\u00e3o. Transfer\u00eancia de dados \u00b6 Como visto na expositiva, a CPU e a GPU possuem espa\u00e7os de endere\u00e7amento completamente distintos. Ou seja, a CPU n\u00e3o consegue acessar os dados na mem\u00f3ria da GPU e vice-versa. A thrust disponibiliza somente um tipo de container ( vector ) e facilita este gerenciamento deixando expl\u00edcito se ele est\u00e1 alocado na CPU ( host ) ou na GPU ( device ). A c\u00f3pia CPU \\leftrightarrow \\leftrightarrow GPU \u00e9 feita implicitamente quando criamos um device_vector ou quando usamos a opera\u00e7\u00e3o de atribui\u00e7\u00e3o entre host_vector e device_vector . Veja o exemplo abaixo: thrust :: host_vector < double > vec_cpu ( 10 ); // alocado na CPU vec1 [ 0 ] = 20 ; vec2 [ 1 ] = 30 ; // aloca vetor na GPU e transfere dados CPU->GPU thrust :: device_vector < double > vec_gpu ( vec_cpu ); //processa vec_gpu vec_cpu = vec_gpu ; // copia dados GPU -> CPU A thrust usa iteradores em todas as suas fun\u00e7\u00f5es. Pense em um iterador como um ponteiro para os elementos do array. Por\u00e9m, um iterador \u00e9 mais esperto: ele guarda tamb\u00e9m o tipo do vetor original e suporta opera\u00e7\u00f5es ++ e * para qualquer tipo de dado iterado de maneira transparente. Vetores thrust aceitam os m\u00e9todos v.begin() para retornar um iterador para o come\u00e7o do vetor e v.end() para um iterador para o fim (depois do \u00faltimo elemento). Podemos tamb\u00e9m somar um valor n a um iterador. Isto \u00e9 equivalente a fazer n vezes a opera\u00e7\u00e3o ++ . Veja abaixo um exemplo de uso das fun\u00e7\u00f5es fill e sequence para preencher valores em um vetor de maneira eficiente. thrust :: device_vector < int > v ( 5 , 0 ); // vetor de 5 ints zerado // v = {0, 0, 0, 0, 0} thrust :: sequence ( v . begin (), v . end ()); // preenche com 0, 1, 2, .... // v = {0, 1, 2, 3, 4} thrust :: fill ( v . begin (), v . begin () + 2 , 13 ); // dois primeiros elementos = 13 // v = {13, 13, 2, 3, 4} Question Consulte o arquivo exemplo1-criacao-iteracao.cu para um exemplo completo de aloca\u00e7\u00e3o e transfer\u00eancia de dados e do uso de iteradores. Example O fluxo de trabalho \"normal\" de aplica\u00e7\u00f5es usando GPU \u00e9 receber os dados em um vetor na CPU e copi\u00e1-los para a GPU para fazer processamentos. Crie um programa que l\u00ea uma sequ\u00eancia de double s da entrada padr\u00e3o em um thrust::host_vector e os copia para um thrust::device_vector . Teste seu programa com o arquivo stocks-google.txt , que cont\u00e9m o pre\u00e7o das a\u00e7\u00f5es do Google nos \u00faltimos 10 anos. Example A cria\u00e7\u00e3o de um device_vector \u00e9 demorada. Me\u00e7a o tempo que a opera\u00e7\u00e3o de aloca\u00e7\u00e3o e c\u00f3pia demora e imprima na sa\u00edda de erros. (Use std::chrono ). Opera\u00e7\u00f5es de redu\u00e7\u00e3o \u00b6 Uma opera\u00e7\u00e3o gen\u00e9rica de redu\u00e7\u00e3o transforma um vetor em um \u00fanico valor. Exemplos cl\u00e1ssicos de opera\u00e7\u00f5es de redu\u00e7\u00e3o incluem soma , m\u00e9dia e m\u00ednimo/m\u00e1ximo de um vetor. A thrust disponibiliza este tipo de opera\u00e7\u00e3o otimizada em GPU usando a fun\u00e7\u00e3o thrust::reduce : val = thrust :: reduce ( iter_comeco , iter_fim , inicial , op ); // iter_comeco: iterador para o come\u00e7o dos dados // iter_fim: iterador para o fim dos dados // inicial: valor inicial // op: opera\u00e7\u00e3o a ser feita. Um exemplo de uso de redu\u00e7\u00e3o para computar o m\u00e1ximo pode ser visto aqui . A lista completa de fun\u00e7\u00f5es que podem ser usadas no lugar de op pode ser vista neste link . Example Continuando o exerc\u00edcio anterior, calcule as seguintes medidas. N\u00e3o se esque\u00e7a de passar o device_vector para a sua fun\u00e7\u00e3o reduce O pre\u00e7o m\u00e9dio das a\u00e7\u00f5es nos \u00faltimos 10 anos. O pre\u00e7o m\u00e9dio das a\u00e7\u00f5es no \u00faltimo ano (365 dias atr\u00e1s). O maior e o menor pre\u00e7o da sequ\u00eancia inteira e do \u00faltimo ano. Voc\u00ea pode consultar todos os tipos de redu\u00e7\u00f5es dispon\u00edveis no site da thrust . Transforma\u00e7\u00f5es ponto a ponto \u00b6 Al\u00e9m de opera\u00e7\u00f5es de redu\u00e7\u00e3o tamb\u00e9m podemos fazer opera\u00e7\u00f5es ponto a ponto em somente um vetor (como negar todas as componentes ou calcular os quadrados) quanto entre dois vetores (como somar dois vetores componente por componente ou comparar cada elemento com seu correspondente em outro vetor). A thrust d\u00e1 o nome de transformation para este tipo de opera\u00e7\u00e3o. // para opera\u00e7\u00f5es entre dois vetores iter1 e iter2. resultado armazenado em out thrust :: transform ( iter1_comeco , iter1_fim , iter2_comeco , out_comeco , op ); // iter1_comeco: iterador para o come\u00e7o de iter1 // iter1_fim: iterador para o fim de iter1 // iter2_comeco: iterador para o come\u00e7o de iter2 // out_comeco: iterador para o come\u00e7o de out // op: opera\u00e7\u00e3o a ser realizada. Um exemplo concreto pode ser visto abaixo. O c\u00f3digo completo est\u00e1 em exemplo2-transform.cu thrust :: device_vector < double > V1 ( 10 , 0 ); thrust :: device_vector < double > V2 ( 10 , 0 ); thrust :: device_vector < double > V3 ( 10 , 0 ); thrust :: device_vector < double > V4 ( 10 , 0 ); // inicializa V1 e V2 aqui //soma V1 e V2 thrust :: transform ( V1 . begin (), V1 . end (), V2 . begin (), V3 . begin (), thrust :: plus < double > ()); // multiplica V1 por 0.5 thrust :: transform ( V1 . begin (), V1 . end (), thrust :: constant_iterator < double > ( 0.5 ), V4 . begin (), thrust :: multiplies < double > ()); As opera\u00e7\u00f5es que foram usadas no reduce tamb\u00e9m podem ser usadas em um transform . N\u00e3o se esque\u00e7a de consultar a lista de opera\u00e7\u00f5es para fazer este exerc\u00edcio. Example Vamos agora trabalhar com o arquivo stocks2.csv . Ele cont\u00e9m a s\u00e9rie hist\u00f3rica de a\u00e7\u00f5es da Apple e da Microsoft. Seu objetivo \u00e9 calcular a diferen\u00e7a m\u00e9dia entre os pre\u00e7os das a\u00e7\u00f5es AAPL e MSFT. Dica : quebre o problema em duas partes. Primeiro calcule a diferen\u00e7a entre os pre\u00e7os e guarde isto em um vetor. Depois compute a m\u00e9dia deste vetor.","title":"17 - Introdu\u00e7\u00e3o a GPU"},{"location":"aulas/17-intro-gpu/#17-introducao-a-gpu","text":"Como visto em aula, programa\u00e7\u00e3o para GPU requer ferramentas especializadas capazes de gerar c\u00f3digo que rode parte na CPU (chamada de host ) e parte na GPU (chamada de target ). Nesta parte introdut\u00f3ria usaremos a biblioteca cuda::thrust . Ela possui um pequeno conjunto de opera\u00e7\u00f5es otimizadas para GPU e que podem ser customizadas para diversos prop\u00f3sitos. Documenta\u00e7\u00e3o oficial A documenta\u00e7\u00e3o oficial da Thrust est\u00e1 dispon\u00edvel no endere\u00e7o https://thrust.github.io/doc/modules.html . Tamb\u00e9m vamos focar em usar m\u00e1quinas pr\u00e9-configuradas.","title":"17 - Introdu\u00e7\u00e3o a GPU"},{"location":"aulas/17-intro-gpu/#compilacao-para-gpu","text":"Para compilar programas para rodar na GPU devemos usar o compilador nvcc . Ele identifica quais por\u00e7\u00f5es do c\u00f3digo dever\u00e3o ser compiladas para a GPU. O restante do c\u00f3digo, que roda exclusivamente na CPU, \u00e9 passado diretamente para um compilador C++ regular e um \u00fanico execut\u00e1vel \u00e9 gerado contendo o c\u00f3digo para CPU e chamadas inseridas pelo nvcc para invocar as fun\u00e7\u00f5es que rodam na GPU. O nvcc e todas as bibliotecas que precisamos est\u00e3o dispon\u00edveis no pacote nvidia-cuda-toolkit pronto para instala\u00e7\u00e3o via apt . A vers\u00e3o disponibilizada n\u00e3o \u00e9 a mais atual, mas tudo funciona de maneira integrada e n\u00e3o \u00e9 necess\u00e1rio instalar nada manualmente. Se voc\u00ea usar as VMs do Insper ent\u00e3o n\u00e3o precisa fazer nada. Todas as ferramentas j\u00e1 est\u00e3o instaladas l\u00e1 e a VM j\u00e1 vem pronta para uso. Example Verifique que sua instala\u00e7\u00e3o funciona compilando o arquivo abaixo. $ nvcc -arch=sm_70 -std=c++14 exemplo1-criacao-iteracao.cu -o exemplo1 Se der tudo certo a execu\u00e7\u00e3o do programa acima dever\u00e1 gerar um execut\u00e1vel exemplo1 que roda e produz o seguinte resultado. Host vector: 0 0 12 0 35 Device vector 0 0 0 0 35","title":"Compila\u00e7\u00e3o para GPU"},{"location":"aulas/17-intro-gpu/#compilacao-para-cpu","text":"Se voc\u00ea ainda n\u00e3o tem uma GPU pode usar o suporte da thrust para OpenMP nas nossas primeiras aulas. Todos os trabalhos ser\u00e3o corrigidos usando GPU usando nvcc . Esta alternativa \u00e9 importante somente para as primeiras aulas, em que nem todos ter\u00e3o acesso ainda a uma GPU. Usaremos isso somente para facilitar o primeiro contato, mas essa op\u00e7\u00e3o n\u00e3o \u00e9 v\u00e1lida para avalia\u00e7\u00f5es. baixar o c\u00f3digo fonte da thrust no github . adicionar as seguintes flags no g++ -DTHRUST_DEVICE_SYSTEM=THRUST_DEVICE_SYSTEM_OMP : diz que a paraleliza\u00e7\u00e3o de device_vetor ser\u00e1 usando OpenMP -I/home/.... : o caminho passado ser\u00e1 usado na busca por include s. Coloque o caminho do reposit\u00f3rio da thrust -fopenmp : j\u00e1 conhecemos este ;) -x c++ : for\u00e7a a compila\u00e7\u00e3o de arquivos .cu como c\u00f3digo fonte C++ Example Verifique que sua instala\u00e7\u00e3o funciona compilando o arquivo abaixo. $ g++ -DTHRUST_DEVICE_SYSTEM=THRUST_DEVICE_SYSTEM_OMP -I/caminho/para/thrust/ -fopenmp -x c++ exemplo1-criacao-iteracao.cu -o exemplo1-cpu Se der tudo certo a execu\u00e7\u00e3o do programa acima dever\u00e1 gerar um execut\u00e1vel exemplo1-cpu que roda e produz o seguinte resultado. Host vector: 0 0 12 0 35 Device vector 0 0 0 0 35 Nem tudo o que roda usando thrust/OpenMP roda em GPU. Por essa raz\u00e3o, esse recurso ser\u00e1 usado somente para testes e nunca para avalia\u00e7\u00e3o.","title":"Compila\u00e7\u00e3o para CPU"},{"location":"aulas/17-intro-gpu/#transferencia-de-dados","text":"Como visto na expositiva, a CPU e a GPU possuem espa\u00e7os de endere\u00e7amento completamente distintos. Ou seja, a CPU n\u00e3o consegue acessar os dados na mem\u00f3ria da GPU e vice-versa. A thrust disponibiliza somente um tipo de container ( vector ) e facilita este gerenciamento deixando expl\u00edcito se ele est\u00e1 alocado na CPU ( host ) ou na GPU ( device ). A c\u00f3pia CPU \\leftrightarrow \\leftrightarrow GPU \u00e9 feita implicitamente quando criamos um device_vector ou quando usamos a opera\u00e7\u00e3o de atribui\u00e7\u00e3o entre host_vector e device_vector . Veja o exemplo abaixo: thrust :: host_vector < double > vec_cpu ( 10 ); // alocado na CPU vec1 [ 0 ] = 20 ; vec2 [ 1 ] = 30 ; // aloca vetor na GPU e transfere dados CPU->GPU thrust :: device_vector < double > vec_gpu ( vec_cpu ); //processa vec_gpu vec_cpu = vec_gpu ; // copia dados GPU -> CPU A thrust usa iteradores em todas as suas fun\u00e7\u00f5es. Pense em um iterador como um ponteiro para os elementos do array. Por\u00e9m, um iterador \u00e9 mais esperto: ele guarda tamb\u00e9m o tipo do vetor original e suporta opera\u00e7\u00f5es ++ e * para qualquer tipo de dado iterado de maneira transparente. Vetores thrust aceitam os m\u00e9todos v.begin() para retornar um iterador para o come\u00e7o do vetor e v.end() para um iterador para o fim (depois do \u00faltimo elemento). Podemos tamb\u00e9m somar um valor n a um iterador. Isto \u00e9 equivalente a fazer n vezes a opera\u00e7\u00e3o ++ . Veja abaixo um exemplo de uso das fun\u00e7\u00f5es fill e sequence para preencher valores em um vetor de maneira eficiente. thrust :: device_vector < int > v ( 5 , 0 ); // vetor de 5 ints zerado // v = {0, 0, 0, 0, 0} thrust :: sequence ( v . begin (), v . end ()); // preenche com 0, 1, 2, .... // v = {0, 1, 2, 3, 4} thrust :: fill ( v . begin (), v . begin () + 2 , 13 ); // dois primeiros elementos = 13 // v = {13, 13, 2, 3, 4} Question Consulte o arquivo exemplo1-criacao-iteracao.cu para um exemplo completo de aloca\u00e7\u00e3o e transfer\u00eancia de dados e do uso de iteradores. Example O fluxo de trabalho \"normal\" de aplica\u00e7\u00f5es usando GPU \u00e9 receber os dados em um vetor na CPU e copi\u00e1-los para a GPU para fazer processamentos. Crie um programa que l\u00ea uma sequ\u00eancia de double s da entrada padr\u00e3o em um thrust::host_vector e os copia para um thrust::device_vector . Teste seu programa com o arquivo stocks-google.txt , que cont\u00e9m o pre\u00e7o das a\u00e7\u00f5es do Google nos \u00faltimos 10 anos. Example A cria\u00e7\u00e3o de um device_vector \u00e9 demorada. Me\u00e7a o tempo que a opera\u00e7\u00e3o de aloca\u00e7\u00e3o e c\u00f3pia demora e imprima na sa\u00edda de erros. (Use std::chrono ).","title":"Transfer\u00eancia de dados"},{"location":"aulas/17-intro-gpu/#operacoes-de-reducao","text":"Uma opera\u00e7\u00e3o gen\u00e9rica de redu\u00e7\u00e3o transforma um vetor em um \u00fanico valor. Exemplos cl\u00e1ssicos de opera\u00e7\u00f5es de redu\u00e7\u00e3o incluem soma , m\u00e9dia e m\u00ednimo/m\u00e1ximo de um vetor. A thrust disponibiliza este tipo de opera\u00e7\u00e3o otimizada em GPU usando a fun\u00e7\u00e3o thrust::reduce : val = thrust :: reduce ( iter_comeco , iter_fim , inicial , op ); // iter_comeco: iterador para o come\u00e7o dos dados // iter_fim: iterador para o fim dos dados // inicial: valor inicial // op: opera\u00e7\u00e3o a ser feita. Um exemplo de uso de redu\u00e7\u00e3o para computar o m\u00e1ximo pode ser visto aqui . A lista completa de fun\u00e7\u00f5es que podem ser usadas no lugar de op pode ser vista neste link . Example Continuando o exerc\u00edcio anterior, calcule as seguintes medidas. N\u00e3o se esque\u00e7a de passar o device_vector para a sua fun\u00e7\u00e3o reduce O pre\u00e7o m\u00e9dio das a\u00e7\u00f5es nos \u00faltimos 10 anos. O pre\u00e7o m\u00e9dio das a\u00e7\u00f5es no \u00faltimo ano (365 dias atr\u00e1s). O maior e o menor pre\u00e7o da sequ\u00eancia inteira e do \u00faltimo ano. Voc\u00ea pode consultar todos os tipos de redu\u00e7\u00f5es dispon\u00edveis no site da thrust .","title":"Opera\u00e7\u00f5es de redu\u00e7\u00e3o"},{"location":"aulas/17-intro-gpu/#transformacoes-ponto-a-ponto","text":"Al\u00e9m de opera\u00e7\u00f5es de redu\u00e7\u00e3o tamb\u00e9m podemos fazer opera\u00e7\u00f5es ponto a ponto em somente um vetor (como negar todas as componentes ou calcular os quadrados) quanto entre dois vetores (como somar dois vetores componente por componente ou comparar cada elemento com seu correspondente em outro vetor). A thrust d\u00e1 o nome de transformation para este tipo de opera\u00e7\u00e3o. // para opera\u00e7\u00f5es entre dois vetores iter1 e iter2. resultado armazenado em out thrust :: transform ( iter1_comeco , iter1_fim , iter2_comeco , out_comeco , op ); // iter1_comeco: iterador para o come\u00e7o de iter1 // iter1_fim: iterador para o fim de iter1 // iter2_comeco: iterador para o come\u00e7o de iter2 // out_comeco: iterador para o come\u00e7o de out // op: opera\u00e7\u00e3o a ser realizada. Um exemplo concreto pode ser visto abaixo. O c\u00f3digo completo est\u00e1 em exemplo2-transform.cu thrust :: device_vector < double > V1 ( 10 , 0 ); thrust :: device_vector < double > V2 ( 10 , 0 ); thrust :: device_vector < double > V3 ( 10 , 0 ); thrust :: device_vector < double > V4 ( 10 , 0 ); // inicializa V1 e V2 aqui //soma V1 e V2 thrust :: transform ( V1 . begin (), V1 . end (), V2 . begin (), V3 . begin (), thrust :: plus < double > ()); // multiplica V1 por 0.5 thrust :: transform ( V1 . begin (), V1 . end (), thrust :: constant_iterator < double > ( 0.5 ), V4 . begin (), thrust :: multiplies < double > ()); As opera\u00e7\u00f5es que foram usadas no reduce tamb\u00e9m podem ser usadas em um transform . N\u00e3o se esque\u00e7a de consultar a lista de opera\u00e7\u00f5es para fazer este exerc\u00edcio. Example Vamos agora trabalhar com o arquivo stocks2.csv . Ele cont\u00e9m a s\u00e9rie hist\u00f3rica de a\u00e7\u00f5es da Apple e da Microsoft. Seu objetivo \u00e9 calcular a diferen\u00e7a m\u00e9dia entre os pre\u00e7os das a\u00e7\u00f5es AAPL e MSFT. Dica : quebre o problema em duas partes. Primeiro calcule a diferen\u00e7a entre os pre\u00e7os e guarde isto em um vetor. Depois compute a m\u00e9dia deste vetor.","title":"Transforma\u00e7\u00f5es ponto a ponto"},{"location":"aulas/18-iteradores/","text":"18 - Iteradores em Thrust \u00b6 Na \u00faltima aula conseguimos rodar algumas fun\u00e7\u00f5es em GPU e medir o custo de transfer\u00eancia de dados. Chegamos a conclus\u00e3o de que, para valer a pena usar a GPU, ou precisamos tratar muitos dados ou precisamos fazer tratamentos pesados. Warning Nesta aula trabalharemos extensivamente com a API da thrust e pediremos para que voc\u00eas consultem a documenta\u00e7\u00e3o oficial da biblioteca. Tamb\u00e9m pode ser \u00fatil ver a se\u00e7\u00e3o de exemplos do reposit\u00f3rio. Iteradores \u00b6 Continuando a partir do \u00faltimo item da aula anterior, suponha que voc\u00ea deseja calcular a vari\u00e2ncia das diferen\u00e7as. Agora que j\u00e1 temos a m\u00e9dia, a f\u00f3rmula da vari\u00e2ncia \u00e9 dada por \\frac{1}{n}\\sum_{i=0}^n (x_i - \\mu)^2 \\frac{1}{n}\\sum_{i=0}^n (x_i - \\mu)^2 Example J\u00e1 sabemos tudo o que precisamos para fazer este c\u00e1lculo. Crie um vetor em que todas as componentes sejam iguais a m\u00e9dia (usando thrust::fill ) e compute a vari\u00e2ncia usando a f\u00f3rmula acima. Apesar do c\u00f3digo acima funcionar, ele tem um problema grave: \u00e9 preciso alocar um vetor inteiro somente para preench\u00ea-lo com valores iguais! Se estivermos trabalhando com muitos dados isto significa diminuir bastante a quantidade de dados que conseguimos tratar antes de acabar com a mem\u00f3ria da GPU. Podemos contornar isso usando iteradores, que s\u00e3o vetores gerados dinamicamente pela thrust a partir de um valor \u00fanico ou a partir de outros vetores. Example Pesquise a documenta\u00e7\u00e3o de thrust::constant_iterator e use-o para substituir a aloca\u00e7\u00e3o de mem\u00f3ria extra no exerc\u00edcio acima. Vamos agora nos preparar para a parte 2 criando um programa novamente em cima do arquivo stocks.txt . Example Leia o arquivo stocks.txt e crie um vetor contendo a diferen\u00e7a entre o dia atual e o anterior. Ou seja, dado que o vetor de sa\u00edda tenha nome ganho_diario e o de entrada stocks , temos que ganho_diario[i] = stocks[i+1] - stocks[i] Claramente ganho_diario.size() == stocks.size() - 1 . Leve isto em conta ao utilizar a opera\u00e7\u00e3o transform para criar o vetor ganho_diario . Opera\u00e7\u00f5es customiz\u00e1veis \u00b6 Com o vetor ganho_diario acima conseguimos saber se o valor da a\u00e7\u00e3o subiu ou caiu de um dia para o outro! Duas perguntas se seguem: quantas vezes o valor subiu? qual \u00e9 o aumento m\u00e9dio, considerando s\u00f3 as vezes em que o valor aumentou de fato? Podemos implementar essas l\u00f3gicas usando opera\u00e7\u00f5es customizadas. Apesar de ser poss\u00edvel escrever essas fun\u00e7\u00f5es do zero, a thrust j\u00e1 possui diversas fun\u00e7\u00f5es de redu\u00e7\u00f5es customiz\u00e1veis. Warning \u00c9 sempre importante consultar a documenta\u00e7\u00e3o para entender como essa fun\u00e7\u00e3o ser\u00e1 aplicada. Em alguns casos \u00e9 necess\u00e1rio que a fun\u00e7\u00e3o passada obede\u00e7a algumas restri\u00e7\u00f5es para que os resultados obtidos fa\u00e7am sentido. Question A thrust j\u00e1 tem suporte a opera\u00e7\u00f5es de redu\u00e7\u00e3o que s\u00e3o contagens. Veja sua documenta\u00e7\u00e3o oficial neste link . Qual fun\u00e7\u00e3o dessa p\u00e1gina voc\u00ea usaria para contar somente os elementos positivos de ganhos_diarios ? Warning A fun\u00e7\u00e3o count_if est\u00e1 atualmente com um erro em sua documenta\u00e7\u00e3o ( link da issue ). N\u00e3o se esque\u00e7a de colocar const no par\u00e2metro de operator() . Example Use a fun\u00e7\u00e3o acima para calcular quantas vezes o valor da a\u00e7\u00e3o subiu. Resposta 1309 Vamos agora para o segundo item: \"Calcular o aumento m\u00e9dio, considerando somente as vezes em que o valor aumentou de fato\". Uma estrat\u00e9gia poss\u00edvel \u00e9 zerar todos os elementos negativos do vetor e depois calcular sua soma. Question A documenta\u00e7\u00e3o sobre transforma\u00e7\u00f5es \u00e9 bastante vasta. Voc\u00ea consegue encontrar alguma fun\u00e7\u00e3o que possa substituir elementos de um vetor baseado em uma condi\u00e7\u00e3o booleana? Details replace_if Example Use a fun\u00e7\u00e3o acima para substituir todos os valores negativos por 0 em ganhos_diarios . Example Calcule agora e m\u00e9dia dos valores positivos do vetor. Voc\u00ea j\u00e1 tem todos os que s\u00e3o positivos no exerc\u00edcio acima e a quantidade de valores positivos. Resposta 5,25179","title":"18 - Iteradores em Thrust"},{"location":"aulas/18-iteradores/#18-iteradores-em-thrust","text":"Na \u00faltima aula conseguimos rodar algumas fun\u00e7\u00f5es em GPU e medir o custo de transfer\u00eancia de dados. Chegamos a conclus\u00e3o de que, para valer a pena usar a GPU, ou precisamos tratar muitos dados ou precisamos fazer tratamentos pesados. Warning Nesta aula trabalharemos extensivamente com a API da thrust e pediremos para que voc\u00eas consultem a documenta\u00e7\u00e3o oficial da biblioteca. Tamb\u00e9m pode ser \u00fatil ver a se\u00e7\u00e3o de exemplos do reposit\u00f3rio.","title":"18 - Iteradores em Thrust"},{"location":"aulas/18-iteradores/#iteradores","text":"Continuando a partir do \u00faltimo item da aula anterior, suponha que voc\u00ea deseja calcular a vari\u00e2ncia das diferen\u00e7as. Agora que j\u00e1 temos a m\u00e9dia, a f\u00f3rmula da vari\u00e2ncia \u00e9 dada por \\frac{1}{n}\\sum_{i=0}^n (x_i - \\mu)^2 \\frac{1}{n}\\sum_{i=0}^n (x_i - \\mu)^2 Example J\u00e1 sabemos tudo o que precisamos para fazer este c\u00e1lculo. Crie um vetor em que todas as componentes sejam iguais a m\u00e9dia (usando thrust::fill ) e compute a vari\u00e2ncia usando a f\u00f3rmula acima. Apesar do c\u00f3digo acima funcionar, ele tem um problema grave: \u00e9 preciso alocar um vetor inteiro somente para preench\u00ea-lo com valores iguais! Se estivermos trabalhando com muitos dados isto significa diminuir bastante a quantidade de dados que conseguimos tratar antes de acabar com a mem\u00f3ria da GPU. Podemos contornar isso usando iteradores, que s\u00e3o vetores gerados dinamicamente pela thrust a partir de um valor \u00fanico ou a partir de outros vetores. Example Pesquise a documenta\u00e7\u00e3o de thrust::constant_iterator e use-o para substituir a aloca\u00e7\u00e3o de mem\u00f3ria extra no exerc\u00edcio acima. Vamos agora nos preparar para a parte 2 criando um programa novamente em cima do arquivo stocks.txt . Example Leia o arquivo stocks.txt e crie um vetor contendo a diferen\u00e7a entre o dia atual e o anterior. Ou seja, dado que o vetor de sa\u00edda tenha nome ganho_diario e o de entrada stocks , temos que ganho_diario[i] = stocks[i+1] - stocks[i] Claramente ganho_diario.size() == stocks.size() - 1 . Leve isto em conta ao utilizar a opera\u00e7\u00e3o transform para criar o vetor ganho_diario .","title":"Iteradores"},{"location":"aulas/18-iteradores/#operacoes-customizaveis","text":"Com o vetor ganho_diario acima conseguimos saber se o valor da a\u00e7\u00e3o subiu ou caiu de um dia para o outro! Duas perguntas se seguem: quantas vezes o valor subiu? qual \u00e9 o aumento m\u00e9dio, considerando s\u00f3 as vezes em que o valor aumentou de fato? Podemos implementar essas l\u00f3gicas usando opera\u00e7\u00f5es customizadas. Apesar de ser poss\u00edvel escrever essas fun\u00e7\u00f5es do zero, a thrust j\u00e1 possui diversas fun\u00e7\u00f5es de redu\u00e7\u00f5es customiz\u00e1veis. Warning \u00c9 sempre importante consultar a documenta\u00e7\u00e3o para entender como essa fun\u00e7\u00e3o ser\u00e1 aplicada. Em alguns casos \u00e9 necess\u00e1rio que a fun\u00e7\u00e3o passada obede\u00e7a algumas restri\u00e7\u00f5es para que os resultados obtidos fa\u00e7am sentido. Question A thrust j\u00e1 tem suporte a opera\u00e7\u00f5es de redu\u00e7\u00e3o que s\u00e3o contagens. Veja sua documenta\u00e7\u00e3o oficial neste link . Qual fun\u00e7\u00e3o dessa p\u00e1gina voc\u00ea usaria para contar somente os elementos positivos de ganhos_diarios ? Warning A fun\u00e7\u00e3o count_if est\u00e1 atualmente com um erro em sua documenta\u00e7\u00e3o ( link da issue ). N\u00e3o se esque\u00e7a de colocar const no par\u00e2metro de operator() . Example Use a fun\u00e7\u00e3o acima para calcular quantas vezes o valor da a\u00e7\u00e3o subiu. Resposta 1309 Vamos agora para o segundo item: \"Calcular o aumento m\u00e9dio, considerando somente as vezes em que o valor aumentou de fato\". Uma estrat\u00e9gia poss\u00edvel \u00e9 zerar todos os elementos negativos do vetor e depois calcular sua soma. Question A documenta\u00e7\u00e3o sobre transforma\u00e7\u00f5es \u00e9 bastante vasta. Voc\u00ea consegue encontrar alguma fun\u00e7\u00e3o que possa substituir elementos de um vetor baseado em uma condi\u00e7\u00e3o booleana? Details replace_if Example Use a fun\u00e7\u00e3o acima para substituir todos os valores negativos por 0 em ganhos_diarios . Example Calcule agora e m\u00e9dia dos valores positivos do vetor. Voc\u00ea j\u00e1 tem todos os que s\u00e3o positivos no exerc\u00edcio acima e a quantidade de valores positivos. Resposta 5,25179","title":"Opera\u00e7\u00f5es customiz\u00e1veis"},{"location":"aulas/19-transformacoes/","text":"19 - Opera\u00e7\u00f5es customizadas \u00b6 Na \u00faltima aula programamos fun\u00e7\u00f5es simples que rodam em GPU e as plugamos em count_if e replace_if . Vamos agora generalizar este conhecimento para transform e criar fun\u00e7\u00f5es mais complexas. Opera\u00e7\u00f5es customizadas em transform \u00b6 Para criar nossas pr\u00f3prias opera\u00e7\u00f5es usamos a seguinte sintaxe: struct custom_transform { // essas marca\u00e7\u00f5es indicam que o c\u00f3digo deve ser compilado para CPU (host) // e GPU (device) // IMPORTANTE: somente c\u00f3digo com a marca\u00e7\u00e3o __device__ \u00e9 compilado para GPU __host__ __device__ double operator ()( const double & x , const double & y ) { // isto pode ser usado com um transform que usa dois vetores // e coloca o resultado em um terceiro. // x \u00e9 um elemento do primeiro vetor // y \u00e9 o elemento correspondente do segundo vetor // o valor retornado \u00e9 colocado no vetor de resultados // para fazer opera\u00e7\u00f5es un\u00e1rias basta receber somente um argumento. } }; A opera\u00e7\u00e3o acima seria aceita em um transform como o abaixo: thrust :: device_vector < double > A , B , C ; thrust :: transform ( A . begin (), A . end (), B . begin (), C . begin (), custom_transform ()); Note que os tipos dos vetores devem bater com os tipos declarados no struct . Por vezes precisamos receber par\u00e2metros para a opera\u00e7\u00e3o customizada funcionar. Um truque comum \u00e9 adicionar atributos no struct usado como opera\u00e7\u00e3o: struct T { int attr ; T ( int a ) : attr ( a ) {}; // TODO: opera\u00e7\u00e3o customizada aqui }; O valor attr estar\u00e1 dispon\u00edvel para uso dentro da opera\u00e7\u00e3o customizada. A linha T(int a): attr(a) {} declara o construtor do struct T . Ela faz com que o atributo attr seja inicializado com o valor do par\u00e2metro a . Se houver mais de uma atribui\u00e7\u00e3o par\u00e2metro - atributo \u00e9 s\u00f3 usar , para separar as inicializa\u00e7\u00f5es. Warning Em GPU n\u00e3o possuimos acesso \u00e0s APIs padr\u00e3o de C++, ent\u00e3o s\u00f3 podemos passar tipos simples de C++. Ou seja, nada de std::vector , new , std::cout ou malloc . Vamos agora usar esta nova sintaxe para escrever c\u00f3digo mais sucinto (e complexo) em thrust . Question Agora que podemos usar opera\u00e7\u00f5es customizadas para c\u00e1lculos complexos, qual parte da vari\u00e2ncia voc\u00ea poderia computar de uma vez? Ou seja, o que voc\u00ea colocaria dentro de operator() ? Details Podemos fazer a conta (x_i - \\mu)^2 / N (x_i - \\mu)^2 / N inteiramente dentro do operator() . Example Fa\u00e7a uma nova implementa\u00e7\u00e3o da vari\u00e2ncia, dessa vez usando uma opera\u00e7\u00e3o customizada e com a chamada transform . Dica : passe a m\u00e9dia do vetor como par\u00e2metro para seu struct . Voc\u00ea ainda precisar\u00e1 computar a m\u00e9dia com um transform_reduce e isso \u00e9 inevit\u00e1vel. Tip Chamadas a GPU tem um custo fixo. Ao usar a opera\u00e7\u00e3o customizada evitamos incorrer esse custo v\u00e1rias vezes. Tamb\u00e9m podemos economizar mem\u00f3ria ao deixar de usar vetores auxiliares. Estruturas 2D - matrizes e imagens \u00b6 Assim como na CPU, podemos representar imagens como um vetor \"deitado\". O acesso ao elemento (i, j) \u00e9 feito como abaixo. img [ i * width + j ] = 10 ; Logo, podemos guardar matrizes na GPU apesar de s\u00f3 temos vetores 1D: basta sempre fazer a conta acima para descobrir o elemento 1D a partir das coordenadas (x,y) . Question Como descobrir as coordenadas (x,y) a partir do \u00edndice 1D? Resposta Sendo k o \u00edndice 1D: y = k / largura x = k % largura Limiar \u00b6 Vamos come\u00e7ar com um processamento de imagens bem simples: o limiar. Se o ponto atual for maior que 127 , coloque na sa\u00edda 255 (branco) caso contr\u00e1rio, coloque na sa\u00edda 0 (preto) Vamos usar o arquivo imagem.hpp dispon\u00edvel na pasta desta aula. Question Abra o arquivo e explore as fun\u00e7\u00f5es exportadas. Como voc\u00ea faria para abrir uma imagem? Details Podemos usar a fun\u00e7\u00e3o Imagem.read , passando para ela uma string com o nome da imagem a ser carregada. Question Como acessamos o pixel y=10, x=20 de uma imagem com largura 300 ? Details img->pixels[10 + 20 * 300] . Question Quais opera\u00e7\u00f5es da thrust voc\u00ea usaria para fazer a opera\u00e7\u00e3o de limiar? Details Apenas um transform j\u00e1 resolve o problema. Basta passar os mesmos dados na imagem de entrada e na de sa\u00edda. Question Quais dados voc\u00ea precisaria copiar para a GPU? Quais dados seriam copiados de volta para a CPU ao finalizar? Resposta \u00c9 necess\u00e1rio copiar o vetor pixels e o tamanho total da imagem para a GPU, o que significa que teremos um vetor para a imagem de entrada. O vetor de sa\u00edda tamb\u00e9m deve ser criado na GPU, mas n\u00e3o precisa ser inicializado. Ap\u00f3s o c\u00e1lculo ele dever\u00e1 ser copiado de volta para a CPU. Question Quantos vetores usaremos na nossa opera\u00e7\u00e3o transform ? Details Um para entrada e outro para sa\u00edda. Question Sabendo que precisaremos copiar dados do vetor pixels e que nossa transforma\u00e7\u00e3o ir\u00e1 receber elementos desse vetor, qual seria a assinatura da fun\u00e7\u00e3o operator() usada no struct ? Details unsigned char operator() (const unsigned char &p) Podemos copiar dados de ponteiros \"crus\" para a GPU com uma sintaxe parecida com os nossos host_vector : int * dados ; // possui N elementos thrust :: device_vector < int > dados_gpu ( dados , dados + N ); Question Vimos que podemos fazer c\u00f3pias de um array \"puro\" em C++ ao criar um thrust::device_vector . Para copiar os dados de volta para a CPU podemos usar a fun\u00e7\u00e3o thrust::copy . Consulte sua documenta\u00e7\u00e3o e escreva abaixo como voc\u00ea a usaria para fazer a c\u00f3pia de um thrust::device_vector<double> a para um vetor double *a_cpu . Voc\u00ea pode supor que o a_cpu tem o mesmo tamanho que a . Resposta Existem v\u00e1rias possibilidades, mas a mais f\u00e1cil seria thrust::copy(a.begin(), a.end(), a_cpu) . Example Use uma transforma\u00e7\u00e3o customizada para implementar o filtro do limiar. Use os arquivos examinados na pergunta anterior. Filtro de m\u00e9dia M\u00e9dia \u00b6 A opera\u00e7\u00e3o acima encaixa bem na thrust pois \u00e9 ponto a ponto: cada processamento s\u00f3 leva em conta o valor do ponto atual. A maioria dos filtros, por\u00e9m, usa informa\u00e7\u00f5es da vizinhan\u00e7a de um ponto. Um exemplo \u00e9 o filtro de m\u00e9dia mostrado abaixo. Dada uma imagem de entrada I I , a imagem de sa\u00edda O O \u00e9 dada pela seguinte express\u00e3o. O[i, j] = \\frac{I[i, j] + I[i-1, j] + I[i+1, j] + I[i, j-1] + I[i,j+1]}{5} O[i, j] = \\frac{I[i, j] + I[i-1, j] + I[i+1, j] + I[i, j-1] + I[i,j+1]}{5} Ambas as imagens tem o mesmo tamanho. Se o pixel acessado estiver fora da \u00e1rea v\u00e1lida da imagem ele deve ser considerado 0. Apesar da thrust nos permitir acessar os dados de cada itera\u00e7\u00e3o, o acesso a elementos arbitr\u00e1rios do vetor n\u00e3o \u00e9 diretamente suportado. Vamos contornar essa limita\u00e7\u00e3o com uma estrat\u00e9gia alternativa: acessar o vetor diretamente e usar a thrust para fornecer ao nossa transforma\u00e7\u00e3o customizada o \u00edndice a ser usado. Vejamos abaixo um exemplo (arquivo raw_access.cu ): struct raw_access { double * ptr ; raw_access ( double * ptr ) : ptr ( ptr ) {}; __device__ __host__ double operator ()( const int & i ) { return ptr [ i ] + 1 ; } }; ... thrust :: counting_iterator < int > iter ( 0 ); raw_access ra ( thrust :: raw_pointer_cast ( vec . data ())); thrust :: transform ( iter , iter + vec . size (), vec . begin (), ra ); ... No c\u00f3digo acima nossa opera\u00e7\u00e3o customizada recebe o vetor como par\u00e2metro de cria\u00e7\u00e3o do struct . O valor passado pelo transform agora \u00e9 o \u00edndice a ser preenchido no vetor de sa\u00edda . Para simplificar, em geral vamos entender que o vetor de entrada e o de sa\u00edda s\u00e3o do mesmo tamanho. Ou seja, conseguimos escrever c\u00f3digo em GPU trabalhando somente com ponteiros e \u00edndices. C\u00f3digo arbitrariamente complexo pode estar dentro do operator() , desde que seja retornado o valor a ser colocado no vetor de sa\u00edda na posi\u00e7\u00e3o i . Danger No Limiar o vetor de entrada e sa\u00edda eram o mesmo. N\u00e3o h\u00e1 problema pois a opera\u00e7\u00e3o s\u00f3 acessa o elemento i . Por\u00e9m, se acessasse outros n\u00e3o conseguimos garantir a ordem das opera\u00e7\u00f5es e os resultados seriam imprevis\u00edveis. Na d\u00favida, sempre envie os dados para um vetor de sa\u00edda diferente. Example Implemente um programa media_gpu que faz o processamento descrito acima usando thrust . Seu programa dever\u00e1 funcionar como abaixo.","title":"19 - Opera\u00e7\u00f5es customizadas"},{"location":"aulas/19-transformacoes/#19-operacoes-customizadas","text":"Na \u00faltima aula programamos fun\u00e7\u00f5es simples que rodam em GPU e as plugamos em count_if e replace_if . Vamos agora generalizar este conhecimento para transform e criar fun\u00e7\u00f5es mais complexas.","title":"19 - Opera\u00e7\u00f5es customizadas"},{"location":"aulas/19-transformacoes/#operacoes-customizadas-em-transform","text":"Para criar nossas pr\u00f3prias opera\u00e7\u00f5es usamos a seguinte sintaxe: struct custom_transform { // essas marca\u00e7\u00f5es indicam que o c\u00f3digo deve ser compilado para CPU (host) // e GPU (device) // IMPORTANTE: somente c\u00f3digo com a marca\u00e7\u00e3o __device__ \u00e9 compilado para GPU __host__ __device__ double operator ()( const double & x , const double & y ) { // isto pode ser usado com um transform que usa dois vetores // e coloca o resultado em um terceiro. // x \u00e9 um elemento do primeiro vetor // y \u00e9 o elemento correspondente do segundo vetor // o valor retornado \u00e9 colocado no vetor de resultados // para fazer opera\u00e7\u00f5es un\u00e1rias basta receber somente um argumento. } }; A opera\u00e7\u00e3o acima seria aceita em um transform como o abaixo: thrust :: device_vector < double > A , B , C ; thrust :: transform ( A . begin (), A . end (), B . begin (), C . begin (), custom_transform ()); Note que os tipos dos vetores devem bater com os tipos declarados no struct . Por vezes precisamos receber par\u00e2metros para a opera\u00e7\u00e3o customizada funcionar. Um truque comum \u00e9 adicionar atributos no struct usado como opera\u00e7\u00e3o: struct T { int attr ; T ( int a ) : attr ( a ) {}; // TODO: opera\u00e7\u00e3o customizada aqui }; O valor attr estar\u00e1 dispon\u00edvel para uso dentro da opera\u00e7\u00e3o customizada. A linha T(int a): attr(a) {} declara o construtor do struct T . Ela faz com que o atributo attr seja inicializado com o valor do par\u00e2metro a . Se houver mais de uma atribui\u00e7\u00e3o par\u00e2metro - atributo \u00e9 s\u00f3 usar , para separar as inicializa\u00e7\u00f5es. Warning Em GPU n\u00e3o possuimos acesso \u00e0s APIs padr\u00e3o de C++, ent\u00e3o s\u00f3 podemos passar tipos simples de C++. Ou seja, nada de std::vector , new , std::cout ou malloc . Vamos agora usar esta nova sintaxe para escrever c\u00f3digo mais sucinto (e complexo) em thrust . Question Agora que podemos usar opera\u00e7\u00f5es customizadas para c\u00e1lculos complexos, qual parte da vari\u00e2ncia voc\u00ea poderia computar de uma vez? Ou seja, o que voc\u00ea colocaria dentro de operator() ? Details Podemos fazer a conta (x_i - \\mu)^2 / N (x_i - \\mu)^2 / N inteiramente dentro do operator() . Example Fa\u00e7a uma nova implementa\u00e7\u00e3o da vari\u00e2ncia, dessa vez usando uma opera\u00e7\u00e3o customizada e com a chamada transform . Dica : passe a m\u00e9dia do vetor como par\u00e2metro para seu struct . Voc\u00ea ainda precisar\u00e1 computar a m\u00e9dia com um transform_reduce e isso \u00e9 inevit\u00e1vel. Tip Chamadas a GPU tem um custo fixo. Ao usar a opera\u00e7\u00e3o customizada evitamos incorrer esse custo v\u00e1rias vezes. Tamb\u00e9m podemos economizar mem\u00f3ria ao deixar de usar vetores auxiliares.","title":"Opera\u00e7\u00f5es customizadas em transform"},{"location":"aulas/19-transformacoes/#estruturas-2d-matrizes-e-imagens","text":"Assim como na CPU, podemos representar imagens como um vetor \"deitado\". O acesso ao elemento (i, j) \u00e9 feito como abaixo. img [ i * width + j ] = 10 ; Logo, podemos guardar matrizes na GPU apesar de s\u00f3 temos vetores 1D: basta sempre fazer a conta acima para descobrir o elemento 1D a partir das coordenadas (x,y) . Question Como descobrir as coordenadas (x,y) a partir do \u00edndice 1D? Resposta Sendo k o \u00edndice 1D: y = k / largura x = k % largura","title":"Estruturas 2D - matrizes e imagens"},{"location":"aulas/19-transformacoes/#limiar","text":"Vamos come\u00e7ar com um processamento de imagens bem simples: o limiar. Se o ponto atual for maior que 127 , coloque na sa\u00edda 255 (branco) caso contr\u00e1rio, coloque na sa\u00edda 0 (preto) Vamos usar o arquivo imagem.hpp dispon\u00edvel na pasta desta aula. Question Abra o arquivo e explore as fun\u00e7\u00f5es exportadas. Como voc\u00ea faria para abrir uma imagem? Details Podemos usar a fun\u00e7\u00e3o Imagem.read , passando para ela uma string com o nome da imagem a ser carregada. Question Como acessamos o pixel y=10, x=20 de uma imagem com largura 300 ? Details img->pixels[10 + 20 * 300] . Question Quais opera\u00e7\u00f5es da thrust voc\u00ea usaria para fazer a opera\u00e7\u00e3o de limiar? Details Apenas um transform j\u00e1 resolve o problema. Basta passar os mesmos dados na imagem de entrada e na de sa\u00edda. Question Quais dados voc\u00ea precisaria copiar para a GPU? Quais dados seriam copiados de volta para a CPU ao finalizar? Resposta \u00c9 necess\u00e1rio copiar o vetor pixels e o tamanho total da imagem para a GPU, o que significa que teremos um vetor para a imagem de entrada. O vetor de sa\u00edda tamb\u00e9m deve ser criado na GPU, mas n\u00e3o precisa ser inicializado. Ap\u00f3s o c\u00e1lculo ele dever\u00e1 ser copiado de volta para a CPU. Question Quantos vetores usaremos na nossa opera\u00e7\u00e3o transform ? Details Um para entrada e outro para sa\u00edda. Question Sabendo que precisaremos copiar dados do vetor pixels e que nossa transforma\u00e7\u00e3o ir\u00e1 receber elementos desse vetor, qual seria a assinatura da fun\u00e7\u00e3o operator() usada no struct ? Details unsigned char operator() (const unsigned char &p) Podemos copiar dados de ponteiros \"crus\" para a GPU com uma sintaxe parecida com os nossos host_vector : int * dados ; // possui N elementos thrust :: device_vector < int > dados_gpu ( dados , dados + N ); Question Vimos que podemos fazer c\u00f3pias de um array \"puro\" em C++ ao criar um thrust::device_vector . Para copiar os dados de volta para a CPU podemos usar a fun\u00e7\u00e3o thrust::copy . Consulte sua documenta\u00e7\u00e3o e escreva abaixo como voc\u00ea a usaria para fazer a c\u00f3pia de um thrust::device_vector<double> a para um vetor double *a_cpu . Voc\u00ea pode supor que o a_cpu tem o mesmo tamanho que a . Resposta Existem v\u00e1rias possibilidades, mas a mais f\u00e1cil seria thrust::copy(a.begin(), a.end(), a_cpu) . Example Use uma transforma\u00e7\u00e3o customizada para implementar o filtro do limiar. Use os arquivos examinados na pergunta anterior.","title":"Limiar"},{"location":"aulas/19-transformacoes/#filtro-de-media-media","text":"A opera\u00e7\u00e3o acima encaixa bem na thrust pois \u00e9 ponto a ponto: cada processamento s\u00f3 leva em conta o valor do ponto atual. A maioria dos filtros, por\u00e9m, usa informa\u00e7\u00f5es da vizinhan\u00e7a de um ponto. Um exemplo \u00e9 o filtro de m\u00e9dia mostrado abaixo. Dada uma imagem de entrada I I , a imagem de sa\u00edda O O \u00e9 dada pela seguinte express\u00e3o. O[i, j] = \\frac{I[i, j] + I[i-1, j] + I[i+1, j] + I[i, j-1] + I[i,j+1]}{5} O[i, j] = \\frac{I[i, j] + I[i-1, j] + I[i+1, j] + I[i, j-1] + I[i,j+1]}{5} Ambas as imagens tem o mesmo tamanho. Se o pixel acessado estiver fora da \u00e1rea v\u00e1lida da imagem ele deve ser considerado 0. Apesar da thrust nos permitir acessar os dados de cada itera\u00e7\u00e3o, o acesso a elementos arbitr\u00e1rios do vetor n\u00e3o \u00e9 diretamente suportado. Vamos contornar essa limita\u00e7\u00e3o com uma estrat\u00e9gia alternativa: acessar o vetor diretamente e usar a thrust para fornecer ao nossa transforma\u00e7\u00e3o customizada o \u00edndice a ser usado. Vejamos abaixo um exemplo (arquivo raw_access.cu ): struct raw_access { double * ptr ; raw_access ( double * ptr ) : ptr ( ptr ) {}; __device__ __host__ double operator ()( const int & i ) { return ptr [ i ] + 1 ; } }; ... thrust :: counting_iterator < int > iter ( 0 ); raw_access ra ( thrust :: raw_pointer_cast ( vec . data ())); thrust :: transform ( iter , iter + vec . size (), vec . begin (), ra ); ... No c\u00f3digo acima nossa opera\u00e7\u00e3o customizada recebe o vetor como par\u00e2metro de cria\u00e7\u00e3o do struct . O valor passado pelo transform agora \u00e9 o \u00edndice a ser preenchido no vetor de sa\u00edda . Para simplificar, em geral vamos entender que o vetor de entrada e o de sa\u00edda s\u00e3o do mesmo tamanho. Ou seja, conseguimos escrever c\u00f3digo em GPU trabalhando somente com ponteiros e \u00edndices. C\u00f3digo arbitrariamente complexo pode estar dentro do operator() , desde que seja retornado o valor a ser colocado no vetor de sa\u00edda na posi\u00e7\u00e3o i . Danger No Limiar o vetor de entrada e sa\u00edda eram o mesmo. N\u00e3o h\u00e1 problema pois a opera\u00e7\u00e3o s\u00f3 acessa o elemento i . Por\u00e9m, se acessasse outros n\u00e3o conseguimos garantir a ordem das opera\u00e7\u00f5es e os resultados seriam imprevis\u00edveis. Na d\u00favida, sempre envie os dados para um vetor de sa\u00edda diferente. Example Implemente um programa media_gpu que faz o processamento descrito acima usando thrust . Seu programa dever\u00e1 funcionar como abaixo.","title":"Filtro de m\u00e9dia M\u00e9dia"},{"location":"guias-tecnicos/container-remoto/","text":"Tutorial Acesso \u00e0 maquina Monstr\u00e3o via VsCode \u00b6 Voc\u00ea deve ter acesso a sua maquina virtual no monstr\u00e3o e o VsCode instalado. Este Tutorial ir\u00e1 seguir as seguintes etapas. Etapas : Instalar extens\u00e3o no VsCode; Fazer acesso ssh; Instalar o Jupyter notebook; Rodar o notebook na pasta alvo. Instalar extens\u00e3o SSH Remote no VScode \u00b6 Dentro do aplicativo do VsCode Ctrl+Shift+X Buscar e instalar os pacotes do Remote-SSH Acesso SSH \u00b6 Clicar no icone a esquerda Remote Explorer Adicionar um novo SSH TARGET Na linha de comando digitar ssh user@<seu IP do monstr\u00e3o> Clicar Enter para ignorar o acesso via par de chaves O VsCode ir\u00e1 conectar na sua M\u00e1quina virtual e pedir a senha Digite a senha de acesso do seu usu\u00e1rio Como instalar e iniciar o Jupyter Notebook com Python no Ubuntu 20.04 \u00b6 Instala\u00e7\u00f5es iniciais : sudo apt update sudo apt upgrade -y sudo apt install build-essential sudo snap install jupyter clonar via git, o reposit\u00f3rio da disciplina Acessar a pasta com o projeto e rodar o comando: jupyter notebook Neste momento o Jupyter ir\u00e1 iniciar o servidor na m\u00e1quina virtual e o VsCode ir\u00e1 mostrar uma mensagem perguntando se deseja abrir via Browser. Aceitar Copiar o token gerado no terminal e colar na aba aberta no Browser. PRONTO. \u00b6 Outra dica \u00b6 Se quiser fazer via Tunel SSH, pode rodar o comando abaixo no seu terminal e acessar o Browser na porta 8888 ssh -L 8888:localhost:8888 user@< digite aqui ip da sua maquina virtual no monstr\u00e3o > * Acesse o localhost:8888 no seu Browser.","title":"Tutorial Acesso \u00e0 maquina Monstr\u00e3o via VsCode"},{"location":"guias-tecnicos/container-remoto/#tutorial-acesso-a-maquina-monstrao-via-vscode","text":"Voc\u00ea deve ter acesso a sua maquina virtual no monstr\u00e3o e o VsCode instalado. Este Tutorial ir\u00e1 seguir as seguintes etapas. Etapas : Instalar extens\u00e3o no VsCode; Fazer acesso ssh; Instalar o Jupyter notebook; Rodar o notebook na pasta alvo.","title":"Tutorial Acesso \u00e0 maquina Monstr\u00e3o via VsCode"},{"location":"guias-tecnicos/container-remoto/#instalar-extensao-ssh-remote-no-vscode","text":"Dentro do aplicativo do VsCode Ctrl+Shift+X Buscar e instalar os pacotes do Remote-SSH","title":"Instalar extens\u00e3o SSH Remote no VScode"},{"location":"guias-tecnicos/container-remoto/#acesso-ssh","text":"Clicar no icone a esquerda Remote Explorer Adicionar um novo SSH TARGET Na linha de comando digitar ssh user@<seu IP do monstr\u00e3o> Clicar Enter para ignorar o acesso via par de chaves O VsCode ir\u00e1 conectar na sua M\u00e1quina virtual e pedir a senha Digite a senha de acesso do seu usu\u00e1rio","title":"Acesso SSH"},{"location":"guias-tecnicos/container-remoto/#como-instalar-e-iniciar-o-jupyter-notebook-com-python-no-ubuntu-2004","text":"Instala\u00e7\u00f5es iniciais : sudo apt update sudo apt upgrade -y sudo apt install build-essential sudo snap install jupyter clonar via git, o reposit\u00f3rio da disciplina Acessar a pasta com o projeto e rodar o comando: jupyter notebook Neste momento o Jupyter ir\u00e1 iniciar o servidor na m\u00e1quina virtual e o VsCode ir\u00e1 mostrar uma mensagem perguntando se deseja abrir via Browser. Aceitar Copiar o token gerado no terminal e colar na aba aberta no Browser.","title":"Como instalar e iniciar o Jupyter Notebook com Python no Ubuntu 20.04"},{"location":"guias-tecnicos/container-remoto/#pronto","text":"","title":"PRONTO."},{"location":"guias-tecnicos/container-remoto/#outra-dica","text":"Se quiser fazer via Tunel SSH, pode rodar o comando abaixo no seu terminal e acessar o Browser na porta 8888 ssh -L 8888:localhost:8888 user@< digite aqui ip da sua maquina virtual no monstr\u00e3o > * Acesse o localhost:8888 no seu Browser.","title":"Outra dica"},{"location":"projetos/","text":"Maximin Share \u00b6 Dados M objetos com valor V[i], i=1..M e N pessoas, desejamos dividir estes objetos de maneira mais igualit\u00e1ria poss\u00edvel. Como n\u00e3o \u00e9 poss\u00edvel \"quebrar\" objetos, naturalmente alguns ficar\u00e3o com objetos de maior valor que os outros. Nosso objetivo neste projeto \u00e9 definir qual seria o menor valor que uma pessoa deveria aceitar nesta parti\u00e7\u00e3o . Para fazer isso vamos usar o seguinte procedimento: uma pessoa ser\u00e1 respons\u00e1vel por fazer a parti\u00e7\u00e3o dos objetos em N partes. Por\u00e9m, ela dever\u00e1 permitir que todas as outras N-1 pessoas escolham primeiro qual parte elas desejam . Ou seja, a pessoa que fez a parti\u00e7\u00e3o naturalmente ficar\u00e1 com a parte de menor valor. Portanto nosso objetivo ser\u00e1 maximizar o valor da parte de menor valor. Chamaremos este valor de MMS e a atribui\u00e7\u00e3o que o gera de parte 1-de-n . Vejamos um exemplo: separaremos 6 objetos para 3 pessoas. Os valores dos objetos s\u00e3o {20, 11, 9, 13, 14, 37} . Uma poss\u00edvel parti\u00e7\u00e3o seria {37} {20, 11} {14, 13, 9} Com esta parti\u00e7\u00e3o, o menor valor seria o do segundo grupo (31). Note que v\u00e1rias divis\u00f5es s\u00e3o poss\u00edveis: {37} {20, 14} {13, 11, 9} Nesta outra parti\u00e7\u00e3o o menor valor \u00e9 o do terceiro grupo (33). Portanto, entre essas duas divis\u00f5es a segunda \u00e9 melhor, j\u00e1 que a pessoa que dividiu ganharia um valor maior. Usaremos este problema na disciplina por uma raz\u00e3o bem simples: encontrar o MMS \u00e9 uma tarefa NP-dif\u00edcil . Ou seja, o melhor que podemos fazer neste caso para garantir a melhor solu\u00e7\u00e3o \u00e9, no pior caso, testar todas as aloca\u00e7\u00f5es poss\u00edveis. Claramente isso \u00e9 lento, ent\u00e3o \u00e9 uma bom exemplo de aplica\u00e7\u00e3o de SuperComputa\u00e7\u00e3o! Entrada e sa\u00edda \u00b6 As entradas e sa\u00eddas das implementa\u00e7\u00f5es ser\u00e3o padronizadas como abaixo. Entrada : N M v1 ...vN Sa\u00edda : MMS objetos da pessoa 1 ... objetos da pessoa M Nos esquemas acima, N = n\u00famero de objetos M = n\u00famero de pessoas vi = valor do objeto i MMS = valor do grupo menos valioso objetos da pessoa i = lista dos \u00edndices dos objetos que est\u00e3o com a pessoa i. Veja os exemplos de entrada e sa\u00edda na pasta entradas do reposit\u00f3rio do projeto. T\u00e9cnicas estudadas e corre\u00e7\u00e3o autom\u00e1tica \u00b6 Para cada t\u00e9cnica estudada em aula implementaremos vers\u00f5es b\u00e1sicas e avan\u00e7adas. Tamb\u00e9m ser\u00e1 necess\u00e1rio implementar vers\u00f5es paralelas em CPU e GPU. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada t\u00e9cnica implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica (23/03) Busca local (09/04) Busca exaustiva (16/04) Relat\u00f3rio preliminar (30/04) Paralelismo MultiCore (21/05) Cada parte de implementa\u00e7\u00e3o ser\u00e1 conferida usando um script de corre\u00e7\u00e3o checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas do projeto, juntamente com instru\u00e7\u00f5es de uso. Registre seu usu\u00e1rio do github at\u00e9 15/03 para ser convidado para seu reposit\u00f3rio de entregas. Instru\u00e7\u00f5es de corre\u00e7\u00e3o \u00b6 O corretor autom\u00e1tico depende do pacote grading-tools , que dever\u00e1 ser instalado como abaixo. $> python3.8 -m pip install --user git+https://github.com/igordsm/grading-tools Python 3.8 no Ubuntu Se seu python3 \u00e9 uma vers\u00e3o inferior ao 3.8, voc\u00ea pode instal\u00e1-lo com os pacotes abaixo: python3.8 python3.8-dev A partir da\u00ed poder\u00e1 seguir normalmente as instru\u00e7\u00f5es desta p\u00e1gina. Com isso configurado, \u00e9 s\u00f3 compilar seu programa e rodar python3.8 corretor.py executavel . Para baixar os novos exerc\u00edcios \u00e9 s\u00f3 rodar git pull . Os exerc\u00edcios ser\u00e3o entregues criando um commit com sua resposta e dando git push . Warning Fique atento a atualiza\u00e7\u00f5es no seu reposit\u00f3rio de projeto. Atualiza\u00e7\u00f5es no corretor ser\u00e3o feitas ao longo do semestre, assim como ser\u00e3o disponibilizados novos arquivos de entrada/sa\u00edda para cada parte a ser implementada. Avalia\u00e7\u00e3o \u00b6 O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega. Conceito D \u00b6 Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C \u00b6 Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C+ \u00b6 Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio. Conceitos avan\u00e7ados \u00b6 A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Maximin Share"},{"location":"projetos/#maximin-share","text":"Dados M objetos com valor V[i], i=1..M e N pessoas, desejamos dividir estes objetos de maneira mais igualit\u00e1ria poss\u00edvel. Como n\u00e3o \u00e9 poss\u00edvel \"quebrar\" objetos, naturalmente alguns ficar\u00e3o com objetos de maior valor que os outros. Nosso objetivo neste projeto \u00e9 definir qual seria o menor valor que uma pessoa deveria aceitar nesta parti\u00e7\u00e3o . Para fazer isso vamos usar o seguinte procedimento: uma pessoa ser\u00e1 respons\u00e1vel por fazer a parti\u00e7\u00e3o dos objetos em N partes. Por\u00e9m, ela dever\u00e1 permitir que todas as outras N-1 pessoas escolham primeiro qual parte elas desejam . Ou seja, a pessoa que fez a parti\u00e7\u00e3o naturalmente ficar\u00e1 com a parte de menor valor. Portanto nosso objetivo ser\u00e1 maximizar o valor da parte de menor valor. Chamaremos este valor de MMS e a atribui\u00e7\u00e3o que o gera de parte 1-de-n . Vejamos um exemplo: separaremos 6 objetos para 3 pessoas. Os valores dos objetos s\u00e3o {20, 11, 9, 13, 14, 37} . Uma poss\u00edvel parti\u00e7\u00e3o seria {37} {20, 11} {14, 13, 9} Com esta parti\u00e7\u00e3o, o menor valor seria o do segundo grupo (31). Note que v\u00e1rias divis\u00f5es s\u00e3o poss\u00edveis: {37} {20, 14} {13, 11, 9} Nesta outra parti\u00e7\u00e3o o menor valor \u00e9 o do terceiro grupo (33). Portanto, entre essas duas divis\u00f5es a segunda \u00e9 melhor, j\u00e1 que a pessoa que dividiu ganharia um valor maior. Usaremos este problema na disciplina por uma raz\u00e3o bem simples: encontrar o MMS \u00e9 uma tarefa NP-dif\u00edcil . Ou seja, o melhor que podemos fazer neste caso para garantir a melhor solu\u00e7\u00e3o \u00e9, no pior caso, testar todas as aloca\u00e7\u00f5es poss\u00edveis. Claramente isso \u00e9 lento, ent\u00e3o \u00e9 uma bom exemplo de aplica\u00e7\u00e3o de SuperComputa\u00e7\u00e3o!","title":"Maximin Share"},{"location":"projetos/#entrada-e-saida","text":"As entradas e sa\u00eddas das implementa\u00e7\u00f5es ser\u00e3o padronizadas como abaixo. Entrada : N M v1 ...vN Sa\u00edda : MMS objetos da pessoa 1 ... objetos da pessoa M Nos esquemas acima, N = n\u00famero de objetos M = n\u00famero de pessoas vi = valor do objeto i MMS = valor do grupo menos valioso objetos da pessoa i = lista dos \u00edndices dos objetos que est\u00e3o com a pessoa i. Veja os exemplos de entrada e sa\u00edda na pasta entradas do reposit\u00f3rio do projeto.","title":"Entrada e sa\u00edda"},{"location":"projetos/#tecnicas-estudadas-e-correcao-automatica","text":"Para cada t\u00e9cnica estudada em aula implementaremos vers\u00f5es b\u00e1sicas e avan\u00e7adas. Tamb\u00e9m ser\u00e1 necess\u00e1rio implementar vers\u00f5es paralelas em CPU e GPU. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada t\u00e9cnica implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica (23/03) Busca local (09/04) Busca exaustiva (16/04) Relat\u00f3rio preliminar (30/04) Paralelismo MultiCore (21/05) Cada parte de implementa\u00e7\u00e3o ser\u00e1 conferida usando um script de corre\u00e7\u00e3o checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas do projeto, juntamente com instru\u00e7\u00f5es de uso. Registre seu usu\u00e1rio do github at\u00e9 15/03 para ser convidado para seu reposit\u00f3rio de entregas.","title":"T\u00e9cnicas estudadas e corre\u00e7\u00e3o autom\u00e1tica"},{"location":"projetos/#instrucoes-de-correcao","text":"O corretor autom\u00e1tico depende do pacote grading-tools , que dever\u00e1 ser instalado como abaixo. $> python3.8 -m pip install --user git+https://github.com/igordsm/grading-tools Python 3.8 no Ubuntu Se seu python3 \u00e9 uma vers\u00e3o inferior ao 3.8, voc\u00ea pode instal\u00e1-lo com os pacotes abaixo: python3.8 python3.8-dev A partir da\u00ed poder\u00e1 seguir normalmente as instru\u00e7\u00f5es desta p\u00e1gina. Com isso configurado, \u00e9 s\u00f3 compilar seu programa e rodar python3.8 corretor.py executavel . Para baixar os novos exerc\u00edcios \u00e9 s\u00f3 rodar git pull . Os exerc\u00edcios ser\u00e3o entregues criando um commit com sua resposta e dando git push . Warning Fique atento a atualiza\u00e7\u00f5es no seu reposit\u00f3rio de projeto. Atualiza\u00e7\u00f5es no corretor ser\u00e3o feitas ao longo do semestre, assim como ser\u00e3o disponibilizados novos arquivos de entrada/sa\u00edda para cada parte a ser implementada.","title":"Instru\u00e7\u00f5es de corre\u00e7\u00e3o"},{"location":"projetos/#avaliacao","text":"O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega.","title":"Avalia\u00e7\u00e3o"},{"location":"projetos/#conceito-d","text":"Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito D"},{"location":"projetos/#conceito-c","text":"Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito C"},{"location":"projetos/#conceito-c_1","text":"Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio.","title":"Conceito C+"},{"location":"projetos/#conceitos-avancados","text":"A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Conceitos avan\u00e7ados"},{"location":"projetos/busca-exaustiva/","text":"Solu\u00e7\u00e3o Busca exaustiva \u00b6 Vamos agora encontrar a melhor solu\u00e7\u00e3o poss\u00edvel usando uma estrat\u00e9gia de busca global. Nosso trabalho ser\u00e1 parecido com o da aula 08-busca-global , mas agora aplicaremos essa estrat\u00e9gia recursiva para o problema de interesse no projeto. Para ajudar em sua implementa\u00e7\u00e3o, responda as perguntas abaixo. Question Quais s\u00e3o as escolhas que podem ser feitas? Quais as possibilidades de cada escolha? Question Quantas solu\u00e7\u00f5es v\u00e1lidas existem? Vari\u00e1veis de ambiente \u00b6 Caso DEBUG=1 seu programa dever\u00e1 mostra, na sa\u00edda de erros, o n\u00famero de solu\u00e7\u00f5es v\u00e1lidas analisadas pelo seu programa. Tome cuidado com o tamanho da vari\u00e1vel usada para guardar este n\u00famero. Valida\u00e7\u00e3o de resultados \u00b6 A pasta busca-global do reposit\u00f3rio de entregas cont\u00e9m arquivos de exemplo in*.txt/out*.txt/err*.txt com as entradas e sa\u00eddas esperadas para esta parte do projeto. Use-os para validar seu programa junto com corretor.py .","title":"Solu\u00e7\u00e3o Busca exaustiva"},{"location":"projetos/busca-exaustiva/#solucao-busca-exaustiva","text":"Vamos agora encontrar a melhor solu\u00e7\u00e3o poss\u00edvel usando uma estrat\u00e9gia de busca global. Nosso trabalho ser\u00e1 parecido com o da aula 08-busca-global , mas agora aplicaremos essa estrat\u00e9gia recursiva para o problema de interesse no projeto. Para ajudar em sua implementa\u00e7\u00e3o, responda as perguntas abaixo. Question Quais s\u00e3o as escolhas que podem ser feitas? Quais as possibilidades de cada escolha? Question Quantas solu\u00e7\u00f5es v\u00e1lidas existem?","title":"Solu\u00e7\u00e3o Busca exaustiva"},{"location":"projetos/busca-exaustiva/#variaveis-de-ambiente","text":"Caso DEBUG=1 seu programa dever\u00e1 mostra, na sa\u00edda de erros, o n\u00famero de solu\u00e7\u00f5es v\u00e1lidas analisadas pelo seu programa. Tome cuidado com o tamanho da vari\u00e1vel usada para guardar este n\u00famero.","title":"Vari\u00e1veis de ambiente"},{"location":"projetos/busca-exaustiva/#validacao-de-resultados","text":"A pasta busca-global do reposit\u00f3rio de entregas cont\u00e9m arquivos de exemplo in*.txt/out*.txt/err*.txt com as entradas e sa\u00eddas esperadas para esta parte do projeto. Use-os para validar seu programa junto com corretor.py .","title":"Valida\u00e7\u00e3o de resultados"},{"location":"projetos/busca-local/","text":"Solu\u00e7\u00e3o Busca local \u00b6 Vamos agora implementar uma estrat\u00e9gia de Busca local como fizemos na aula 07 . Nossa estrat\u00e9gia de busca local ser\u00e1 composta por tr\u00eas passos: Passo 1 Cada objeto \u00e9 atribu\u00eddo para uma pessoa aleat\u00f3ria. Passo 2 Selecione a pessoa P com o menor valor. Passe por todos os outros objetos e verifique se esse objeto poderia ser doado para P . Um objeto pode ser doado se o valor total do doador tirando o objeto doado \u00e9 maior que o valor total da pessoa P . Se for poss\u00edvel, fa\u00e7a a doa\u00e7\u00e3o, calcule o novo MMS . Passo 3 Repita o Passo 2 at\u00e9 que n\u00e3o seja mais poss\u00edvel. Para auxiliar o entendimento desta busca local, responda as seguintes perguntas. Question O Passo 2 da nossa estrat\u00e9gia nunca diminui o MMS . Por que? Question Conseguimos saber de antem\u00e3o quantas vezes repetiremos Passo 2 ? Vari\u00e1veis de ambiente \u00b6 Nosso programa ser\u00e1 controlado por tr\u00eas vari\u00e1veis de ambiente: SEED controla o seed usado em nosso gerador de n\u00fameros aleat\u00f3rios. Se n\u00e3o for passado, assuma SEED = 0 ; ITER controla o n\u00famero de vezes que repetimos a estrat\u00e9gia delineada acima. Se n\u00e3o for passado, assuma ITER = 100000 ; DEBUG : mostra informa\u00e7\u00f5es auxiliares para ajudar a corre\u00e7\u00e3o autom\u00e1tica. Se n\u00e3o for passado, assuma DEBUG = 0 ; Ao rodar com DEBUG=1 seu programa dever\u00e1 mostrar na sa\u00edda de erros cerr uma linha para cada resultado final do processo de busca local. Ou seja, dever\u00e1 mostrar ITER linhas no formato abaixo: valor a1 ... aN valor cont\u00e9m o valor do MMS da solu\u00e7\u00e3o aI cont\u00e9m a pessoa que possui o objeto I Note que o formato dessa sa\u00edda \u00e9 diferente da sa\u00edda final do programa, por\u00e9m a informa\u00e7\u00e3o representada \u00e9 a mesma. Valida\u00e7\u00e3o de resultados \u00b6 A pasta heuristica do reposit\u00f3rio de entregas cont\u00e9m arquivos de exemplo in*.txt/out*.txt com as entradas e sa\u00eddas poss\u00edveis para esta parte do projeto. Use-os para validar seu programa junto com corretor.py . Warning Esta valida\u00e7\u00e3o n\u00e3o espera resultados id\u00eanticos aos das sa\u00eddas de exemplo. A valida\u00e7\u00e3o testar\u00e1 se seu programa tem as seguintes propriedades: a solu\u00e7\u00e3o final \u00e9 \u00f3tima local. Ou seja, n\u00e3o \u00e9 poss\u00edvel repetir o Passo 2 e conseguir uma solu\u00e7\u00e3o melhor a solu\u00e7\u00e3o final \u00e9 valida. as solu\u00e7\u00f5es de cada busca local mostradas quando DEBUG=1 tamb\u00e9m s\u00e3o \u00f3timos locais a solu\u00e7\u00e3o final \u00e9 a melhor entre todas as solu\u00e7\u00f5es calculadas solu\u00e7\u00f5es diferentes s\u00e3o geradas quando valores de SEED diferentes s\u00e3o passados s\u00e3o mostradas ITER linhas na sa\u00edda de erros e cada linha corresponde a uma solu\u00e7\u00e3o v\u00e1lida","title":"Solu\u00e7\u00e3o Busca local"},{"location":"projetos/busca-local/#solucao-busca-local","text":"Vamos agora implementar uma estrat\u00e9gia de Busca local como fizemos na aula 07 . Nossa estrat\u00e9gia de busca local ser\u00e1 composta por tr\u00eas passos: Passo 1 Cada objeto \u00e9 atribu\u00eddo para uma pessoa aleat\u00f3ria. Passo 2 Selecione a pessoa P com o menor valor. Passe por todos os outros objetos e verifique se esse objeto poderia ser doado para P . Um objeto pode ser doado se o valor total do doador tirando o objeto doado \u00e9 maior que o valor total da pessoa P . Se for poss\u00edvel, fa\u00e7a a doa\u00e7\u00e3o, calcule o novo MMS . Passo 3 Repita o Passo 2 at\u00e9 que n\u00e3o seja mais poss\u00edvel. Para auxiliar o entendimento desta busca local, responda as seguintes perguntas. Question O Passo 2 da nossa estrat\u00e9gia nunca diminui o MMS . Por que? Question Conseguimos saber de antem\u00e3o quantas vezes repetiremos Passo 2 ?","title":"Solu\u00e7\u00e3o Busca local"},{"location":"projetos/busca-local/#variaveis-de-ambiente","text":"Nosso programa ser\u00e1 controlado por tr\u00eas vari\u00e1veis de ambiente: SEED controla o seed usado em nosso gerador de n\u00fameros aleat\u00f3rios. Se n\u00e3o for passado, assuma SEED = 0 ; ITER controla o n\u00famero de vezes que repetimos a estrat\u00e9gia delineada acima. Se n\u00e3o for passado, assuma ITER = 100000 ; DEBUG : mostra informa\u00e7\u00f5es auxiliares para ajudar a corre\u00e7\u00e3o autom\u00e1tica. Se n\u00e3o for passado, assuma DEBUG = 0 ; Ao rodar com DEBUG=1 seu programa dever\u00e1 mostrar na sa\u00edda de erros cerr uma linha para cada resultado final do processo de busca local. Ou seja, dever\u00e1 mostrar ITER linhas no formato abaixo: valor a1 ... aN valor cont\u00e9m o valor do MMS da solu\u00e7\u00e3o aI cont\u00e9m a pessoa que possui o objeto I Note que o formato dessa sa\u00edda \u00e9 diferente da sa\u00edda final do programa, por\u00e9m a informa\u00e7\u00e3o representada \u00e9 a mesma.","title":"Vari\u00e1veis de ambiente"},{"location":"projetos/busca-local/#validacao-de-resultados","text":"A pasta heuristica do reposit\u00f3rio de entregas cont\u00e9m arquivos de exemplo in*.txt/out*.txt com as entradas e sa\u00eddas poss\u00edveis para esta parte do projeto. Use-os para validar seu programa junto com corretor.py . Warning Esta valida\u00e7\u00e3o n\u00e3o espera resultados id\u00eanticos aos das sa\u00eddas de exemplo. A valida\u00e7\u00e3o testar\u00e1 se seu programa tem as seguintes propriedades: a solu\u00e7\u00e3o final \u00e9 \u00f3tima local. Ou seja, n\u00e3o \u00e9 poss\u00edvel repetir o Passo 2 e conseguir uma solu\u00e7\u00e3o melhor a solu\u00e7\u00e3o final \u00e9 valida. as solu\u00e7\u00f5es de cada busca local mostradas quando DEBUG=1 tamb\u00e9m s\u00e3o \u00f3timos locais a solu\u00e7\u00e3o final \u00e9 a melhor entre todas as solu\u00e7\u00f5es calculadas solu\u00e7\u00f5es diferentes s\u00e3o geradas quando valores de SEED diferentes s\u00e3o passados s\u00e3o mostradas ITER linhas na sa\u00edda de erros e cada linha corresponde a uma solu\u00e7\u00e3o v\u00e1lida","title":"Valida\u00e7\u00e3o de resultados"},{"location":"projetos/heuristico/","text":"Solu\u00e7\u00e3o heur\u00edstica \u00b6 Um bom princ\u00edpio para dividir os objetos entre pessoas \u00e9 Dividir o n\u00famero de objetos por pessoa de maneira mais igualit\u00e1ria poss\u00edvel Ou seja, nossa heur\u00edstica ir\u00e1 mirar em divis\u00f5es em que cada pessoa recebe ao menos N/M objetos (arredondado para baixo). Nossa estrat\u00e9gia para esta divis\u00e3o ser\u00e1 Ordenar objetos por valor e atribu\u00ed-los sequencialmente para cada pessoa. Ao chegar ao fim da lista de pessoas continuamos o processo com a primeira pessoa. Esta heur\u00edstica funciona muito bem quando os pesos s\u00e3o id\u00eanticos (ou muito parecidos), de maneira que a primeira \"leva\" de atribui\u00e7\u00f5es n\u00e3o crie grande diferen\u00e7a de valor entre a primeira e a \u00faltima pessoa. Valida\u00e7\u00e3o de resultados \u00b6 A pasta heuristica do reposit\u00f3rio de entregas cont\u00e9m arquivos de exemplo in*.txt/out*.txt com as entradas e sa\u00eddas esperadas para esta parte do projeto. Use-os para validar seu programa junto com corretor.py .","title":"Solu\u00e7\u00e3o heur\u00edstica"},{"location":"projetos/heuristico/#solucao-heuristica","text":"Um bom princ\u00edpio para dividir os objetos entre pessoas \u00e9 Dividir o n\u00famero de objetos por pessoa de maneira mais igualit\u00e1ria poss\u00edvel Ou seja, nossa heur\u00edstica ir\u00e1 mirar em divis\u00f5es em que cada pessoa recebe ao menos N/M objetos (arredondado para baixo). Nossa estrat\u00e9gia para esta divis\u00e3o ser\u00e1 Ordenar objetos por valor e atribu\u00ed-los sequencialmente para cada pessoa. Ao chegar ao fim da lista de pessoas continuamos o processo com a primeira pessoa. Esta heur\u00edstica funciona muito bem quando os pesos s\u00e3o id\u00eanticos (ou muito parecidos), de maneira que a primeira \"leva\" de atribui\u00e7\u00f5es n\u00e3o crie grande diferen\u00e7a de valor entre a primeira e a \u00faltima pessoa.","title":"Solu\u00e7\u00e3o heur\u00edstica"},{"location":"projetos/heuristico/#validacao-de-resultados","text":"A pasta heuristica do reposit\u00f3rio de entregas cont\u00e9m arquivos de exemplo in*.txt/out*.txt com as entradas e sa\u00eddas esperadas para esta parte do projeto. Use-os para validar seu programa junto com corretor.py .","title":"Valida\u00e7\u00e3o de resultados"},{"location":"projetos/paralelismo-multicore/","text":"Paralelismo multi-core \u00b6 Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela do algoritmo de busca local. Compila\u00e7\u00e3o do programa \u00b6 Seu programa multi-core dever\u00e1 ser gerado a partir do mesmo c\u00f3digo fonte do sequencial. Ou seja, compilar com -fopenmp habilita o programa paralelo. Compilar sem essa flag obtem os resultados sequenciais. Caso seu programa use as chamadas do OpenMP para c\u00f3digos auxiliares (aloca\u00e7\u00e3o de mem\u00f3ria, etc), voc\u00ea pode checar se seu programa foi compilado com esta flag seguindo o exemplo abaixo. #ifdef _OPENMP // c\u00f3digo espec\u00edfico para multi-core aqui #else // c\u00f3digo espec\u00edfico para sequencia aqui #endif Corre\u00e7\u00e3o autom\u00e1tica \u00b6 Se seu programa for compilado com -fopenmp ele dever\u00e1 rodar usando todas as CPUs pelo m\u00e1ximo de tempo poss\u00edvel. O corretor autom\u00e1tico checar\u00e1 as seguintes condi\u00e7\u00f5es: o consumo m\u00e9dio de CPU durante a execu\u00e7\u00e3o do programa \u00e9 maior que 75% para cada core. as mesmas checagens do algoritmo sequencial ser\u00e3o feitas. Ou seja, seu programa dever\u00e1 funcionar de maneira id\u00eantica ao algoritmo sequencial. Os resultados n\u00e3o precisam ser exatamente os mesmos, mas o programa dever\u00e1 gerar solu\u00e7\u00f5es com as mesmas propriedades. Execute o corretor com o argumento multi-core para rodar somente estes testes.","title":"Paralelismo multi-core"},{"location":"projetos/paralelismo-multicore/#paralelismo-multi-core","text":"Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela do algoritmo de busca local.","title":"Paralelismo multi-core"},{"location":"projetos/paralelismo-multicore/#compilacao-do-programa","text":"Seu programa multi-core dever\u00e1 ser gerado a partir do mesmo c\u00f3digo fonte do sequencial. Ou seja, compilar com -fopenmp habilita o programa paralelo. Compilar sem essa flag obtem os resultados sequenciais. Caso seu programa use as chamadas do OpenMP para c\u00f3digos auxiliares (aloca\u00e7\u00e3o de mem\u00f3ria, etc), voc\u00ea pode checar se seu programa foi compilado com esta flag seguindo o exemplo abaixo. #ifdef _OPENMP // c\u00f3digo espec\u00edfico para multi-core aqui #else // c\u00f3digo espec\u00edfico para sequencia aqui #endif","title":"Compila\u00e7\u00e3o do programa"},{"location":"projetos/paralelismo-multicore/#correcao-automatica","text":"Se seu programa for compilado com -fopenmp ele dever\u00e1 rodar usando todas as CPUs pelo m\u00e1ximo de tempo poss\u00edvel. O corretor autom\u00e1tico checar\u00e1 as seguintes condi\u00e7\u00f5es: o consumo m\u00e9dio de CPU durante a execu\u00e7\u00e3o do programa \u00e9 maior que 75% para cada core. as mesmas checagens do algoritmo sequencial ser\u00e3o feitas. Ou seja, seu programa dever\u00e1 funcionar de maneira id\u00eantica ao algoritmo sequencial. Os resultados n\u00e3o precisam ser exatamente os mesmos, mas o programa dever\u00e1 gerar solu\u00e7\u00f5es com as mesmas propriedades. Execute o corretor com o argumento multi-core para rodar somente estes testes.","title":"Corre\u00e7\u00e3o autom\u00e1tica"},{"location":"projetos/relatorio-1/","text":"Relat\u00f3rio - v1 \u00b6 Nesta primeira parte do relat\u00f3rio iremos analisar as implementa\u00e7\u00f5es j\u00e1 criadas com rela\u00e7\u00e3o a sua velocidade e qualidade da solu\u00e7\u00e3o. Os objetivos deste relat\u00f3rio s\u00e3o criar entradas de tamanho adequado para os prop\u00f3sitos dos testes estudar o efeito do n\u00famero de pessoas e do n\u00famero de objetos nas medidas de interesse (tempo e qualidade da solu\u00e7\u00e3o) comparar o desempenho dos algoritmos implementados at\u00e9 o momento em rela\u00e7\u00e3o a essas duas medidas. Seu trabalhou dever\u00e1 ser entregue como um arquivo PDF chamado relatorio-intermediario.pdf na pasta relatorios do reposit\u00f3rio. Ele poder\u00e1 ser gerado a partir de um Jupyter notebook (como feito na aula 01 ) ou usando a ferramenta pweave ( recomendado ). A rubrica de avalia\u00e7\u00e3o est\u00e1 dispon\u00edvel abaixo e tamb\u00e9m neste link .","title":"Relat\u00f3rio - v1"},{"location":"projetos/relatorio-1/#relatorio-v1","text":"Nesta primeira parte do relat\u00f3rio iremos analisar as implementa\u00e7\u00f5es j\u00e1 criadas com rela\u00e7\u00e3o a sua velocidade e qualidade da solu\u00e7\u00e3o. Os objetivos deste relat\u00f3rio s\u00e3o criar entradas de tamanho adequado para os prop\u00f3sitos dos testes estudar o efeito do n\u00famero de pessoas e do n\u00famero de objetos nas medidas de interesse (tempo e qualidade da solu\u00e7\u00e3o) comparar o desempenho dos algoritmos implementados at\u00e9 o momento em rela\u00e7\u00e3o a essas duas medidas. Seu trabalhou dever\u00e1 ser entregue como um arquivo PDF chamado relatorio-intermediario.pdf na pasta relatorios do reposit\u00f3rio. Ele poder\u00e1 ser gerado a partir de um Jupyter notebook (como feito na aula 01 ) ou usando a ferramenta pweave ( recomendado ). A rubrica de avalia\u00e7\u00e3o est\u00e1 dispon\u00edvel abaixo e tamb\u00e9m neste link .","title":"Relat\u00f3rio - v1"}]}