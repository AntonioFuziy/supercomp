{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SuperComputa\u00e7\u00e3o \u00b6 Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2020/2. Professor : Igor Montagner Objetivos \u00b6 Ao final da disciplina o aluno ser\u00e1 capaz de: Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; O projeto da disciplina ser\u00e1 composto por m\u00faltiplas partes. Mais detalhes na p\u00e1gina de projetos A m\u00e9dia final \u00e9 dada por 55% Projeto 45% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Projeto >= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados) Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Home"},{"location":"#supercomputacao","text":"Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2020/2. Professor : Igor Montagner","title":"SuperComputa\u00e7\u00e3o"},{"location":"#objetivos","text":"Ao final da disciplina o aluno ser\u00e1 capaz de:","title":"Objetivos"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; O projeto da disciplina ser\u00e1 composto por m\u00faltiplas partes. Mais detalhes na p\u00e1gina de projetos A m\u00e9dia final \u00e9 dada por 55% Projeto 45% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Projeto >= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados) Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Avalia\u00e7\u00e3o"},{"location":"enunciado/","text":"Prova Intermedi\u00e1ria - SuperComputa\u00e7\u00e3o \u00b6 Esta prova tem duas partes independentes. Ambas as partes cont\u00e9m exerc\u00edcios que somam ao menos 5 pontos, por\u00e9m \u00e9 esperado que um aluno proficiente nos objetivos da disciplina seja capaz de atacar ao menos a maioria dos itens de ambas as partes. Isto significa que o tempo levado para resolver a prova \u00e9 tamb\u00e9m um indicador da profici\u00eancia de voc\u00eas. Em quest\u00f5es em que \u00e9 pedida a implementa\u00e7\u00e3o de um algoritmo espec\u00edfico, ser\u00e3o disponibilizados pares entrada/sa\u00edda para confer\u00eancia de resultados. Se os testes n\u00e3o passarem sua nota ser\u00e1 no m\u00e1ximo 50% da quest\u00e3o. Respostas descritivas nestas quest\u00f5es ser\u00e3o levadas em conta para at\u00e9 30% da nota da quest\u00e3o mesmo se nenhum teste passar. Por exemplo, voc\u00ea poder\u00e1 explicar o que est\u00e1 errado atualmente no seu c\u00f3digo e como isso poderia ser consertado. Problema 1 - O carteiro viajante \u00b6 No nosso projeto trabalhamos com o Caixeiro viajante, que \u00e9 um vendedor de porta em porta que deve passar por v\u00e1rias cidades e gostaria de faz\u00ea-lo no menor tempo poss\u00edvel. Nesta prova trabalharemos com um problema similar: o Carteiro viajante. Trabalhamos para os correios e precisamos determinar a rota que um carteiro far\u00e1 dado um conjunto de correspond\u00eancias que ele precisa entregar.O carteiro dever\u00e1 sair da ag\u00eancia (posicionada na coordenada 0,0 ), visitar todas as resid\u00eancias e voltar para a ag\u00eancia no fim do dia. Nosso trajeto proposto dever\u00e1 seguir as seguintes regras de seguran\u00e7a do trabalho: um carteiro n\u00e3o pode caminhar mais que 2km sem pausa para descanso. o tempo total de caminhada n\u00e3o pode superar 4 horas A melhor rota \u00e9 aquela que respeita ambas regras e tem o menor comprimento. Question 1,5: Responda as tr\u00eas perguntas abaixo Quais s\u00e3o as escolhas a serem feitas? Qual \u00e9 a fun\u00e7\u00e3o objetivo? \u00c9 um problema de maximiza\u00e7\u00e3o ou minimiza\u00e7\u00e3o? Quais s\u00e3o as restri\u00e7\u00f5es? Example 2,0 Implemente um programa que devolve a primeira rota encontrada para o problema acima que respeite a regra 1: um carteiro n\u00e3o pode caminhar mais que 2km sem pausa para descanso Voc\u00ea n\u00e3o precisa, necessariamente, implementar uma solu\u00e7\u00e3o eficiente. A solu\u00e7\u00e3o retornada n\u00e3o precisa ser a melhor poss\u00edvel. Seu programa dever\u00e1 aceitar entradas como a abaixo. As coordenadas est\u00e3o em quil\u00f4metros . N x1 y1 x2 y2 ... xN yN Se existir resposta, seu programa dever\u00e1 retorn\u00e1-la no formato abaixo ( r1 .. rn s\u00e3o os \u00edndices das resid\u00eancias visitadas). tamanho r1 ... rn Se n\u00e3o existir resposta, seu programa dever\u00e1 exibir a mensagem \"SEM RESPOSTA\". Example 1,0 Crie uma nova vers\u00e3o do seu programa acima que tamb\u00e9m respeita a regra 2: o tempo total de caminhada n\u00e3o pode superar 4 horas Al\u00e9m disso, seu programa agora dever\u00e1 retornar a melhor rota poss\u00edvel. Os formatos de entrada/sa\u00edda continuam os mesmos. Para calcular o tempo que um trajeto leva voc\u00ea pode supor que nosso carteiro anda a uma velocidade de 4km/h . Example 1,0: Implemente um algoritmo de Branch and bound para a vers\u00e3o acima da sua solu\u00e7\u00e3o. Explique ele em um coment\u00e1rio no seu c\u00f3digo. Teste com in7.txt . Problema 2 - Aloca\u00e7\u00e3o de M\u00e1quinas Virtuais \u00b6 Minimizar a quantidade de m\u00e1quinas f\u00edsicas necess\u00e1rias para aloca\u00e7\u00e3o de VMs \u00e9 uma parte importante da opera\u00e7\u00e3o de empresas de Cloud. No nosso exemplo simplificado vamos levar em contar somente a quantidade de mem\u00f3ria RAM que cada VM requer. Todas as nossas m\u00e1quinas f\u00edsicas tem a mesma quantidade R de RAM. Cada uma das N VM*s a serem alocadas requer quantidade mi, i=1...N de RAM. Nosso objetivo \u00e9 alocar cada *VM em uma m\u00e1quina f\u00edsica de modo a minimizar a quantidade de m\u00e1quinas f\u00edsicas usadas. Note que, no limite, precisaremos de N m\u00e1quinas f\u00edsicas de qualquer maneira. A sa\u00edda de nosso programa ser\u00e1 o n\u00famero de m\u00e1quinas f\u00edsicas necess\u00e1rias e qual VM dever\u00e1 ir em qual m\u00e1quina f\u00edsica. Entrada \u00b6 R N m1 ... mN R \u00e9 a quantidade de RAM que cada m\u00e1quina f\u00edsica possui N \u00e9 o n\u00famero de VMs a serem alocadas m1 ... mN \u00e9 a quantidade de RAM de cada VM Sa\u00edda \u00b6 K VMs na m\u00e1quina 0 VMS na m\u00e1quina 1 .... VMs na m\u00e1quina K Exerc\u00edcios \u00b6 Question 1,0: Responda as tr\u00eas perguntas abaixo Quais s\u00e3o as escolhas a serem feitas? Qual \u00e9 a fun\u00e7\u00e3o objetivo? \u00c9 um problema de maximiza\u00e7\u00e3o ou minimiza\u00e7\u00e3o? Quais s\u00e3o as restri\u00e7\u00f5es? Example 2,5: Uma maneira simples de conseguir uma solu\u00e7\u00e3o \u00e9 a seguinte ideia: Para cada VM, aloque-a na m\u00e1quina de menor \u00edndice poss\u00edvel. \u00b6 Seu programa dever\u00e1 respeitar os formatos de entrada e sa\u00edda Question 1,0: O programa acima percorre os objetos na ordem de entrada. Existe alguma ordem em particular que \u00e9 boa? Explique o por que essa heur\u00edstica daria bons resultados. Example 1,0: Implemente uma vers\u00e3o aleatorizada do seu programa acima e mostre que ele alcan\u00e7a resultados melhores se rodado 100 vezes.","title":"Prova Intermedi\u00e1ria - SuperComputa\u00e7\u00e3o"},{"location":"enunciado/#prova-intermediaria-supercomputacao","text":"Esta prova tem duas partes independentes. Ambas as partes cont\u00e9m exerc\u00edcios que somam ao menos 5 pontos, por\u00e9m \u00e9 esperado que um aluno proficiente nos objetivos da disciplina seja capaz de atacar ao menos a maioria dos itens de ambas as partes. Isto significa que o tempo levado para resolver a prova \u00e9 tamb\u00e9m um indicador da profici\u00eancia de voc\u00eas. Em quest\u00f5es em que \u00e9 pedida a implementa\u00e7\u00e3o de um algoritmo espec\u00edfico, ser\u00e3o disponibilizados pares entrada/sa\u00edda para confer\u00eancia de resultados. Se os testes n\u00e3o passarem sua nota ser\u00e1 no m\u00e1ximo 50% da quest\u00e3o. Respostas descritivas nestas quest\u00f5es ser\u00e3o levadas em conta para at\u00e9 30% da nota da quest\u00e3o mesmo se nenhum teste passar. Por exemplo, voc\u00ea poder\u00e1 explicar o que est\u00e1 errado atualmente no seu c\u00f3digo e como isso poderia ser consertado.","title":"Prova Intermedi\u00e1ria - SuperComputa\u00e7\u00e3o"},{"location":"enunciado/#problema-1-o-carteiro-viajante","text":"No nosso projeto trabalhamos com o Caixeiro viajante, que \u00e9 um vendedor de porta em porta que deve passar por v\u00e1rias cidades e gostaria de faz\u00ea-lo no menor tempo poss\u00edvel. Nesta prova trabalharemos com um problema similar: o Carteiro viajante. Trabalhamos para os correios e precisamos determinar a rota que um carteiro far\u00e1 dado um conjunto de correspond\u00eancias que ele precisa entregar.O carteiro dever\u00e1 sair da ag\u00eancia (posicionada na coordenada 0,0 ), visitar todas as resid\u00eancias e voltar para a ag\u00eancia no fim do dia. Nosso trajeto proposto dever\u00e1 seguir as seguintes regras de seguran\u00e7a do trabalho: um carteiro n\u00e3o pode caminhar mais que 2km sem pausa para descanso. o tempo total de caminhada n\u00e3o pode superar 4 horas A melhor rota \u00e9 aquela que respeita ambas regras e tem o menor comprimento. Question 1,5: Responda as tr\u00eas perguntas abaixo Quais s\u00e3o as escolhas a serem feitas? Qual \u00e9 a fun\u00e7\u00e3o objetivo? \u00c9 um problema de maximiza\u00e7\u00e3o ou minimiza\u00e7\u00e3o? Quais s\u00e3o as restri\u00e7\u00f5es? Example 2,0 Implemente um programa que devolve a primeira rota encontrada para o problema acima que respeite a regra 1: um carteiro n\u00e3o pode caminhar mais que 2km sem pausa para descanso Voc\u00ea n\u00e3o precisa, necessariamente, implementar uma solu\u00e7\u00e3o eficiente. A solu\u00e7\u00e3o retornada n\u00e3o precisa ser a melhor poss\u00edvel. Seu programa dever\u00e1 aceitar entradas como a abaixo. As coordenadas est\u00e3o em quil\u00f4metros . N x1 y1 x2 y2 ... xN yN Se existir resposta, seu programa dever\u00e1 retorn\u00e1-la no formato abaixo ( r1 .. rn s\u00e3o os \u00edndices das resid\u00eancias visitadas). tamanho r1 ... rn Se n\u00e3o existir resposta, seu programa dever\u00e1 exibir a mensagem \"SEM RESPOSTA\". Example 1,0 Crie uma nova vers\u00e3o do seu programa acima que tamb\u00e9m respeita a regra 2: o tempo total de caminhada n\u00e3o pode superar 4 horas Al\u00e9m disso, seu programa agora dever\u00e1 retornar a melhor rota poss\u00edvel. Os formatos de entrada/sa\u00edda continuam os mesmos. Para calcular o tempo que um trajeto leva voc\u00ea pode supor que nosso carteiro anda a uma velocidade de 4km/h . Example 1,0: Implemente um algoritmo de Branch and bound para a vers\u00e3o acima da sua solu\u00e7\u00e3o. Explique ele em um coment\u00e1rio no seu c\u00f3digo. Teste com in7.txt .","title":"Problema 1 - O carteiro viajante"},{"location":"enunciado/#problema-2-alocacao-de-maquinas-virtuais","text":"Minimizar a quantidade de m\u00e1quinas f\u00edsicas necess\u00e1rias para aloca\u00e7\u00e3o de VMs \u00e9 uma parte importante da opera\u00e7\u00e3o de empresas de Cloud. No nosso exemplo simplificado vamos levar em contar somente a quantidade de mem\u00f3ria RAM que cada VM requer. Todas as nossas m\u00e1quinas f\u00edsicas tem a mesma quantidade R de RAM. Cada uma das N VM*s a serem alocadas requer quantidade mi, i=1...N de RAM. Nosso objetivo \u00e9 alocar cada *VM em uma m\u00e1quina f\u00edsica de modo a minimizar a quantidade de m\u00e1quinas f\u00edsicas usadas. Note que, no limite, precisaremos de N m\u00e1quinas f\u00edsicas de qualquer maneira. A sa\u00edda de nosso programa ser\u00e1 o n\u00famero de m\u00e1quinas f\u00edsicas necess\u00e1rias e qual VM dever\u00e1 ir em qual m\u00e1quina f\u00edsica.","title":"Problema 2 - Aloca\u00e7\u00e3o de M\u00e1quinas Virtuais"},{"location":"enunciado/#entrada","text":"R N m1 ... mN R \u00e9 a quantidade de RAM que cada m\u00e1quina f\u00edsica possui N \u00e9 o n\u00famero de VMs a serem alocadas m1 ... mN \u00e9 a quantidade de RAM de cada VM","title":"Entrada"},{"location":"enunciado/#saida","text":"K VMs na m\u00e1quina 0 VMS na m\u00e1quina 1 .... VMs na m\u00e1quina K","title":"Sa\u00edda"},{"location":"enunciado/#exercicios","text":"Question 1,0: Responda as tr\u00eas perguntas abaixo Quais s\u00e3o as escolhas a serem feitas? Qual \u00e9 a fun\u00e7\u00e3o objetivo? \u00c9 um problema de maximiza\u00e7\u00e3o ou minimiza\u00e7\u00e3o? Quais s\u00e3o as restri\u00e7\u00f5es? Example 2,5: Uma maneira simples de conseguir uma solu\u00e7\u00e3o \u00e9 a seguinte ideia:","title":"Exerc\u00edcios"},{"location":"enunciado/#para-cada-vm-aloque-a-na-maquina-de-menor-indice-possivel","text":"Seu programa dever\u00e1 respeitar os formatos de entrada e sa\u00edda Question 1,0: O programa acima percorre os objetos na ordem de entrada. Existe alguma ordem em particular que \u00e9 boa? Explique o por que essa heur\u00edstica daria bons resultados. Example 1,0: Implemente uma vers\u00e3o aleatorizada do seu programa acima e mostre que ele alcan\u00e7a resultados melhores se rodado 100 vezes.","title":"Para cada VM, aloque-a na m\u00e1quina de menor \u00edndice poss\u00edvel."},{"location":"sobre/","text":"Burocracias \u00b6 Turma 1 (remoto) \u00b6 Hor\u00e1rios: TER - 09:45 SEX - 13:30 Atendimento SEX - 15:30 Alunos Arthur (F)Olga Raphael Iago Jorge Vitor Satyro Juan Garcia Guilherme Aliperti Gabriel Moura Matteo Isabella Victor Rachel Tarraf Bruno Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 25/08 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 28/08 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 01/09 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 04/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 08/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 11/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 15/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 18/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 22/09 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 25/09 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 29/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 02/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 06/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 09/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 16/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 20/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 23/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 27/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 30/10 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 03/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 06/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 10/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 13/11 Quiz para PF Quiz para PF 17/11 Apresenta\u00e7\u00e3o da competi\u00e7\u00e3o final de desempenho Aula est\u00fadio para projeto 20/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 24/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 27/11 Prova Final Prova Final 01/12 Prova Final Prova Final Turma 2 (presencial) \u00b6 Hor\u00e1rios: QUA - 13:30 SEX - 07:30 Atendimento SEX - 09:30 Alunos Alessandra Alexandre Giulia Felippe Teracini Guilherme Schoueri Gobetti Sabrina (Remoto?) Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 26/08 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 28/08 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 02/09 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 04/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 09/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 11/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 16/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 18/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 23/09 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 25/09 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 30/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 02/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 07/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 09/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 14/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 16/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 21/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 23/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 28/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 30/10 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 04/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 06/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 11/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 13/11 Quiz para PF Quiz para PF 18/11 Apresenta\u00e7\u00e3o da competi\u00e7\u00e3o final de desempenho Aula est\u00fadio para projeto 20/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 25/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 27/11 Prova Final Prova Final 02/12 Prova Final Prova Final Turma Mista (Presencial/Remoto) \u00b6 Hugo (TER 09:45, SEX 7:30)","title":"Burocracias"},{"location":"sobre/#burocracias","text":"","title":"Burocracias"},{"location":"sobre/#turma-1-remoto","text":"Hor\u00e1rios: TER - 09:45 SEX - 13:30 Atendimento SEX - 15:30 Alunos Arthur (F)Olga Raphael Iago Jorge Vitor Satyro Juan Garcia Guilherme Aliperti Gabriel Moura Matteo Isabella Victor Rachel Tarraf Bruno Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 25/08 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 28/08 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 01/09 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 04/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 08/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 11/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 15/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 18/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 22/09 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 25/09 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 29/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 02/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 06/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 09/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 16/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 20/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 23/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 27/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 30/10 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 03/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 06/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 10/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 13/11 Quiz para PF Quiz para PF 17/11 Apresenta\u00e7\u00e3o da competi\u00e7\u00e3o final de desempenho Aula est\u00fadio para projeto 20/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 24/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 27/11 Prova Final Prova Final 01/12 Prova Final Prova Final","title":"Turma 1 (remoto)"},{"location":"sobre/#turma-2-presencial","text":"Hor\u00e1rios: QUA - 13:30 SEX - 07:30 Atendimento SEX - 09:30 Alunos Alessandra Alexandre Giulia Felippe Teracini Guilherme Schoueri Gobetti Sabrina (Remoto?) Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 26/08 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 28/08 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 02/09 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 04/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 09/09 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 11/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 16/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 18/09 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 23/09 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 25/09 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 30/09 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 02/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 07/10 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 09/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 14/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 16/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 21/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 23/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 28/10 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 30/10 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 04/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 06/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 11/11 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 13/11 Quiz para PF Quiz para PF 18/11 Apresenta\u00e7\u00e3o da competi\u00e7\u00e3o final de desempenho Aula est\u00fadio para projeto 20/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 25/11 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 27/11 Prova Final Prova Final 02/12 Prova Final Prova Final","title":"Turma 2 (presencial)"},{"location":"sobre/#turma-mista-presencialremoto","text":"Hugo (TER 09:45, SEX 7:30)","title":"Turma Mista (Presencial/Remoto)"},{"location":"turmas/","text":"Divis\u00e3o de turmas \u00b6 A partir de 08/09 \u00b6 Turma 1 (remoto) \u00b6 Hor\u00e1rios: TER - 09:45 SEX - 13:30 Atendimento SEX - 15:30 Alunos \u00b6 Rachel Arthur (F)Olga Raphael Iago Jorge Vitor Satyro Juan Garcia Guilherme Aliperti Gabriel Moura Bruno Matteo Sabrina Gobetti Isabella Turma 2 (presencial) \u00b6 Hor\u00e1rios: QUA - 13:30 SEX - 07:30 Atendimento SEX - 09:30 Alunos \u00b6 Alessandra Tarraf Alexandre Giulia Felippe Teracini Guilherme Schoueri Turma Mista (Presencial/Remoto) \u00b6 Hugo (TER 09:45, SEX 7:30)","title":"Divis\u00e3o de turmas"},{"location":"turmas/#divisao-de-turmas","text":"","title":"Divis\u00e3o de turmas"},{"location":"turmas/#a-partir-de-0809","text":"","title":"A partir de 08/09"},{"location":"turmas/#turma-1-remoto","text":"Hor\u00e1rios: TER - 09:45 SEX - 13:30 Atendimento SEX - 15:30","title":"Turma 1 (remoto)"},{"location":"turmas/#alunos","text":"Rachel Arthur (F)Olga Raphael Iago Jorge Vitor Satyro Juan Garcia Guilherme Aliperti Gabriel Moura Bruno Matteo Sabrina Gobetti Isabella","title":"Alunos"},{"location":"turmas/#turma-2-presencial","text":"Hor\u00e1rios: QUA - 13:30 SEX - 07:30 Atendimento SEX - 09:30","title":"Turma 2 (presencial)"},{"location":"turmas/#alunos_1","text":"Alessandra Tarraf Alexandre Giulia Felippe Teracini Guilherme Schoueri","title":"Alunos"},{"location":"turmas/#turma-mista-presencialremoto","text":"Hugo (TER 09:45, SEX 7:30)","title":"Turma Mista (Presencial/Remoto)"},{"location":"aulas/01-introducao/","text":"01 - Aquecimento \u00b6 A disciplina utilizar\u00e1 a linguagem C++ para implementa\u00e7\u00e3o dos programas. Ela \u00e9 muito usada em implementa\u00e7\u00f5es de alto desempenho e possui recursos muito \u00fateis e que simplificam a programa\u00e7\u00e3o se comparada com C puro. Nas aulas 01 e 02 aprenderemos alguns desses recursos e os utilizaremos para implementa\u00e7\u00e3o de algoritmos simples. Gabaritos e respostas Este curso n\u00e3o fornece c\u00f3digo de resposta para os exerc\u00edcios de sala. Cada exerc\u00edcio \u00e9 acompanhado de um algoritmo em pseudo-c\u00f3digo e alguns pares de arquivos entrada/sa\u00edda. Isto j\u00e1 \u00e9 suficiente para que voc\u00eas verifiquem se sua solu\u00e7\u00e3o est\u00e1 correta. Boas pr\u00e1ticas de programa\u00e7\u00e3o ser\u00e3o demonstradas em exerc\u00edcios corrigidos pelo professor durante o semestre. Uma lista (n\u00e3o exaustiva) dessas pr\u00e1ticas estar\u00e1 dispon\u00edveis na p\u00e1gina Projeto . Compila\u00e7\u00e3o \u00b6 Programas em C++ s\u00e3o compilados com o comando g++ . Ele funciona igual ao gcc que voc\u00eas j\u00e1 usaram em Desafios e Sistemas Hardware-Software. $> g++ arquivo.cpp -o executavel Entrada e sa\u00edda em C++ \u00b6 Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream). A maior vantagem de usar cin e cout \u00e9 que n\u00e3o precisamos mais daquelas strings de formata\u00e7\u00e3o estranhas com %d , %s e afins. Podemos passar vari\u00e1veis diretamente para a sa\u00edda do terminal usando o operador << . Veja um exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << \"Sa\u00edda: \" << a << \";\" << b << \" \\n \" ; Example Crie um arquivo entrada-saida.cpp com uma fun\u00e7\u00e3o main que roda o c\u00f3digo acima. Compile e execute seu programa e verifique que ele mostra o valor correto no terminal. O mesmo vale para a entrada, mas desta vez \"tiramos\" os dados do objeto std::cin . O exemplo abaixo l\u00ea um inteiro e um double do terminal. int a ; double b ; std :: cin >> a >> b ; Example Modifique seu programa entrada-saida.cpp para ler \u00ea um n\u00famero inteiro n e mostrar sua divis\u00e3o fracion\u00e1ria por 2. Ou seja, antes de dividir converta n para double . E esse std:: ? Em C++ podemos ter v\u00e1rias fun\u00e7\u00f5es, vari\u00e1veis e objetos em geral com o mesmo nome. Para evitar que eles colidam e n\u00e3o se saiba a qual estamos nos referindo cada nome deve ser definido um namespace (literalmente espaco de nomes ). Podemos ter namespace s aninhados.Por exemplo, std::chrono cont\u00e9m as fun\u00e7\u00f5es relacionadas contagem de tempo durante a execu\u00e7\u00e3o de um programa. Todas as fun\u00e7\u00f5es, classes e globais na biblioteca padr\u00e3o est\u00e3o definidas no espa\u00e7o std . Se quisermos, podemos omitir escrever std:: toda vez digitando using namespace std . Isso pode ser feito tamb\u00e9m com namespaces aninhados. A implementa\u00e7\u00e3o de algoritmos definidos usando express\u00f5es matem\u00e1ticas \u00e9 uma habilidade importante neste curso. Example Escreva um programa que receba um inteiro n e calcule a seguinte s\u00e9rie. S = \\sum_{i=0}^n \\frac{1}{2^i} S = \\sum_{i=0}^n \\frac{1}{2^i} Mostre as primeiras 15 casas decimais de S . Veja a documenta\u00e7\u00e3o de std::setprecision aqui . Resposta Essa s\u00e9rie converge para o n\u00famero 2, mas sua resposta dever\u00e1 ser sempre menor que este n\u00famero. Logo, quanto maior n mais pr\u00f3xima sua resposta ser\u00e1. Seu programa dever\u00e1 implementar algo como o algoritmo abaixo. leia inteiro n s = 0.0 para i=0 at\u00e9 n s += 1 / (2 elevado a i) print(s)","title":"01 - Aquecimento"},{"location":"aulas/01-introducao/#01-aquecimento","text":"A disciplina utilizar\u00e1 a linguagem C++ para implementa\u00e7\u00e3o dos programas. Ela \u00e9 muito usada em implementa\u00e7\u00f5es de alto desempenho e possui recursos muito \u00fateis e que simplificam a programa\u00e7\u00e3o se comparada com C puro. Nas aulas 01 e 02 aprenderemos alguns desses recursos e os utilizaremos para implementa\u00e7\u00e3o de algoritmos simples. Gabaritos e respostas Este curso n\u00e3o fornece c\u00f3digo de resposta para os exerc\u00edcios de sala. Cada exerc\u00edcio \u00e9 acompanhado de um algoritmo em pseudo-c\u00f3digo e alguns pares de arquivos entrada/sa\u00edda. Isto j\u00e1 \u00e9 suficiente para que voc\u00eas verifiquem se sua solu\u00e7\u00e3o est\u00e1 correta. Boas pr\u00e1ticas de programa\u00e7\u00e3o ser\u00e3o demonstradas em exerc\u00edcios corrigidos pelo professor durante o semestre. Uma lista (n\u00e3o exaustiva) dessas pr\u00e1ticas estar\u00e1 dispon\u00edveis na p\u00e1gina Projeto .","title":"01 - Aquecimento"},{"location":"aulas/01-introducao/#compilacao","text":"Programas em C++ s\u00e3o compilados com o comando g++ . Ele funciona igual ao gcc que voc\u00eas j\u00e1 usaram em Desafios e Sistemas Hardware-Software. $> g++ arquivo.cpp -o executavel","title":"Compila\u00e7\u00e3o"},{"location":"aulas/01-introducao/#entrada-e-saida-em-c","text":"Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream). A maior vantagem de usar cin e cout \u00e9 que n\u00e3o precisamos mais daquelas strings de formata\u00e7\u00e3o estranhas com %d , %s e afins. Podemos passar vari\u00e1veis diretamente para a sa\u00edda do terminal usando o operador << . Veja um exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << \"Sa\u00edda: \" << a << \";\" << b << \" \\n \" ; Example Crie um arquivo entrada-saida.cpp com uma fun\u00e7\u00e3o main que roda o c\u00f3digo acima. Compile e execute seu programa e verifique que ele mostra o valor correto no terminal. O mesmo vale para a entrada, mas desta vez \"tiramos\" os dados do objeto std::cin . O exemplo abaixo l\u00ea um inteiro e um double do terminal. int a ; double b ; std :: cin >> a >> b ; Example Modifique seu programa entrada-saida.cpp para ler \u00ea um n\u00famero inteiro n e mostrar sua divis\u00e3o fracion\u00e1ria por 2. Ou seja, antes de dividir converta n para double . E esse std:: ? Em C++ podemos ter v\u00e1rias fun\u00e7\u00f5es, vari\u00e1veis e objetos em geral com o mesmo nome. Para evitar que eles colidam e n\u00e3o se saiba a qual estamos nos referindo cada nome deve ser definido um namespace (literalmente espaco de nomes ). Podemos ter namespace s aninhados.Por exemplo, std::chrono cont\u00e9m as fun\u00e7\u00f5es relacionadas contagem de tempo durante a execu\u00e7\u00e3o de um programa. Todas as fun\u00e7\u00f5es, classes e globais na biblioteca padr\u00e3o est\u00e3o definidas no espa\u00e7o std . Se quisermos, podemos omitir escrever std:: toda vez digitando using namespace std . Isso pode ser feito tamb\u00e9m com namespaces aninhados. A implementa\u00e7\u00e3o de algoritmos definidos usando express\u00f5es matem\u00e1ticas \u00e9 uma habilidade importante neste curso. Example Escreva um programa que receba um inteiro n e calcule a seguinte s\u00e9rie. S = \\sum_{i=0}^n \\frac{1}{2^i} S = \\sum_{i=0}^n \\frac{1}{2^i} Mostre as primeiras 15 casas decimais de S . Veja a documenta\u00e7\u00e3o de std::setprecision aqui . Resposta Essa s\u00e9rie converge para o n\u00famero 2, mas sua resposta dever\u00e1 ser sempre menor que este n\u00famero. Logo, quanto maior n mais pr\u00f3xima sua resposta ser\u00e1. Seu programa dever\u00e1 implementar algo como o algoritmo abaixo. leia inteiro n s = 0.0 para i=0 at\u00e9 n s += 1 / (2 elevado a i) print(s)","title":"Entrada e sa\u00edda em C++"},{"location":"aulas/02-desempenho/","text":"02 - Iniciando C++11 \u00b6 Nesta aula trabalharemos dois objetivos: implementa\u00e7\u00e3o de algoritmos dada uma descri\u00e7\u00e3o de alto n\u00edvel da tarefa a ser implementada t\u00e9cnicas de implementa\u00e7\u00e3o para alto desempenho Aloca\u00e7\u00e3o de mem\u00f3ria e vetores em C++ \u00b6 Em C usamos as fun\u00e7\u00f5es malloc e free para alocar mem\u00f3ria dinamicamente. Um inconveniente dessas fun\u00e7\u00f5es \u00e9 que sempre temos que passar o tamanho que queremos em bytes. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m est\u00e3o dispon\u00edveis, mas us\u00e1-las \u00e9 considerado uma m\u00e1 pr\u00e1tica. Ao inv\u00e9s, usamos os operadores new e delete para alocar mem\u00f3ria. Existem duas vantagens em us\u00e1-los. Podemos escrever diretamente o tipo que queremos, em vez de seu tamanho em bytes. A aloca\u00e7\u00e3o de arrays \u00e9 feita de maneira natural usando os colchetes [] . Vejamos o exemplo abaixo. int n ; std :: cin >> n ; double * values = new double [ n ]; /* usar values aqui */ delete [] values ; \u00c9 alocado um vetor de double de tamanho n (lido do terminal). Ap\u00f3s ele ser usado liberamos o espa\u00e7o alocado usando delete[] . E se eu quiser alocar um s\u00f3 valor? \u00c9 simples! \u00c9 s\u00f3 usar new sem os colchetes [] ! Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Resposta Use o programa t1.py para gerar entradas e sa\u00eddas de teste para seu programa. Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas? Resposta M\u00e9dia e vari\u00e2ncia. Apesar do uso de new[] e delete[] mostrado na se\u00e7\u00e3o anterior j\u00e1 ser mais conveniente, ainda s\u00e3o essencialmente um programa em C com sintaxe ligeiramente mais agrad\u00e1vel. Para tornar a programa\u00e7\u00e3o em C++ mais produtiva sua biblioteca padr\u00e3o conta com estruturas de dados prontas para uso. A estrutura std::vector \u00e9 um vetor din\u00e2mico que tem funcionalidades parecidas com a lista de Python ou o ArrayList de Java. O c\u00f3digo abaixo exemplifica seu uso e mostra algumas de suas fun\u00e7\u00f5es. Note que omitimos o uso de std no c\u00f3digo abaixo. int n ; cin >> n ; vector < double > vec ; for ( int i = 0 ; i < n ; i ++ ) { vec . push_back ( i * i ) } cout << \"Tamanho do vetor: \" << vec . size () << \" \\n \" ; cout << \"Primeiro elemento: \" << vec . front () << \" \\n \" ; cout << \"\u00daltimo elemento: \" << vec . back () << \" \\n \" ; cout << \"Elemento 3: \" << vec [ 2 ] << \" \\n \" ; Alguns pontos interessantes deste exemplo: N\u00e3o sabemos o tamanho de vec ao cri\u00e1-lo. O m\u00e9todo push_back aumenta ele quando necess\u00e1rio e n\u00e3o precisamos nos preocupar com isso. O n\u00famero de elementos colocados no vetor \u00e9 retornado pelo m\u00e9todo size() O acesso \u00e9 feito exatamente igual ao array de C, usando os colchetes [] E esse <double> na declara\u00e7\u00e3o? Em C++ tipos passados entre < > s\u00e3o usados para parametrizar tipos gen\u00e9ricos. Ou seja, um vetor pode guardar qualquer tipo de dado e precisamos indicar qual ao cri\u00e1-lo. Note que, portanto, um vetor vector<int> e um vetor vector<double> s\u00e3o considerados de tipos diferentes e n\u00e3o posso passar o primeiro para uma fun\u00e7\u00e3o esperando o segundo. Example Modifique sua Tarefa 4 para usar vector . Verifique que o programa continua produzindo os mesmos resultados. Matrizes (vers\u00e3o 1) \u00b6 Dados N pontos com coordenadas (x_i, y_i)_{i=0}^N (x_i, y_i)_{i=0}^N , computar a matriz de dist\u00e2ncias D D tal que D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) Tip Use t3.py para gerar os arquivos de entrada/sa\u00edda da tarefa abaixo. Example Implemente um programa que calcule a matriz D acima. Sua entrada dever\u00e1 estar no formato dos arquivos t3-in-*.txt e sua sa\u00edda no formato dos arquivos t3-out-*.txt . Mostre as dist\u00e2ncias com 2 casas decimais. Dicas : a maneira mais f\u00e1cil (n\u00e3o necessariamente a melhor) de alocar uma matriz \u00e9 usando um vetor em que cada elemento \u00e9 outro vetor. fa\u00e7a uma implementa\u00e7\u00e3o o mais simples poss\u00edvel. Vamos melhor\u00e1-la nas pr\u00f3ximas tarefas. Resposta leia inteiro N leia vetores X e Y seja D uma matriz NxN para i=1..N: para j=1..N: DX = X[i] - X[j] DY = Y[i] - Y[j] D[i,j] = sqrt(DX*DX + DY*DY) Question Anote abaixo o tempo de execu\u00e7\u00e3o para os arquivos t3-in-*.txt e t3-out-*.txt Question Qual \u00e9 a complexidade computacional de sua implementa\u00e7\u00e3o? Refer\u00eancias e passagem de dados \u00b6 Na parte anterior fizemos nosso programa inteiro no main . Vamos agora organiz\u00e1-lo melhor. Example Crie uma fun\u00e7\u00e3o calcula_distancias que recebe a matriz e os dados recebidos na entrada e a preenche. Sua fun\u00e7\u00e3o n\u00e3o dever\u00e1 retornar nenhum valor. Ao terminar, me\u00e7a o tempo de execu\u00e7\u00e3o para o arquivo t3-out-4.txt . Resposta Aqui podem ocorrer dois problemas: Seu programa deu \"Segmentation Fault\". Seu programa rodou at\u00e9 o fim, mas a sa\u00edda \u00e9 vazia (ou cheia de 0). O problema em si depende de como voc\u00ea fez o for duplo para mostrar os resultados. De qualquer maneira, simplesmente mover c\u00f3digo para uma outra fun\u00e7\u00e3o n\u00e3o funciona neste caso. Ambos problemas descritos na solu\u00e7\u00e3o s\u00e3o previs\u00edveis e ocorrem pela mesma raz\u00e3o: ao passar um vector para uma fun\u00e7\u00e3o \u00e9 feita uma c\u00f3pia de seu conte\u00fado . Ou seja, a matriz usada dentro de calcula_distancias n\u00e3o \u00e9 a mesma do main ! Isto \u00e9 considerado uma feature em C++ : por padr\u00e3o toda vari\u00e1vel \u00e9 passada por c\u00f3pia . Isto evita que uma fun\u00e7\u00e3o modifique um valor sem que o c\u00f3digo chamador fique sabendo. Em C podemos passar vari\u00e1veis por refer\u00eancia passando um ponteiro para elas. Apesar de funcional, isso n\u00e3o \u00e9 muito pr\u00e1tico pois temos que acessar a vari\u00e1vel sempre usando * . Em C++ temos um novo recurso: refer\u00eancias. Ao declarar uma vari\u00e1vel como uma refer\u00eancia crio uma esp\u00e9cie de ponteiro constante que sempre acessa a vari\u00e1vel apontada. Veja o exemplo abaixo. int x = 10 ; int & ref = x ; // refer\u00eancias s\u00e3o declaradas colocando & na frente do nome da vari\u00e1vel // a partir daqui ref e x representam a mesma vari\u00e1vel ref = 15 ; cout << x << \" \\n \" ; // 15 O mesmo poderia ser feito com ponteiros (como mostrado abaixo). A grande vantagem da refer\u00eancia \u00e9 que n\u00e3o precisamos usar *ref para nos referirmos \u00e0 vari\u00e1vel x ! Na atribui\u00e7\u00e3o tamb\u00e9m podemos usar direto int &ref = x , o que torna o c\u00f3digo mais limpo e f\u00e1cil de entender. int x = 10 ; int * ref = & x ; // precisamos de &x para apontar ref para a vari\u00e1vel x * ref = 15 ; // precisamos indicar *ref para atribuir a vari\u00e1vel x cout << x << \" \\n \" ; // 15 Dicas Note que uma refer\u00eancia tem que ser inicializada com a vari\u00e1vel a que ela se refere. Ou seja, ao declarar tenho que j\u00e1 indicar a vari\u00e1vel destino. Example Modifique sua fun\u00e7\u00e3o para usar refer\u00eancias. Verifique que ele volta a funcionar e que seu tempo de execu\u00e7\u00e3o continua parecido com a vers\u00e3o que rodava no main . Resposta Basta adicionar & na frente dos nomes dos argumentos (vetores x, y e matriz). A chamada da fun\u00e7\u00e3o n\u00e3o muda. Dica Em C++ precisamos estar sempre atentos a maneira que passamos os dados. Se n\u00e3o indicarmos ser\u00e1 por c\u00f3pia. Para compartilhar o mesmo objeto entre v\u00e1rias fun\u00e7\u00f5es usamos refer\u00eancias & . Uma primeira otimiza\u00e7\u00e3o \u00b6 Nossa primeira implementa\u00e7\u00e3o \u00e9 bastante direta da defini\u00e7\u00e3o e n\u00e3o tenta ser eficiente. Question Analisando a defini\u00e7ao da Tarefa 1, como seria poss\u00edvel economizar trabalho? Resposta Podemos ver que a matriz D \u00e9 sim\u00e9trica. Ou seja, D[i,j] == D[j,i] . Isso significa que poder\u00edamos calcular s\u00f3 um deles e copiar o valor para a outra posi\u00e7\u00e3o. Question Como isso poderia ser usado para melhorar o tempo de execu\u00e7\u00e3o de calcula_distancias ? Question Seu programa criado na tarefa 1 consegue ser adaptado para implementar sua ideia da quest\u00e3o anterior? O que precisaria ser modificado? Resposta Duas respostas s\u00e3o poss\u00edveis e corretas aqui: Preciso checar se o i > j e usar o valor j\u00e1 calculado de D[j,i] . \u00c9 preciso alocar a matriz inteira antes de come\u00e7ar. Se formos dando push_back linha a linha n\u00e3o conseguimos atribuir um valor ao mesmo tempo a D[i,j] e D[j,i] , j\u00e1 que um deles ainda n\u00e3o ter\u00e1 sido criado. Baseado na resposta acima vamos tentar nossa primeira otimiza\u00e7\u00e3o: s\u00f3 vamos calcular D[i,j] para i <= j (ou seja, s\u00f3 a metade \"de cima\" de D ). Example Use a estrat\u00e9gia acima para evitar calcular a matriz inteira. Verifique se houve melhora no tempo do teste t3-in-3.txt . Dica : tente de novo usar a ideia mais simples poss\u00edvel e implemente adicionando um so if no seu programa. Resposta N\u00e3o dever\u00e1 haver ganho de desempenho significativo. Veremos exatamente o por que na pr\u00f3xima aula.","title":"02 - Iniciando C++11"},{"location":"aulas/02-desempenho/#02-iniciando-c11","text":"Nesta aula trabalharemos dois objetivos: implementa\u00e7\u00e3o de algoritmos dada uma descri\u00e7\u00e3o de alto n\u00edvel da tarefa a ser implementada t\u00e9cnicas de implementa\u00e7\u00e3o para alto desempenho","title":"02 - Iniciando C++11"},{"location":"aulas/02-desempenho/#alocacao-de-memoria-e-vetores-em-c","text":"Em C usamos as fun\u00e7\u00f5es malloc e free para alocar mem\u00f3ria dinamicamente. Um inconveniente dessas fun\u00e7\u00f5es \u00e9 que sempre temos que passar o tamanho que queremos em bytes. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m est\u00e3o dispon\u00edveis, mas us\u00e1-las \u00e9 considerado uma m\u00e1 pr\u00e1tica. Ao inv\u00e9s, usamos os operadores new e delete para alocar mem\u00f3ria. Existem duas vantagens em us\u00e1-los. Podemos escrever diretamente o tipo que queremos, em vez de seu tamanho em bytes. A aloca\u00e7\u00e3o de arrays \u00e9 feita de maneira natural usando os colchetes [] . Vejamos o exemplo abaixo. int n ; std :: cin >> n ; double * values = new double [ n ]; /* usar values aqui */ delete [] values ; \u00c9 alocado um vetor de double de tamanho n (lido do terminal). Ap\u00f3s ele ser usado liberamos o espa\u00e7o alocado usando delete[] . E se eu quiser alocar um s\u00f3 valor? \u00c9 simples! \u00c9 s\u00f3 usar new sem os colchetes [] ! Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Resposta Use o programa t1.py para gerar entradas e sa\u00eddas de teste para seu programa. Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas? Resposta M\u00e9dia e vari\u00e2ncia. Apesar do uso de new[] e delete[] mostrado na se\u00e7\u00e3o anterior j\u00e1 ser mais conveniente, ainda s\u00e3o essencialmente um programa em C com sintaxe ligeiramente mais agrad\u00e1vel. Para tornar a programa\u00e7\u00e3o em C++ mais produtiva sua biblioteca padr\u00e3o conta com estruturas de dados prontas para uso. A estrutura std::vector \u00e9 um vetor din\u00e2mico que tem funcionalidades parecidas com a lista de Python ou o ArrayList de Java. O c\u00f3digo abaixo exemplifica seu uso e mostra algumas de suas fun\u00e7\u00f5es. Note que omitimos o uso de std no c\u00f3digo abaixo. int n ; cin >> n ; vector < double > vec ; for ( int i = 0 ; i < n ; i ++ ) { vec . push_back ( i * i ) } cout << \"Tamanho do vetor: \" << vec . size () << \" \\n \" ; cout << \"Primeiro elemento: \" << vec . front () << \" \\n \" ; cout << \"\u00daltimo elemento: \" << vec . back () << \" \\n \" ; cout << \"Elemento 3: \" << vec [ 2 ] << \" \\n \" ; Alguns pontos interessantes deste exemplo: N\u00e3o sabemos o tamanho de vec ao cri\u00e1-lo. O m\u00e9todo push_back aumenta ele quando necess\u00e1rio e n\u00e3o precisamos nos preocupar com isso. O n\u00famero de elementos colocados no vetor \u00e9 retornado pelo m\u00e9todo size() O acesso \u00e9 feito exatamente igual ao array de C, usando os colchetes [] E esse <double> na declara\u00e7\u00e3o? Em C++ tipos passados entre < > s\u00e3o usados para parametrizar tipos gen\u00e9ricos. Ou seja, um vetor pode guardar qualquer tipo de dado e precisamos indicar qual ao cri\u00e1-lo. Note que, portanto, um vetor vector<int> e um vetor vector<double> s\u00e3o considerados de tipos diferentes e n\u00e3o posso passar o primeiro para uma fun\u00e7\u00e3o esperando o segundo. Example Modifique sua Tarefa 4 para usar vector . Verifique que o programa continua produzindo os mesmos resultados.","title":"Aloca\u00e7\u00e3o de mem\u00f3ria e vetores em C++"},{"location":"aulas/02-desempenho/#matrizes-versao-1","text":"Dados N pontos com coordenadas (x_i, y_i)_{i=0}^N (x_i, y_i)_{i=0}^N , computar a matriz de dist\u00e2ncias D D tal que D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) Tip Use t3.py para gerar os arquivos de entrada/sa\u00edda da tarefa abaixo. Example Implemente um programa que calcule a matriz D acima. Sua entrada dever\u00e1 estar no formato dos arquivos t3-in-*.txt e sua sa\u00edda no formato dos arquivos t3-out-*.txt . Mostre as dist\u00e2ncias com 2 casas decimais. Dicas : a maneira mais f\u00e1cil (n\u00e3o necessariamente a melhor) de alocar uma matriz \u00e9 usando um vetor em que cada elemento \u00e9 outro vetor. fa\u00e7a uma implementa\u00e7\u00e3o o mais simples poss\u00edvel. Vamos melhor\u00e1-la nas pr\u00f3ximas tarefas. Resposta leia inteiro N leia vetores X e Y seja D uma matriz NxN para i=1..N: para j=1..N: DX = X[i] - X[j] DY = Y[i] - Y[j] D[i,j] = sqrt(DX*DX + DY*DY) Question Anote abaixo o tempo de execu\u00e7\u00e3o para os arquivos t3-in-*.txt e t3-out-*.txt Question Qual \u00e9 a complexidade computacional de sua implementa\u00e7\u00e3o?","title":"Matrizes (vers\u00e3o 1)"},{"location":"aulas/02-desempenho/#referencias-e-passagem-de-dados","text":"Na parte anterior fizemos nosso programa inteiro no main . Vamos agora organiz\u00e1-lo melhor. Example Crie uma fun\u00e7\u00e3o calcula_distancias que recebe a matriz e os dados recebidos na entrada e a preenche. Sua fun\u00e7\u00e3o n\u00e3o dever\u00e1 retornar nenhum valor. Ao terminar, me\u00e7a o tempo de execu\u00e7\u00e3o para o arquivo t3-out-4.txt . Resposta Aqui podem ocorrer dois problemas: Seu programa deu \"Segmentation Fault\". Seu programa rodou at\u00e9 o fim, mas a sa\u00edda \u00e9 vazia (ou cheia de 0). O problema em si depende de como voc\u00ea fez o for duplo para mostrar os resultados. De qualquer maneira, simplesmente mover c\u00f3digo para uma outra fun\u00e7\u00e3o n\u00e3o funciona neste caso. Ambos problemas descritos na solu\u00e7\u00e3o s\u00e3o previs\u00edveis e ocorrem pela mesma raz\u00e3o: ao passar um vector para uma fun\u00e7\u00e3o \u00e9 feita uma c\u00f3pia de seu conte\u00fado . Ou seja, a matriz usada dentro de calcula_distancias n\u00e3o \u00e9 a mesma do main ! Isto \u00e9 considerado uma feature em C++ : por padr\u00e3o toda vari\u00e1vel \u00e9 passada por c\u00f3pia . Isto evita que uma fun\u00e7\u00e3o modifique um valor sem que o c\u00f3digo chamador fique sabendo. Em C podemos passar vari\u00e1veis por refer\u00eancia passando um ponteiro para elas. Apesar de funcional, isso n\u00e3o \u00e9 muito pr\u00e1tico pois temos que acessar a vari\u00e1vel sempre usando * . Em C++ temos um novo recurso: refer\u00eancias. Ao declarar uma vari\u00e1vel como uma refer\u00eancia crio uma esp\u00e9cie de ponteiro constante que sempre acessa a vari\u00e1vel apontada. Veja o exemplo abaixo. int x = 10 ; int & ref = x ; // refer\u00eancias s\u00e3o declaradas colocando & na frente do nome da vari\u00e1vel // a partir daqui ref e x representam a mesma vari\u00e1vel ref = 15 ; cout << x << \" \\n \" ; // 15 O mesmo poderia ser feito com ponteiros (como mostrado abaixo). A grande vantagem da refer\u00eancia \u00e9 que n\u00e3o precisamos usar *ref para nos referirmos \u00e0 vari\u00e1vel x ! Na atribui\u00e7\u00e3o tamb\u00e9m podemos usar direto int &ref = x , o que torna o c\u00f3digo mais limpo e f\u00e1cil de entender. int x = 10 ; int * ref = & x ; // precisamos de &x para apontar ref para a vari\u00e1vel x * ref = 15 ; // precisamos indicar *ref para atribuir a vari\u00e1vel x cout << x << \" \\n \" ; // 15 Dicas Note que uma refer\u00eancia tem que ser inicializada com a vari\u00e1vel a que ela se refere. Ou seja, ao declarar tenho que j\u00e1 indicar a vari\u00e1vel destino. Example Modifique sua fun\u00e7\u00e3o para usar refer\u00eancias. Verifique que ele volta a funcionar e que seu tempo de execu\u00e7\u00e3o continua parecido com a vers\u00e3o que rodava no main . Resposta Basta adicionar & na frente dos nomes dos argumentos (vetores x, y e matriz). A chamada da fun\u00e7\u00e3o n\u00e3o muda. Dica Em C++ precisamos estar sempre atentos a maneira que passamos os dados. Se n\u00e3o indicarmos ser\u00e1 por c\u00f3pia. Para compartilhar o mesmo objeto entre v\u00e1rias fun\u00e7\u00f5es usamos refer\u00eancias & .","title":"Refer\u00eancias e passagem de dados"},{"location":"aulas/02-desempenho/#uma-primeira-otimizacao","text":"Nossa primeira implementa\u00e7\u00e3o \u00e9 bastante direta da defini\u00e7\u00e3o e n\u00e3o tenta ser eficiente. Question Analisando a defini\u00e7ao da Tarefa 1, como seria poss\u00edvel economizar trabalho? Resposta Podemos ver que a matriz D \u00e9 sim\u00e9trica. Ou seja, D[i,j] == D[j,i] . Isso significa que poder\u00edamos calcular s\u00f3 um deles e copiar o valor para a outra posi\u00e7\u00e3o. Question Como isso poderia ser usado para melhorar o tempo de execu\u00e7\u00e3o de calcula_distancias ? Question Seu programa criado na tarefa 1 consegue ser adaptado para implementar sua ideia da quest\u00e3o anterior? O que precisaria ser modificado? Resposta Duas respostas s\u00e3o poss\u00edveis e corretas aqui: Preciso checar se o i > j e usar o valor j\u00e1 calculado de D[j,i] . \u00c9 preciso alocar a matriz inteira antes de come\u00e7ar. Se formos dando push_back linha a linha n\u00e3o conseguimos atribuir um valor ao mesmo tempo a D[i,j] e D[j,i] , j\u00e1 que um deles ainda n\u00e3o ter\u00e1 sido criado. Baseado na resposta acima vamos tentar nossa primeira otimiza\u00e7\u00e3o: s\u00f3 vamos calcular D[i,j] para i <= j (ou seja, s\u00f3 a metade \"de cima\" de D ). Example Use a estrat\u00e9gia acima para evitar calcular a matriz inteira. Verifique se houve melhora no tempo do teste t3-in-3.txt . Dica : tente de novo usar a ideia mais simples poss\u00edvel e implemente adicionando um so if no seu programa. Resposta N\u00e3o dever\u00e1 haver ganho de desempenho significativo. Veremos exatamente o por que na pr\u00f3xima aula.","title":"Uma primeira otimiza\u00e7\u00e3o"},{"location":"aulas/03-profiling-e-projeto/","text":"03 - Profiling \u00b6 Software Para esta aula precisaremos dos seguintes pacotes instalados. valgrind - ferramenta de an\u00e1lise de c\u00f3digo execut\u00e1vel kcachegrind - visualizador de resultados do valgrind Medi\u00e7\u00e3o de tempo com KCachegrind \u00b6 Apesar de podermos medir o tempo que nosso programa demora usando o comando time , n\u00e3o conseguimos nenhuma informa\u00e7\u00e3o importante de qual parte do programa est\u00e1 consumindo mais tempo. Este processo de dissecar um programa e entender exatamente qual parte demora quanto \u00e9 chamada de Profiling . Demonstra\u00e7\u00e3o (Instru\u00e7\u00f5es) \u00c9 preciso compilar um execut\u00e1vel com profiling habilitado para medir os tempos. g++ -g euclides-ingenuo.cpp -o euclides-ingenuo Ap\u00f3s este passo, devemos executar o programa usando o valgrind com as op\u00e7\u00f5es abaixo. valgrind --tool=callgrind ./seu_exec < entrada > saida Para mostrar os resultados usando o kcachegrind usamos o seguinte comando. kcachegrind callgrind.out.(pid aqui) Na demonstra\u00e7\u00e3o pudemos ver que grande parte do tempo do programa da Tarefa 1 \u00e9 gasto mostrando a sa\u00edda no terminal. Isto nos leva \u00e0 primeira conclus\u00e3o da atividade de hoje: Entrada e sa\u00edda de dados s\u00e3o opera\u00e7\u00f5es muito lentas Example Fa\u00e7a o teste da demonstra\u00e7\u00e3o em seu pr\u00f3prio programa e anote abaixo, para as duas vers\u00f5es de calcula_distancias , o tempo relativo de execu\u00e7\u00e3o o n\u00famero absoluto de instru\u00e7\u00f5es executadas Question O n\u00famero absoluto de intru\u00e7\u00f5es executadas diminuiu significativamente depois de nossa otimiza\u00e7\u00e3o? Teoricamente s\u00f3 calculamos metade da matriz, esse n\u00famero \u00e9 quase metade da vers\u00e3o n\u00e3o otimizada? Voc\u00ea consegue dizer por que? Resposta Deve ter havido uma diminui\u00e7\u00e3o, mas n\u00e3o chega nem perto de metade. Isso ocorre por v\u00e1rias raz\u00f5es: nosso for duplo continua percorrendo a matriz inteira, apesar de s\u00f3 fazer o c\u00e1lculo em metade das posi\u00e7\u00f5es. alocamos a matriz elemento a elemento enquanto fazemos os c\u00e1lculos. Com isso em mente, vamos agora otimizar a fun\u00e7\u00e3o calcula_distancias . J\u00e1 sabemos que o efeito no tempo final n\u00e3o ser\u00e1 grande. Nosso objetivo ent\u00e3o ser\u00e1 verificar a seguinte afirma\u00e7\u00e3o. Dois algoritmos de mesma complexidade computacional podem ter tempos de execu\u00e7\u00e3o muito diferentes Question A resposta da quest\u00e3o anterior indica que s\u00f3 usar um if para evitar o c\u00e1lculo repetido n\u00e3o \u00e9 suficiente. Precisamos efetivamente fazer um for que percorre s\u00f3 metade da matriz. Supondo que a matriz j\u00e1 esteja inteira alocada, escreva em pseudo-c\u00f3digo como faz\u00ea-lo. Resposta para i=1..N: para j=i..N: DX = X[i] - X[j] DY = Y[i] - Y[j] DIST = sqrt(DX*DX + DY*DY) D[i,j] = DIST D[j,i] = DIST Matrizes (vers\u00e3o 2) \u00b6 Nossa implementa\u00e7\u00e3o usando vector<vector<double>> tem um problema s\u00e9rio: ela aloca elemento a elemento uma estrutura grande que j\u00e1 sabemos o tamanho de in\u00edcio. Seria muito melhor se pud\u00e9ssemos alocar todas as N^2 N^2 posi\u00e7\u00f5es da matriz de uma s\u00f3 vez! Fazemos isso trabalhando com um layout de mem\u00f3ria cont\u00ednuo. Ou seja, armazenaremos a matriz linha a linha como um \u00fanico vetor de tamanho n*n . Temos v\u00e1rias vantagens: tempo de aloca\u00e7\u00e3o de mem\u00f3ria \u00e9 reduzido, j\u00e1 que s\u00f3 fazemos uma chamada podemos acessar qualquer posi\u00e7\u00e3o a qualquer momento melhor desempenho de cache A figura abaixo exemplifica esse layout de mem\u00f3ria: Question Em uma matriz de tamanho 4x7 (4 linhas, 7 colunas), qual \u00e9 o elemento do vetor que representa a posi\u00e7\u00e3o 2x5 (linha 3, coluna 6)? Details Estamos considerando que come\u00e7amos a contar as linhas e colunas do zero. A posi\u00e7\u00e3o do vetor \u00e9 19 . Este n\u00famero \u00e9 obtido pela express\u00e3o $ i \\times c + j$ i \u00e9 a linha a ser acessada j \u00e9 a coluna c \u00e9 o n\u00famero de colunas da matriz 19 = 2 * 7 + 5 Tip Conseguimos redimensionar um vetor usando o m\u00e9todo resize , que recebe o novo n\u00famero de elementos do vetor. Example Fa\u00e7a uma terceira vers\u00e3o de calcula_distancias , desta vez usando o layout de mem\u00f3ria acima. Verifique que o programa continua retornando os mesmos resultados que as vers\u00f5es anteriores. Question Rode novamente os testes de profiling e verifique o n\u00famero de instru\u00e7\u00f5es para esta nova vers\u00e3o. Compare este valor com os anteriores e comente.","title":"03 - Profiling"},{"location":"aulas/03-profiling-e-projeto/#03-profiling","text":"Software Para esta aula precisaremos dos seguintes pacotes instalados. valgrind - ferramenta de an\u00e1lise de c\u00f3digo execut\u00e1vel kcachegrind - visualizador de resultados do valgrind","title":"03 - Profiling"},{"location":"aulas/03-profiling-e-projeto/#medicao-de-tempo-com-kcachegrind","text":"Apesar de podermos medir o tempo que nosso programa demora usando o comando time , n\u00e3o conseguimos nenhuma informa\u00e7\u00e3o importante de qual parte do programa est\u00e1 consumindo mais tempo. Este processo de dissecar um programa e entender exatamente qual parte demora quanto \u00e9 chamada de Profiling . Demonstra\u00e7\u00e3o (Instru\u00e7\u00f5es) \u00c9 preciso compilar um execut\u00e1vel com profiling habilitado para medir os tempos. g++ -g euclides-ingenuo.cpp -o euclides-ingenuo Ap\u00f3s este passo, devemos executar o programa usando o valgrind com as op\u00e7\u00f5es abaixo. valgrind --tool=callgrind ./seu_exec < entrada > saida Para mostrar os resultados usando o kcachegrind usamos o seguinte comando. kcachegrind callgrind.out.(pid aqui) Na demonstra\u00e7\u00e3o pudemos ver que grande parte do tempo do programa da Tarefa 1 \u00e9 gasto mostrando a sa\u00edda no terminal. Isto nos leva \u00e0 primeira conclus\u00e3o da atividade de hoje: Entrada e sa\u00edda de dados s\u00e3o opera\u00e7\u00f5es muito lentas Example Fa\u00e7a o teste da demonstra\u00e7\u00e3o em seu pr\u00f3prio programa e anote abaixo, para as duas vers\u00f5es de calcula_distancias , o tempo relativo de execu\u00e7\u00e3o o n\u00famero absoluto de instru\u00e7\u00f5es executadas Question O n\u00famero absoluto de intru\u00e7\u00f5es executadas diminuiu significativamente depois de nossa otimiza\u00e7\u00e3o? Teoricamente s\u00f3 calculamos metade da matriz, esse n\u00famero \u00e9 quase metade da vers\u00e3o n\u00e3o otimizada? Voc\u00ea consegue dizer por que? Resposta Deve ter havido uma diminui\u00e7\u00e3o, mas n\u00e3o chega nem perto de metade. Isso ocorre por v\u00e1rias raz\u00f5es: nosso for duplo continua percorrendo a matriz inteira, apesar de s\u00f3 fazer o c\u00e1lculo em metade das posi\u00e7\u00f5es. alocamos a matriz elemento a elemento enquanto fazemos os c\u00e1lculos. Com isso em mente, vamos agora otimizar a fun\u00e7\u00e3o calcula_distancias . J\u00e1 sabemos que o efeito no tempo final n\u00e3o ser\u00e1 grande. Nosso objetivo ent\u00e3o ser\u00e1 verificar a seguinte afirma\u00e7\u00e3o. Dois algoritmos de mesma complexidade computacional podem ter tempos de execu\u00e7\u00e3o muito diferentes Question A resposta da quest\u00e3o anterior indica que s\u00f3 usar um if para evitar o c\u00e1lculo repetido n\u00e3o \u00e9 suficiente. Precisamos efetivamente fazer um for que percorre s\u00f3 metade da matriz. Supondo que a matriz j\u00e1 esteja inteira alocada, escreva em pseudo-c\u00f3digo como faz\u00ea-lo. Resposta para i=1..N: para j=i..N: DX = X[i] - X[j] DY = Y[i] - Y[j] DIST = sqrt(DX*DX + DY*DY) D[i,j] = DIST D[j,i] = DIST","title":"Medi\u00e7\u00e3o de tempo com KCachegrind"},{"location":"aulas/03-profiling-e-projeto/#matrizes-versao-2","text":"Nossa implementa\u00e7\u00e3o usando vector<vector<double>> tem um problema s\u00e9rio: ela aloca elemento a elemento uma estrutura grande que j\u00e1 sabemos o tamanho de in\u00edcio. Seria muito melhor se pud\u00e9ssemos alocar todas as N^2 N^2 posi\u00e7\u00f5es da matriz de uma s\u00f3 vez! Fazemos isso trabalhando com um layout de mem\u00f3ria cont\u00ednuo. Ou seja, armazenaremos a matriz linha a linha como um \u00fanico vetor de tamanho n*n . Temos v\u00e1rias vantagens: tempo de aloca\u00e7\u00e3o de mem\u00f3ria \u00e9 reduzido, j\u00e1 que s\u00f3 fazemos uma chamada podemos acessar qualquer posi\u00e7\u00e3o a qualquer momento melhor desempenho de cache A figura abaixo exemplifica esse layout de mem\u00f3ria: Question Em uma matriz de tamanho 4x7 (4 linhas, 7 colunas), qual \u00e9 o elemento do vetor que representa a posi\u00e7\u00e3o 2x5 (linha 3, coluna 6)? Details Estamos considerando que come\u00e7amos a contar as linhas e colunas do zero. A posi\u00e7\u00e3o do vetor \u00e9 19 . Este n\u00famero \u00e9 obtido pela express\u00e3o $ i \\times c + j$ i \u00e9 a linha a ser acessada j \u00e9 a coluna c \u00e9 o n\u00famero de colunas da matriz 19 = 2 * 7 + 5 Tip Conseguimos redimensionar um vetor usando o m\u00e9todo resize , que recebe o novo n\u00famero de elementos do vetor. Example Fa\u00e7a uma terceira vers\u00e3o de calcula_distancias , desta vez usando o layout de mem\u00f3ria acima. Verifique que o programa continua retornando os mesmos resultados que as vers\u00f5es anteriores. Question Rode novamente os testes de profiling e verifique o n\u00famero de instru\u00e7\u00f5es para esta nova vers\u00e3o. Compare este valor com os anteriores e comente.","title":"Matrizes (vers\u00e3o 2)"},{"location":"aulas/04-projeto-heuristicas/","text":"04 - Heur\u00edsticas \u00b6 A atividade pr\u00e1tica de hoje consiste em implementar heur\u00edsticas para a solu\u00e7\u00e3o do problema da Mochila bin\u00e1ria . Resumo do problema \u00b6 Dados N objetos e uma mochila que comporta at\u00e9 W quilos, cada um com peso w_i w_i e valor v_i v_i , selecionar objetos com o maior valor poss\u00edvel que caibam dentro da mochila. Entrada : N W w1 v1 .... wN vN Sa\u00edda : W V opt o1 ... oT W - peso dos objetos selecionados V - valor dos objetos selecionados opt 0 se for usada uma heur\u00edstica ou busca local 1 se a solu\u00e7\u00e3o for \u00f3timo global oi s\u00e3o os \u00edndices ( em ordem crescente ) dos objetos selecionados Tip Arquivos para verificar a corretude das suas implementa\u00e7\u00f5es est\u00e3o dispon\u00edveis nesta pasta. Eles est\u00e3o nomeados como in-*.txt , mais-caro-out-*.txt e mais-leve-out-*.txt . Mais caro primeiro \u00b6 A ideia desta heur\u00edstica \u00e9 n\u00e3o deixar nenhum objeto valioso para tr\u00e1s! Por isso vamos ser ganaciosos e pegar primeiro os objetos mais caros ! Se um objeto valioso n\u00e3o couber passamos para os mais baratos e prosseguimos at\u00e9 examinar todos objetos. Question Escreva abaixo um algoritmo em pseudo-c\u00f3digo para implementar a heur\u00edstica descrita acima. Resposta ids = // vetor inicializado com ids[i] = i ordene os vetores ids, v e w de acordo com o vetor de valores v peso = 0 valor = 0 resposta = //vetor inicializado com 0 T = 0 // n\u00famero de objetos selecionados para i=1..N se peso + w[i] < W ent\u00e3o resposta[T] = ids[i] peso += w[i] valor += v[i] T += 1 print peso, valor, 0 print resposta[0 .. T] Question Qual \u00e9 a complexidade computacional deste algoritmo? Ele \u00e9 a melhor implementa\u00e7\u00e3o poss\u00edvel? Resposta Se o algoritmo descrito em sua resposta anterior envolver ordena\u00e7\u00e3o, ent\u00e3o ele tem complexidade \\mathcal{O}(n\\log n) \\mathcal{O}(n\\log n) e \u00e9 o melhor poss\u00edvel sim (voc\u00ea consegue explicar por que?). Se voc\u00ea fez um loop duplo que procura pelo maior a cada itera\u00e7\u00e3o ent\u00e3o seu algoritmo \u00e9 \\mathcal{O}(n^2) \\mathcal{O}(n^2) . Example Agora que temos um algoritmo, crie uma implementa\u00e7\u00e3o do programa acima. Dica : C++ j\u00e1 possui um algoritmo de ordena\u00e7\u00e3o implementado no cabe\u00e7alho <algorithm> . Use-o. Busque por ordena\u00e7\u00e3o indireta para entender como ordenar os tr\u00eas vetores ao mesmo tempo. Pode ser conveniente organizar os dados usando struct . Mais leve primeiro \u00b6 Vamos testar uma abordagem oposta: quantidade agora \u00e9 o foco . Por isso vamos ser pr\u00e1ticos e pegar o maior n\u00famero de objetos poss\u00edvel ! Come\u00e7aremos agora pelos objetos mais leves e vamos torcer para que a quantidade grande de objetos selecionados resulte em uma mochila com alto valor. Question Compare esta heur\u00edstica com a da se\u00e7\u00e3o anterior levando em conta o algoritmo em pseudo-c\u00f3digo e sua complexidade computacional. Question Quais partes do programa da heur\u00edstica anterior podem ser aproveitadas para implementar a descrita acima? Example Implemente agora a heur\u00edstica do mais leve. Chame seu programa de mais_leve , mantendo tamb\u00e9m o c\u00f3digo do anterior. Analisando nossas heur\u00edsticas \u00b6 Question Crie uma entrada em que a heur\u00edstica do mais valioso seja muito melhor que a do mais leve. Escreva abaixo as sa\u00eddas de cada programa. Question Crie uma entrada em que a heur\u00edstica do mais leve seja muito melhor que a do mais valioso. Escreva abaixo as sa\u00eddas de cada programa. Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais valioso \u00e9 melhor? Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais leve \u00e9 melhor?","title":"04 - Heur\u00edsticas"},{"location":"aulas/04-projeto-heuristicas/#04-heuristicas","text":"A atividade pr\u00e1tica de hoje consiste em implementar heur\u00edsticas para a solu\u00e7\u00e3o do problema da Mochila bin\u00e1ria .","title":"04 - Heur\u00edsticas"},{"location":"aulas/04-projeto-heuristicas/#resumo-do-problema","text":"Dados N objetos e uma mochila que comporta at\u00e9 W quilos, cada um com peso w_i w_i e valor v_i v_i , selecionar objetos com o maior valor poss\u00edvel que caibam dentro da mochila. Entrada : N W w1 v1 .... wN vN Sa\u00edda : W V opt o1 ... oT W - peso dos objetos selecionados V - valor dos objetos selecionados opt 0 se for usada uma heur\u00edstica ou busca local 1 se a solu\u00e7\u00e3o for \u00f3timo global oi s\u00e3o os \u00edndices ( em ordem crescente ) dos objetos selecionados Tip Arquivos para verificar a corretude das suas implementa\u00e7\u00f5es est\u00e3o dispon\u00edveis nesta pasta. Eles est\u00e3o nomeados como in-*.txt , mais-caro-out-*.txt e mais-leve-out-*.txt .","title":"Resumo do problema"},{"location":"aulas/04-projeto-heuristicas/#mais-caro-primeiro","text":"A ideia desta heur\u00edstica \u00e9 n\u00e3o deixar nenhum objeto valioso para tr\u00e1s! Por isso vamos ser ganaciosos e pegar primeiro os objetos mais caros ! Se um objeto valioso n\u00e3o couber passamos para os mais baratos e prosseguimos at\u00e9 examinar todos objetos. Question Escreva abaixo um algoritmo em pseudo-c\u00f3digo para implementar a heur\u00edstica descrita acima. Resposta ids = // vetor inicializado com ids[i] = i ordene os vetores ids, v e w de acordo com o vetor de valores v peso = 0 valor = 0 resposta = //vetor inicializado com 0 T = 0 // n\u00famero de objetos selecionados para i=1..N se peso + w[i] < W ent\u00e3o resposta[T] = ids[i] peso += w[i] valor += v[i] T += 1 print peso, valor, 0 print resposta[0 .. T] Question Qual \u00e9 a complexidade computacional deste algoritmo? Ele \u00e9 a melhor implementa\u00e7\u00e3o poss\u00edvel? Resposta Se o algoritmo descrito em sua resposta anterior envolver ordena\u00e7\u00e3o, ent\u00e3o ele tem complexidade \\mathcal{O}(n\\log n) \\mathcal{O}(n\\log n) e \u00e9 o melhor poss\u00edvel sim (voc\u00ea consegue explicar por que?). Se voc\u00ea fez um loop duplo que procura pelo maior a cada itera\u00e7\u00e3o ent\u00e3o seu algoritmo \u00e9 \\mathcal{O}(n^2) \\mathcal{O}(n^2) . Example Agora que temos um algoritmo, crie uma implementa\u00e7\u00e3o do programa acima. Dica : C++ j\u00e1 possui um algoritmo de ordena\u00e7\u00e3o implementado no cabe\u00e7alho <algorithm> . Use-o. Busque por ordena\u00e7\u00e3o indireta para entender como ordenar os tr\u00eas vetores ao mesmo tempo. Pode ser conveniente organizar os dados usando struct .","title":"Mais caro primeiro"},{"location":"aulas/04-projeto-heuristicas/#mais-leve-primeiro","text":"Vamos testar uma abordagem oposta: quantidade agora \u00e9 o foco . Por isso vamos ser pr\u00e1ticos e pegar o maior n\u00famero de objetos poss\u00edvel ! Come\u00e7aremos agora pelos objetos mais leves e vamos torcer para que a quantidade grande de objetos selecionados resulte em uma mochila com alto valor. Question Compare esta heur\u00edstica com a da se\u00e7\u00e3o anterior levando em conta o algoritmo em pseudo-c\u00f3digo e sua complexidade computacional. Question Quais partes do programa da heur\u00edstica anterior podem ser aproveitadas para implementar a descrita acima? Example Implemente agora a heur\u00edstica do mais leve. Chame seu programa de mais_leve , mantendo tamb\u00e9m o c\u00f3digo do anterior.","title":"Mais leve primeiro"},{"location":"aulas/04-projeto-heuristicas/#analisando-nossas-heuristicas","text":"Question Crie uma entrada em que a heur\u00edstica do mais valioso seja muito melhor que a do mais leve. Escreva abaixo as sa\u00eddas de cada programa. Question Crie uma entrada em que a heur\u00edstica do mais leve seja muito melhor que a do mais valioso. Escreva abaixo as sa\u00eddas de cada programa. Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais valioso \u00e9 melhor? Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais leve \u00e9 melhor?","title":"Analisando nossas heur\u00edsticas"},{"location":"aulas/05-algoritmos-aleatorios/","text":"05 - Algoritmos Aleatorizados \u00b6 Um gerador de n\u00fameros pseudo-aleat\u00f3rios (RNG) \u00e9 um algoritmo determin\u00edstico que gera uma sequ\u00eancia de n\u00fameros que parece aleat\u00f3ria. Essa frase possui dois termos importantes que precisamos destrinchar: determin\u00edstico : Um RNG tipicamente recebe como entrada um inteiro seed (que representa uma sequ\u00eancia de bits \"aleat\u00f3ria\") e gera uma sequ\u00eancia de n\u00fameros baseada no seed . Ou seja, o algoritmo \u00e9 determin\u00edstico pois gera sempre a mesma sequ\u00eancia para uma determinada entrada ( seed ). parece aleat\u00f3ria : Se compararmos duas sequ\u00eancias de n\u00fameros, uma gerada por um RNG e outra por uma distribui\u00e7\u00e3o uniforme de verdade, n\u00e3o conseguimos dizer qual distribui\u00e7\u00e3o foi gerada pelo RNG . Ou seja, ao escolhermos um seed a sequ\u00eancia gerada ser\u00e1 sempre a mesma, mesmo se executarmos o programa em outras m\u00e1quinas. Isso torna a utiliza\u00e7\u00e3o de RNGs para experimentos bastante interessante: \u00e9 poss\u00edvel reproduzir os resultados feitos por outros desenvolvedores/cientistas. Para isto \u00e9 necess\u00e1rio que o programa permita escolher o seed da simula\u00e7\u00e3o; que o seed usado seja publicado junto com os resultados. Question E se quisermos gerar uma sequ\u00eancia diferente a cada execu\u00e7\u00e3o do programa? Como poder\u00edamos configurar o seed para que isto aconte\u00e7a? Iniciando com RNGs \u00b6 Muitas implementa\u00e7\u00f5es de RNGs s\u00e3o divididas em duas partes: engine / random state : algoritmo que gera um inteiro cujos bits formam uma sequ\u00eancia pseudo-aleat\u00f3ria. distribution : utiliza os bits acima para retornar n\u00fameros que sigam alguma distribui\u00e7\u00e3o estat\u00edstica (como normal ou uniforme). Question A biblioteca padr\u00e3o de C++ disponibiliza diversas fun\u00e7\u00f5es para utiliza\u00e7\u00e3o de *RNG*s (cabe\u00e7alho <random> - documenta\u00e7\u00e3o neste link ). Se voc\u00ea quisesse sortear n\u00fameros aleat\u00f3rios inteiros entre -2 e 5 quais fun\u00e7\u00f5es usaria? Resposta #include <random> ... std::default_random_engine generator; std::uniform_int_distribution<int> distribution(-2,5); distribution(generator); // gera n\u00famero Question E se voc\u00ea quisesse sortear um n\u00famero real entre 0 e 1 ? Resposta #include <random> ... std::default_random_engine generator; std::uniform_real_distribution<double> distribution(0.0, 1.0); distribution(generator); // gera n\u00famero Agora que voc\u00ea j\u00e1 consegue gerar n\u00fameros aleat\u00f3rios, vamos implementar nossa primeira vers\u00e3o de uma heur\u00edstica aleatorizada. Example Adicionaremos a seguinte varia\u00e7\u00e3o na nossa heur\u00edstica: a cada passo de sele\u00e7\u00e3o temos 25% de chance de selecionar um objeto aleat\u00f3rio que ainda n\u00e3o foi utilizado. Ou seja, cada passo do algoritmo segue a seguinte regra Fa\u00e7a um sorteio aleat\u00f3rio Com probabilidade 75% pegue o pr\u00f3ximo objeto n\u00e3o selecionado de acordo com a heur\u00edstica (mais leve ou mais caro) Com probabilidade 25% selecione um objeto qualquer dos que n\u00e3o foram analisados ainda. Note que n\u00e3o mudamos o pr\u00f3ximo elemento ao fazer a sele\u00e7\u00e3o aleat\u00f3ria. Adote seed=10 nesta tarefa. Dica : agora \u00e9 poss\u00edvel que eu olhe um produto mais de uma vez. Voc\u00ea precisar\u00e1 checar isso no seu programa! Resposta Os arquivos in-*.txt cont\u00e9m entradas para teste. Os arquivos out-caro-(rand-?)*.txt cont\u00e9m as sa\u00eddas esperadas para as heur\u00edsticas do mais caro. Question Rode a heur\u00edstica aleatorizada 10 vezes (como fazer isso?) e anote os valores das mochilas obtidas. Em m\u00e9dia, \u00e9 melhor ou pior que a heuristca sem aleatoriza\u00e7\u00e3o? Construindo uma solu\u00e7\u00e3o inteira aleat\u00f3ria \u00b6 Vamos agora fazer algo mais absurdo: e se criarmos uma solu\u00e7\u00e3o toda aleat\u00f3ria? Question Como voc\u00ea criaria uma solu\u00e7\u00e3o aleatoriamente? Resposta N\u00e3o existe uma resposta certa aqui. Duas solu\u00e7\u00f5es s\u00e3o mais comuns: passando por cada objeto, pegue-o com probabilidade 50% . percorra a lista em ordem aleat\u00f3ria, fazendo o mesmo algoritmo do mais caro/leve. Example Tente implementar a abordagem 1 da resposta acima. Example Tente implementar a abordagem 2 da resposta acima. Question Rode ambos programas acima com v\u00e1rios seeds diferentes e anote abaixo os resultados. Warning Iremos discutir esses resultados na pr\u00f3xima aula.","title":"05 - Algoritmos Aleatorizados"},{"location":"aulas/05-algoritmos-aleatorios/#05-algoritmos-aleatorizados","text":"Um gerador de n\u00fameros pseudo-aleat\u00f3rios (RNG) \u00e9 um algoritmo determin\u00edstico que gera uma sequ\u00eancia de n\u00fameros que parece aleat\u00f3ria. Essa frase possui dois termos importantes que precisamos destrinchar: determin\u00edstico : Um RNG tipicamente recebe como entrada um inteiro seed (que representa uma sequ\u00eancia de bits \"aleat\u00f3ria\") e gera uma sequ\u00eancia de n\u00fameros baseada no seed . Ou seja, o algoritmo \u00e9 determin\u00edstico pois gera sempre a mesma sequ\u00eancia para uma determinada entrada ( seed ). parece aleat\u00f3ria : Se compararmos duas sequ\u00eancias de n\u00fameros, uma gerada por um RNG e outra por uma distribui\u00e7\u00e3o uniforme de verdade, n\u00e3o conseguimos dizer qual distribui\u00e7\u00e3o foi gerada pelo RNG . Ou seja, ao escolhermos um seed a sequ\u00eancia gerada ser\u00e1 sempre a mesma, mesmo se executarmos o programa em outras m\u00e1quinas. Isso torna a utiliza\u00e7\u00e3o de RNGs para experimentos bastante interessante: \u00e9 poss\u00edvel reproduzir os resultados feitos por outros desenvolvedores/cientistas. Para isto \u00e9 necess\u00e1rio que o programa permita escolher o seed da simula\u00e7\u00e3o; que o seed usado seja publicado junto com os resultados. Question E se quisermos gerar uma sequ\u00eancia diferente a cada execu\u00e7\u00e3o do programa? Como poder\u00edamos configurar o seed para que isto aconte\u00e7a?","title":"05 - Algoritmos Aleatorizados"},{"location":"aulas/05-algoritmos-aleatorios/#iniciando-com-rngs","text":"Muitas implementa\u00e7\u00f5es de RNGs s\u00e3o divididas em duas partes: engine / random state : algoritmo que gera um inteiro cujos bits formam uma sequ\u00eancia pseudo-aleat\u00f3ria. distribution : utiliza os bits acima para retornar n\u00fameros que sigam alguma distribui\u00e7\u00e3o estat\u00edstica (como normal ou uniforme). Question A biblioteca padr\u00e3o de C++ disponibiliza diversas fun\u00e7\u00f5es para utiliza\u00e7\u00e3o de *RNG*s (cabe\u00e7alho <random> - documenta\u00e7\u00e3o neste link ). Se voc\u00ea quisesse sortear n\u00fameros aleat\u00f3rios inteiros entre -2 e 5 quais fun\u00e7\u00f5es usaria? Resposta #include <random> ... std::default_random_engine generator; std::uniform_int_distribution<int> distribution(-2,5); distribution(generator); // gera n\u00famero Question E se voc\u00ea quisesse sortear um n\u00famero real entre 0 e 1 ? Resposta #include <random> ... std::default_random_engine generator; std::uniform_real_distribution<double> distribution(0.0, 1.0); distribution(generator); // gera n\u00famero Agora que voc\u00ea j\u00e1 consegue gerar n\u00fameros aleat\u00f3rios, vamos implementar nossa primeira vers\u00e3o de uma heur\u00edstica aleatorizada. Example Adicionaremos a seguinte varia\u00e7\u00e3o na nossa heur\u00edstica: a cada passo de sele\u00e7\u00e3o temos 25% de chance de selecionar um objeto aleat\u00f3rio que ainda n\u00e3o foi utilizado. Ou seja, cada passo do algoritmo segue a seguinte regra Fa\u00e7a um sorteio aleat\u00f3rio Com probabilidade 75% pegue o pr\u00f3ximo objeto n\u00e3o selecionado de acordo com a heur\u00edstica (mais leve ou mais caro) Com probabilidade 25% selecione um objeto qualquer dos que n\u00e3o foram analisados ainda. Note que n\u00e3o mudamos o pr\u00f3ximo elemento ao fazer a sele\u00e7\u00e3o aleat\u00f3ria. Adote seed=10 nesta tarefa. Dica : agora \u00e9 poss\u00edvel que eu olhe um produto mais de uma vez. Voc\u00ea precisar\u00e1 checar isso no seu programa! Resposta Os arquivos in-*.txt cont\u00e9m entradas para teste. Os arquivos out-caro-(rand-?)*.txt cont\u00e9m as sa\u00eddas esperadas para as heur\u00edsticas do mais caro. Question Rode a heur\u00edstica aleatorizada 10 vezes (como fazer isso?) e anote os valores das mochilas obtidas. Em m\u00e9dia, \u00e9 melhor ou pior que a heuristca sem aleatoriza\u00e7\u00e3o?","title":"Iniciando com RNGs"},{"location":"aulas/05-algoritmos-aleatorios/#construindo-uma-solucao-inteira-aleatoria","text":"Vamos agora fazer algo mais absurdo: e se criarmos uma solu\u00e7\u00e3o toda aleat\u00f3ria? Question Como voc\u00ea criaria uma solu\u00e7\u00e3o aleatoriamente? Resposta N\u00e3o existe uma resposta certa aqui. Duas solu\u00e7\u00f5es s\u00e3o mais comuns: passando por cada objeto, pegue-o com probabilidade 50% . percorra a lista em ordem aleat\u00f3ria, fazendo o mesmo algoritmo do mais caro/leve. Example Tente implementar a abordagem 1 da resposta acima. Example Tente implementar a abordagem 2 da resposta acima. Question Rode ambos programas acima com v\u00e1rios seeds diferentes e anote abaixo os resultados. Warning Iremos discutir esses resultados na pr\u00f3xima aula.","title":"Construindo uma solu\u00e7\u00e3o inteira aleat\u00f3ria"},{"location":"aulas/06-busca-local/","text":"06 - Busca local \u00b6 Nesta aula trabalharemos com um algoritmo chamado \"Busca local\", que consiste basicamente em fazer pequenas atualiza\u00e7\u00f5es que melhoram sucessivamente uma solu\u00e7\u00e3o. Solu\u00e7\u00e3o aleatorizada \u00b6 Vamos iniciar criando solu\u00e7\u00f5es aleat\u00f3rias. Isto nos permitiria criar uma grande quantidade de solu\u00e7\u00f5es e, eventualmente, pegar a melhor delas. Apesar de ser muito mais simples que a busca heur\u00edstica, a quantidade massiva de solu\u00e7\u00f5es geradas tem potencial de encontrar boas solu\u00e7\u00f5es. Vamos trabalhar com um algoritmo bem simples para gerar solu\u00e7\u00f5es aleat\u00f3rias: Para cada objeto, selecione-o com probabilidade 0.5 . Se o objeto for selecionado, coloque-o na mochile se couber. Question Supondo que s\u00f3 existe uma solu\u00e7\u00e3o \u00f3tima global, qual \u00e9 a chance de a encontrarmos repetindo o algoritmo acima? Question Supondo que todos os objetos caibam na mochila, quantos s\u00e3o selecionados em m\u00e9dia? Example Implemente o algoritmo acima. Use seed=10 . Example Repita o algoritmo 10 vezes e pegue somente a melhor solu\u00e7\u00e3o. Tip Use os arquivos de entrada/sa\u00edda disponibilizados nas aulas passadas. Busca local \u00b6 Vamos agora implementar uma busca local para a Mochila Bin\u00e1ria seguindo os dois algoritmos vistos na expositiva. Mochila cheia \u00b6 Para implementar a Mochila cheia iremos adotar a seguinte estrat\u00e9gia: Gere uma solu\u00e7\u00e3o aleat\u00f3ria. Percorre novamente todos os objetos (na ordem da entrada) Se um objeto couber na mochila, inclua-o. Example Implemente o algoritmo acima. Example Rode a Mochila cheia 10 vezes e retorne a melhor solu\u00e7\u00e3o. Question Houve melhoria em rela\u00e7\u00e3o ao aleat\u00f3rio sozinho? Foi significativa? Fechamento \u00b6 Question Como voc\u00ea avalia os ganhos obtidos pela busca local em rela\u00e7\u00e3o ao aleat\u00f3rio?","title":"06 - Busca local"},{"location":"aulas/06-busca-local/#06-busca-local","text":"Nesta aula trabalharemos com um algoritmo chamado \"Busca local\", que consiste basicamente em fazer pequenas atualiza\u00e7\u00f5es que melhoram sucessivamente uma solu\u00e7\u00e3o.","title":"06 - Busca local"},{"location":"aulas/06-busca-local/#solucao-aleatorizada","text":"Vamos iniciar criando solu\u00e7\u00f5es aleat\u00f3rias. Isto nos permitiria criar uma grande quantidade de solu\u00e7\u00f5es e, eventualmente, pegar a melhor delas. Apesar de ser muito mais simples que a busca heur\u00edstica, a quantidade massiva de solu\u00e7\u00f5es geradas tem potencial de encontrar boas solu\u00e7\u00f5es. Vamos trabalhar com um algoritmo bem simples para gerar solu\u00e7\u00f5es aleat\u00f3rias: Para cada objeto, selecione-o com probabilidade 0.5 . Se o objeto for selecionado, coloque-o na mochile se couber. Question Supondo que s\u00f3 existe uma solu\u00e7\u00e3o \u00f3tima global, qual \u00e9 a chance de a encontrarmos repetindo o algoritmo acima? Question Supondo que todos os objetos caibam na mochila, quantos s\u00e3o selecionados em m\u00e9dia? Example Implemente o algoritmo acima. Use seed=10 . Example Repita o algoritmo 10 vezes e pegue somente a melhor solu\u00e7\u00e3o. Tip Use os arquivos de entrada/sa\u00edda disponibilizados nas aulas passadas.","title":"Solu\u00e7\u00e3o aleatorizada"},{"location":"aulas/06-busca-local/#busca-local","text":"Vamos agora implementar uma busca local para a Mochila Bin\u00e1ria seguindo os dois algoritmos vistos na expositiva.","title":"Busca local"},{"location":"aulas/06-busca-local/#mochila-cheia","text":"Para implementar a Mochila cheia iremos adotar a seguinte estrat\u00e9gia: Gere uma solu\u00e7\u00e3o aleat\u00f3ria. Percorre novamente todos os objetos (na ordem da entrada) Se um objeto couber na mochila, inclua-o. Example Implemente o algoritmo acima. Example Rode a Mochila cheia 10 vezes e retorne a melhor solu\u00e7\u00e3o. Question Houve melhoria em rela\u00e7\u00e3o ao aleat\u00f3rio sozinho? Foi significativa?","title":"Mochila cheia"},{"location":"aulas/06-busca-local/#fechamento","text":"Question Como voc\u00ea avalia os ganhos obtidos pela busca local em rela\u00e7\u00e3o ao aleat\u00f3rio?","title":"Fechamento"},{"location":"aulas/07-busca-exaustiva/","text":"07 - Busca exaustiva \u00b6 Pseudo-c\u00f3digo \u00b6 Vamos iniciar tentando escrever um algoritmo em pseudo-c\u00f3digo para a seguinte ideia: Iniciando com o objeto 0: N\u00e3o inclua ele na mochila: resolva o problema com o restante dos objetos e retorne esse resultado Inclua ele na mochila: resolva o problema com o restante dos objetos e uma mochila de capacidade C - p[0] . Retorne o resultado + v[0] . Escolhe a melhor das duas op\u00e7\u00f5es acima e retorne. Tip Note que pedimos para resolver o problema de novo, mas com menos objetos. Parece que esse \u00e9 um algoritmo recursivo! Question Escreva um algoritmo recursivo em pseudo-c\u00f3digo para resolver o problema da mochila. Seu algoritmo dever\u00e1 retornar o valor da mochila \u00f3tima, mas N\u00c3O precisa ainda retornar a mochila que tem esse valor. Question Adapte seu algoritmo acima para, al\u00e9m de retornar a melhor solu\u00e7\u00e3o, tamb\u00e9m retornar a mochila que tem esse valor. Dica : pode ser \u00fatil passar um vetor para guardar a melhor solu\u00e7\u00e3o encontrada. Implementa\u00e7\u00e3o \u00b6 Vamos agora tentar implementar o algoritmo de busca global que fizemos. Example Implemente em C++ seu algoritmo acima. Question Teste o seu programa com a entrada in-aula.txt (que \u00e9 a entrada dos slides). Voc\u00ea consegue agora responder \u00e0 pergunta Existe mochila com valor maior que 13 ? Fechamento \u00b6 Question Como voc\u00ea avalia os ganhos obtidos pela busca global em rela\u00e7\u00e3o \u00e0 busca local?","title":"07 - Busca exaustiva"},{"location":"aulas/07-busca-exaustiva/#07-busca-exaustiva","text":"","title":"07 - Busca exaustiva"},{"location":"aulas/07-busca-exaustiva/#pseudo-codigo","text":"Vamos iniciar tentando escrever um algoritmo em pseudo-c\u00f3digo para a seguinte ideia: Iniciando com o objeto 0: N\u00e3o inclua ele na mochila: resolva o problema com o restante dos objetos e retorne esse resultado Inclua ele na mochila: resolva o problema com o restante dos objetos e uma mochila de capacidade C - p[0] . Retorne o resultado + v[0] . Escolhe a melhor das duas op\u00e7\u00f5es acima e retorne. Tip Note que pedimos para resolver o problema de novo, mas com menos objetos. Parece que esse \u00e9 um algoritmo recursivo! Question Escreva um algoritmo recursivo em pseudo-c\u00f3digo para resolver o problema da mochila. Seu algoritmo dever\u00e1 retornar o valor da mochila \u00f3tima, mas N\u00c3O precisa ainda retornar a mochila que tem esse valor. Question Adapte seu algoritmo acima para, al\u00e9m de retornar a melhor solu\u00e7\u00e3o, tamb\u00e9m retornar a mochila que tem esse valor. Dica : pode ser \u00fatil passar um vetor para guardar a melhor solu\u00e7\u00e3o encontrada.","title":"Pseudo-c\u00f3digo"},{"location":"aulas/07-busca-exaustiva/#implementacao","text":"Vamos agora tentar implementar o algoritmo de busca global que fizemos. Example Implemente em C++ seu algoritmo acima. Question Teste o seu programa com a entrada in-aula.txt (que \u00e9 a entrada dos slides). Voc\u00ea consegue agora responder \u00e0 pergunta Existe mochila com valor maior que 13 ?","title":"Implementa\u00e7\u00e3o"},{"location":"aulas/07-busca-exaustiva/#fechamento","text":"Question Como voc\u00ea avalia os ganhos obtidos pela busca global em rela\u00e7\u00e3o \u00e0 busca local?","title":"Fechamento"},{"location":"aulas/08-busca-exaustiva-II/","text":"08 - Compara\u00e7\u00e3o de resultados \u00b6 J\u00e1 implementamos diversos algoritmos para o problema da mochila bin\u00e1ria e chegou a hora de compararmos os resultados por eles obtidos. Nossa ideia aqui \u00e9 exercitar nossa capacidade de responder perguntas abertas com base em dados. At\u00e9 qual tamanho de mochila a busca global resolve r\u00e1pido? \u00b6 O algoritmo de busca local \u00e9 melhor que as heur\u00edsticas? \u00b6 Vale a pena esperar pela busca global? At\u00e9 que ponto? \u00b6 Formulando a pergunta com precis\u00e3o \u00b6 Todas as perguntas acima s\u00e3o abertas. Elas admitem diferentes respostas dependendo de nossa interpreta\u00e7\u00e3o. Nesta se\u00e7\u00e3o iremos aprender a reformul\u00e1-las de maneira (mais) precisa e a planejar uma s\u00e9rie de experimentos que possam apoiar nossa resposta. Question Escolha uma das quest\u00f5es acima para trabalhar nesta quest\u00e3o. Question Alguns qualificadores comumente usados em discursos informais s\u00e3o considerados \"vazios\" quanto usados em um contexto mais cient\u00edfico, onde \u00e9 importante ser preciso nas mensagens. Express\u00f5es como \"A melhor que B\" \"r\u00e1pido, devagar, significativo\" \"vale a pena\" s\u00e3o ruins pois n\u00e3o deixam expl\u00edcito as expectativas de quem as escreveu. Por exemplo, poder\u00edamos ainda perguntar: \"A \u00e9 melhor que B\"** sob qual m\u00e9trica**? O que \u00e9 considerado \"r\u00e1pido, devagar ou significativo\"? 1 minuto \u00e9 r\u00e1pido ou devagar (depende da aplica\u00e7\u00e3o) Qual \u00e9 o crit\u00e9rio usado para \"valer a pena\"? Tempo? Valor da mochila? O qu\u00e3o pr\u00f3ximo do \u00f3timo vale a pena? Reescreva a pergunta escolhida agora especificando exatamente o que voc\u00ea gostaria de responder. Importante N\u00e3o existe resposta certa para a pergunta acima. Desde que voc\u00ea seja preciso em sua formula\u00e7\u00e3o a resposta est\u00e1 correta. Ou seja, neste momento n\u00e3o estamos questionando se a pergunta faz sentido , somente se ela est\u00e1 bem formulada . Agora que temos uma pergunta mais precisamente formulada, vamos planejar Question Temos dispon\u00edvel na aula 08 um gerador de entradas para a mochila. Como voc\u00ea o usaria para gerar dados que te ajudem a responder a pergunta escolhida? Especifique tamanhos de entrada e comente por que voc\u00ea faria estes testes. Question Com os dados da quest\u00e3o acima em m\u00e3os, que ferramentas visuais voc\u00ea usaria para facilitar a comunica\u00e7\u00e3o dos resultados? Se sua resposta incluir tabelas, diga o que ser\u00e1 mostrado em cada eixo e qual sua interpreta\u00e7\u00e3o dos dados. Se sua resposta incluir gr\u00e1ficos, explique qual tipo e qual informa\u00e7\u00e3o voc\u00ea estaria colocando em evid\u00eancia. Implementando de maneira reprodut\u00edvel \u00b6 Vamos agora tentar implementar seu plano acima de maneira reprodut\u00edvel. Ou seja, qualquer pessoa com a infra necess\u00e1ria poderia reexecutar seus experimentos e obter os mesmos dados que voc\u00ea. Example Re\u00fana todos os arquivos de entrada usados em uma pasta in . Example Crie um script python que executa seu programa para todas as entradas acima. Dicas : voc\u00ea pode usar os.system , mas subprocess.run permite colocar um tempo limite de execu\u00e7\u00e3o. Isto pode ser muito conveniente dependendo do tipo de pergunta que formulou time.time() pode ser interessante para medir o tempo de execu\u00e7\u00e3o do seu programa. Example Salve os resultados acima em um dataframe do Pandas . Se quiser, salve seus resultados correntes para um arquivo CSV . Example Crie tabelas ou gr\u00e1ficos a partir do dataframe criado.","title":"08 - Compara\u00e7\u00e3o de resultados"},{"location":"aulas/08-busca-exaustiva-II/#08-comparacao-de-resultados","text":"J\u00e1 implementamos diversos algoritmos para o problema da mochila bin\u00e1ria e chegou a hora de compararmos os resultados por eles obtidos. Nossa ideia aqui \u00e9 exercitar nossa capacidade de responder perguntas abertas com base em dados.","title":"08 - Compara\u00e7\u00e3o de resultados"},{"location":"aulas/08-busca-exaustiva-II/#ate-qual-tamanho-de-mochila-a-busca-global-resolve-rapido","text":"","title":"At\u00e9 qual tamanho de mochila a busca global resolve r\u00e1pido?"},{"location":"aulas/08-busca-exaustiva-II/#o-algoritmo-de-busca-local-e-melhor-que-as-heuristicas","text":"","title":"O algoritmo de busca local \u00e9 melhor que as heur\u00edsticas?"},{"location":"aulas/08-busca-exaustiva-II/#vale-a-pena-esperar-pela-busca-global-ate-que-ponto","text":"","title":"Vale a pena esperar pela busca global? At\u00e9 que ponto?"},{"location":"aulas/08-busca-exaustiva-II/#formulando-a-pergunta-com-precisao","text":"Todas as perguntas acima s\u00e3o abertas. Elas admitem diferentes respostas dependendo de nossa interpreta\u00e7\u00e3o. Nesta se\u00e7\u00e3o iremos aprender a reformul\u00e1-las de maneira (mais) precisa e a planejar uma s\u00e9rie de experimentos que possam apoiar nossa resposta. Question Escolha uma das quest\u00f5es acima para trabalhar nesta quest\u00e3o. Question Alguns qualificadores comumente usados em discursos informais s\u00e3o considerados \"vazios\" quanto usados em um contexto mais cient\u00edfico, onde \u00e9 importante ser preciso nas mensagens. Express\u00f5es como \"A melhor que B\" \"r\u00e1pido, devagar, significativo\" \"vale a pena\" s\u00e3o ruins pois n\u00e3o deixam expl\u00edcito as expectativas de quem as escreveu. Por exemplo, poder\u00edamos ainda perguntar: \"A \u00e9 melhor que B\"** sob qual m\u00e9trica**? O que \u00e9 considerado \"r\u00e1pido, devagar ou significativo\"? 1 minuto \u00e9 r\u00e1pido ou devagar (depende da aplica\u00e7\u00e3o) Qual \u00e9 o crit\u00e9rio usado para \"valer a pena\"? Tempo? Valor da mochila? O qu\u00e3o pr\u00f3ximo do \u00f3timo vale a pena? Reescreva a pergunta escolhida agora especificando exatamente o que voc\u00ea gostaria de responder. Importante N\u00e3o existe resposta certa para a pergunta acima. Desde que voc\u00ea seja preciso em sua formula\u00e7\u00e3o a resposta est\u00e1 correta. Ou seja, neste momento n\u00e3o estamos questionando se a pergunta faz sentido , somente se ela est\u00e1 bem formulada . Agora que temos uma pergunta mais precisamente formulada, vamos planejar Question Temos dispon\u00edvel na aula 08 um gerador de entradas para a mochila. Como voc\u00ea o usaria para gerar dados que te ajudem a responder a pergunta escolhida? Especifique tamanhos de entrada e comente por que voc\u00ea faria estes testes. Question Com os dados da quest\u00e3o acima em m\u00e3os, que ferramentas visuais voc\u00ea usaria para facilitar a comunica\u00e7\u00e3o dos resultados? Se sua resposta incluir tabelas, diga o que ser\u00e1 mostrado em cada eixo e qual sua interpreta\u00e7\u00e3o dos dados. Se sua resposta incluir gr\u00e1ficos, explique qual tipo e qual informa\u00e7\u00e3o voc\u00ea estaria colocando em evid\u00eancia.","title":"Formulando a pergunta com precis\u00e3o"},{"location":"aulas/08-busca-exaustiva-II/#implementando-de-maneira-reprodutivel","text":"Vamos agora tentar implementar seu plano acima de maneira reprodut\u00edvel. Ou seja, qualquer pessoa com a infra necess\u00e1ria poderia reexecutar seus experimentos e obter os mesmos dados que voc\u00ea. Example Re\u00fana todos os arquivos de entrada usados em uma pasta in . Example Crie um script python que executa seu programa para todas as entradas acima. Dicas : voc\u00ea pode usar os.system , mas subprocess.run permite colocar um tempo limite de execu\u00e7\u00e3o. Isto pode ser muito conveniente dependendo do tipo de pergunta que formulou time.time() pode ser interessante para medir o tempo de execu\u00e7\u00e3o do seu programa. Example Salve os resultados acima em um dataframe do Pandas . Se quiser, salve seus resultados correntes para um arquivo CSV . Example Crie tabelas ou gr\u00e1ficos a partir do dataframe criado.","title":"Implementando de maneira reprodut\u00edvel"},{"location":"aulas/09-branch-and-bound/","text":"09 - Branch and Bound \u00b6 Vamos come\u00e7ar nossa atividade instrumentando nossa busca exaustiva. Dado que a promessa do nosso algoritmo Branch and Bound \u00e9 evitar chegar at\u00e9 o fim de uma solu\u00e7\u00e3o parcial que n\u00e3o tem chance de ser \u00f3tima, faz todo sentido ent\u00e3o contarmos quantas vezes chegamos at\u00e9 o fim. Example Vamos adicionar dois contadores ao nosso programa num_leaf conta quantas vezes uma solu\u00e7\u00e3o completa foi comparada com a melhor poss\u00edvel num_copy conta quantas vezes foi encontrada uma solu\u00e7\u00e3o melhor que a atual. Question Rode para o exemplo in150.txt e anote os valores obtidos abaixo. Um bound simples: ignorar peso \u00b6 Nesta se\u00e7\u00e3o implementaremos um Branch and Bound simples com a seguinte ideia: BOUND Complete uma solu\u00e7\u00e3o parcial incluindo na mochila todos os objetos n\u00e3o selecionados. Isto \u00e9 equivalente a relaxar a restri\u00e7\u00e3o do peso . Question Os contadores num_leaf e num_copy se modificariam ao implementar o Branch and Bound ? Se sim, quais deles? Resposta Somente num_leaf , j\u00e1 que deixamos de chegar em folhas que n\u00e3o tem chance de serem \u00f3timos globais. num_copy continua igual, j\u00e1 que conta o n\u00famero de vezes que o melhor foi atualizado. Example Implemente no seu c\u00f3digo o Branch and Bound usando o Bound acima. Ou seja, voc\u00ea dever\u00e1, ao chegar em um objeto Checar se a soma da solu\u00e7\u00e3o atual mais o bound \u00e9 melhor que o melhor poss\u00edvel. Se n\u00e3o for retorna Se for prossegue fazendo a escolha para o objeto atual. Example Adicione ao seu programa um contador num_bounds que conta o n\u00famero de vezes em que evitamos de testar uma solu\u00e7\u00e3o parcial at\u00e9 o fim. Question Teste seu programa novamente com a entrada in150.txt . Houve ganho de desempenho? Anote abaixo os contadores e interprete seu resultado. Avan\u00e7ado \u00b6 Question O bound Ignorar peso depende das escolhas feitas at\u00e9 o momento? Ou seja, se tenho 4 objetos, o bound da solu\u00e7\u00e3o parcial (1, 0, -, -) \u00e9 igual ou diferente do bound da solu\u00e7\u00e3o parcial (1, 1, -, -) ? Question Como voc\u00ea poderia economizar trabalho ao calcular o bound? \u00c9 poss\u00edvel pr\u00e9-calcular algo? Example Reimplemente seu bound, desta vez pr\u00e9-calculando tudo antes de iniciar a busca_exaustiva. Question Rode novamente com a entrada in150.txt e verifique se houve ganho de tempo de execu\u00e7\u00e3o. Analisando nosso bound \u00b6 Conseguimos algum ganho de desempenho ao criar o \u00faltimo bound. Vamos agora descobrir se ele \u00e9 bom mesmo. Question Como voc\u00ea mediria a altura em que o bound agiu? Seria melhor cortar mais para cima ou mais para baixo? O valor num_bound n\u00e3o ajuda muito a entender se o bound \u00e9 bom, j\u00e1 que cortar muito pode significar faz\u00ea-lo pr\u00f3ximo das folhas (e isto gera ganho pequeno de desempenho). Example Fa\u00e7a seu programa contar o n\u00famero de vezes em que o bound \u00e9 ativado em cada n\u00edvel da recurs\u00e3o. Mostre esses valores no terminal. Question Interprete os resultados acima. Example Fa\u00e7a seu programa guardar a diferen\u00e7a m\u00e9dia entre o valor do bound (que \u00e9 uma estimativa da qualidade final de uma solu\u00e7\u00e3o) e o melhor valor encontrado para aquele ramo da recurs\u00e3o. Dica : voc\u00ea vai precisar retornar o valor da melhor mochila encontrada em cada parte. Question Interprete os resultados acima. Example Plote os valores obtidos acima e interprete seus resultados.","title":"09 - Branch and Bound"},{"location":"aulas/09-branch-and-bound/#09-branch-and-bound","text":"Vamos come\u00e7ar nossa atividade instrumentando nossa busca exaustiva. Dado que a promessa do nosso algoritmo Branch and Bound \u00e9 evitar chegar at\u00e9 o fim de uma solu\u00e7\u00e3o parcial que n\u00e3o tem chance de ser \u00f3tima, faz todo sentido ent\u00e3o contarmos quantas vezes chegamos at\u00e9 o fim. Example Vamos adicionar dois contadores ao nosso programa num_leaf conta quantas vezes uma solu\u00e7\u00e3o completa foi comparada com a melhor poss\u00edvel num_copy conta quantas vezes foi encontrada uma solu\u00e7\u00e3o melhor que a atual. Question Rode para o exemplo in150.txt e anote os valores obtidos abaixo.","title":"09 - Branch and Bound"},{"location":"aulas/09-branch-and-bound/#um-bound-simples-ignorar-peso","text":"Nesta se\u00e7\u00e3o implementaremos um Branch and Bound simples com a seguinte ideia: BOUND Complete uma solu\u00e7\u00e3o parcial incluindo na mochila todos os objetos n\u00e3o selecionados. Isto \u00e9 equivalente a relaxar a restri\u00e7\u00e3o do peso . Question Os contadores num_leaf e num_copy se modificariam ao implementar o Branch and Bound ? Se sim, quais deles? Resposta Somente num_leaf , j\u00e1 que deixamos de chegar em folhas que n\u00e3o tem chance de serem \u00f3timos globais. num_copy continua igual, j\u00e1 que conta o n\u00famero de vezes que o melhor foi atualizado. Example Implemente no seu c\u00f3digo o Branch and Bound usando o Bound acima. Ou seja, voc\u00ea dever\u00e1, ao chegar em um objeto Checar se a soma da solu\u00e7\u00e3o atual mais o bound \u00e9 melhor que o melhor poss\u00edvel. Se n\u00e3o for retorna Se for prossegue fazendo a escolha para o objeto atual. Example Adicione ao seu programa um contador num_bounds que conta o n\u00famero de vezes em que evitamos de testar uma solu\u00e7\u00e3o parcial at\u00e9 o fim. Question Teste seu programa novamente com a entrada in150.txt . Houve ganho de desempenho? Anote abaixo os contadores e interprete seu resultado.","title":"Um bound simples: ignorar peso"},{"location":"aulas/09-branch-and-bound/#avancado","text":"Question O bound Ignorar peso depende das escolhas feitas at\u00e9 o momento? Ou seja, se tenho 4 objetos, o bound da solu\u00e7\u00e3o parcial (1, 0, -, -) \u00e9 igual ou diferente do bound da solu\u00e7\u00e3o parcial (1, 1, -, -) ? Question Como voc\u00ea poderia economizar trabalho ao calcular o bound? \u00c9 poss\u00edvel pr\u00e9-calcular algo? Example Reimplemente seu bound, desta vez pr\u00e9-calculando tudo antes de iniciar a busca_exaustiva. Question Rode novamente com a entrada in150.txt e verifique se houve ganho de tempo de execu\u00e7\u00e3o.","title":"Avan\u00e7ado"},{"location":"aulas/09-branch-and-bound/#analisando-nosso-bound","text":"Conseguimos algum ganho de desempenho ao criar o \u00faltimo bound. Vamos agora descobrir se ele \u00e9 bom mesmo. Question Como voc\u00ea mediria a altura em que o bound agiu? Seria melhor cortar mais para cima ou mais para baixo? O valor num_bound n\u00e3o ajuda muito a entender se o bound \u00e9 bom, j\u00e1 que cortar muito pode significar faz\u00ea-lo pr\u00f3ximo das folhas (e isto gera ganho pequeno de desempenho). Example Fa\u00e7a seu programa contar o n\u00famero de vezes em que o bound \u00e9 ativado em cada n\u00edvel da recurs\u00e3o. Mostre esses valores no terminal. Question Interprete os resultados acima. Example Fa\u00e7a seu programa guardar a diferen\u00e7a m\u00e9dia entre o valor do bound (que \u00e9 uma estimativa da qualidade final de uma solu\u00e7\u00e3o) e o melhor valor encontrado para aquele ramo da recurs\u00e3o. Dica : voc\u00ea vai precisar retornar o valor da melhor mochila encontrada em cada parte. Question Interprete os resultados acima. Example Plote os valores obtidos acima e interprete seus resultados.","title":"Analisando nosso bound"},{"location":"aulas/10-branch-and-bound-II/","text":"10 - Branch and Bound II \u00b6 Vimos na expositiva que um bound justo \u00e9 importante para conseguir ganhos grandes de desempenho no Branch and Bound. A mochila fracion\u00e1ria \u00b6 Nosso relaxamento de restri\u00e7\u00e3o permite que um objeto seja incluido em fra\u00e7\u00f5es. Como vimos na aula, existe um algoritmo simples que d\u00e1 a solu\u00e7\u00e3o \u00f3tima: ordene os objetos por propor\u00e7\u00e3o valor/kg. pegue os objetos nesta ordem at\u00e9 n\u00e3o caber mais na mochila se um objeto n\u00e3o couber inteiro, pegue a maior fra\u00e7\u00e3o poss\u00edvel A resposta da Mochila fracion\u00e1ria provavelmente n\u00e3o ser\u00e1 uma Mochila bin\u00e1ria vi\u00e1vel. Mesmo assim, provamos na aula que ela \u00e9 um limitante superior para a Mochila bin\u00e1ria . Example Implemente a mochila fracion\u00e1ria e execute-a para nossa entrada in150.txt . Sua sa\u00edda deve estar no formato abaixo. valor objeto1(fracao1) .... objetoN(fracaoN) Veja o arquivo out150.txt para a resposta esperada neste exerc\u00edcio. A ordem importa? Estrat\u00e9gia Best-first \u00b6 Antes de incorporar o bound usando mochila fracion\u00e1ria vamos observar o efeito da ordem de an\u00e1lise das solu\u00e7\u00f5es. Na nossa primeira tentativa fizemos a busca exaustiva na ordem que os objetos foram apresentados na entrada. Isso resultava nos seguintes indicadores num_leaf 770786731 num_copy 44 Question Suponha que agora voc\u00ea ir\u00e1 analisar os objetos na ordem usada na Mochila fracion\u00e1ria . Voc\u00ea espera que num_leaf continue igual, aumente ou diminua? Question Suponha que agora voc\u00ea ir\u00e1 analisar os objetos na ordem usada na Mochila fracion\u00e1ria . Voc\u00ea espera que num_copy continue igual, aumente ou diminua? Example Implemente esta estrat\u00e9gia e verifique se os seus resultados se confirmaram. Resposta Assim como voc\u00ea deve ter respondido nas duas primeiras quest\u00f5es, num_leaf deve continuar igual, mas num_copy vai diminuir muito. O bound Mochila fracion\u00e1ria \u00b6 Vamos agora juntar tudo e implementar o bound Mochila fracion\u00e1ria examinando os objetos na ordem da parte anterior. Question Levando em conta que a ordem anterior fez apenas 3 c\u00f3pias, qual sua expectativa em rela\u00e7\u00e3o aos poss\u00edveis ganhos de desempenho que implementar o bound Mochila fracion\u00e1ria pode trazer? Example Implemente o bound. Question Quais os valores de num_leaf , num_copy e num_bound para in150.txt ? Analisando o bound \u00b6 Vamos agora analisar nossas medidas de efetividade do bound. Question Compare os valores de num_bound para Ignorar peso e Mochila fracion\u00e1ria . Voc\u00ea consegue tirar conclus\u00f5es a partir deste valor? Resposta A dica de que tem algo estranho \u00e9 que num_bound \u00e9 muito menor. Ou seja, a conclus\u00e3o de que quanto menor o num_bound melhor \u00e9 claramente problem\u00e1tica, j\u00e1 que contraria a intui\u00e7\u00e3o de que um bound teria que estar ocorrendo v\u00e1rias vezes. Por outro lado, o programa \u00e9 realmente muito mais r\u00e1pido, ent\u00e3o deve haver algo que n\u00e3o est\u00e1 sendo medido corretamente. Example Implemente no seu c\u00f3digo a contagem de quantas vezes o bound foi feito por n\u00edvel da recurs\u00e3o. Question Compare o resultado acima com o obtido no mesmo teste na aula anterior. Agora voc\u00ea consegue explicar a raz\u00e3o do desempenho da nova implementa\u00e7\u00e3o ter sido t\u00e3o melhor? Resposta para a aula anterior 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 43 32830 536970 250518 792810 1550819 2119857 2475746 2710403 56370234 16347241 14514859 63885823 22061564 111961043 25164499 79575293 47368277 2373877 0 17059720 2265050 423517","title":"10 - Branch and Bound II"},{"location":"aulas/10-branch-and-bound-II/#10-branch-and-bound-ii","text":"Vimos na expositiva que um bound justo \u00e9 importante para conseguir ganhos grandes de desempenho no Branch and Bound.","title":"10 - Branch and Bound II"},{"location":"aulas/10-branch-and-bound-II/#a-mochila-fracionaria","text":"Nosso relaxamento de restri\u00e7\u00e3o permite que um objeto seja incluido em fra\u00e7\u00f5es. Como vimos na aula, existe um algoritmo simples que d\u00e1 a solu\u00e7\u00e3o \u00f3tima: ordene os objetos por propor\u00e7\u00e3o valor/kg. pegue os objetos nesta ordem at\u00e9 n\u00e3o caber mais na mochila se um objeto n\u00e3o couber inteiro, pegue a maior fra\u00e7\u00e3o poss\u00edvel A resposta da Mochila fracion\u00e1ria provavelmente n\u00e3o ser\u00e1 uma Mochila bin\u00e1ria vi\u00e1vel. Mesmo assim, provamos na aula que ela \u00e9 um limitante superior para a Mochila bin\u00e1ria . Example Implemente a mochila fracion\u00e1ria e execute-a para nossa entrada in150.txt . Sua sa\u00edda deve estar no formato abaixo. valor objeto1(fracao1) .... objetoN(fracaoN) Veja o arquivo out150.txt para a resposta esperada neste exerc\u00edcio.","title":"A mochila fracion\u00e1ria"},{"location":"aulas/10-branch-and-bound-II/#a-ordem-importa-estrategia-best-first","text":"Antes de incorporar o bound usando mochila fracion\u00e1ria vamos observar o efeito da ordem de an\u00e1lise das solu\u00e7\u00f5es. Na nossa primeira tentativa fizemos a busca exaustiva na ordem que os objetos foram apresentados na entrada. Isso resultava nos seguintes indicadores num_leaf 770786731 num_copy 44 Question Suponha que agora voc\u00ea ir\u00e1 analisar os objetos na ordem usada na Mochila fracion\u00e1ria . Voc\u00ea espera que num_leaf continue igual, aumente ou diminua? Question Suponha que agora voc\u00ea ir\u00e1 analisar os objetos na ordem usada na Mochila fracion\u00e1ria . Voc\u00ea espera que num_copy continue igual, aumente ou diminua? Example Implemente esta estrat\u00e9gia e verifique se os seus resultados se confirmaram. Resposta Assim como voc\u00ea deve ter respondido nas duas primeiras quest\u00f5es, num_leaf deve continuar igual, mas num_copy vai diminuir muito.","title":"A ordem importa? Estrat\u00e9gia Best-first"},{"location":"aulas/10-branch-and-bound-II/#o-bound-mochila-fracionaria","text":"Vamos agora juntar tudo e implementar o bound Mochila fracion\u00e1ria examinando os objetos na ordem da parte anterior. Question Levando em conta que a ordem anterior fez apenas 3 c\u00f3pias, qual sua expectativa em rela\u00e7\u00e3o aos poss\u00edveis ganhos de desempenho que implementar o bound Mochila fracion\u00e1ria pode trazer? Example Implemente o bound. Question Quais os valores de num_leaf , num_copy e num_bound para in150.txt ?","title":"O bound Mochila fracion\u00e1ria"},{"location":"aulas/10-branch-and-bound-II/#analisando-o-bound","text":"Vamos agora analisar nossas medidas de efetividade do bound. Question Compare os valores de num_bound para Ignorar peso e Mochila fracion\u00e1ria . Voc\u00ea consegue tirar conclus\u00f5es a partir deste valor? Resposta A dica de que tem algo estranho \u00e9 que num_bound \u00e9 muito menor. Ou seja, a conclus\u00e3o de que quanto menor o num_bound melhor \u00e9 claramente problem\u00e1tica, j\u00e1 que contraria a intui\u00e7\u00e3o de que um bound teria que estar ocorrendo v\u00e1rias vezes. Por outro lado, o programa \u00e9 realmente muito mais r\u00e1pido, ent\u00e3o deve haver algo que n\u00e3o est\u00e1 sendo medido corretamente. Example Implemente no seu c\u00f3digo a contagem de quantas vezes o bound foi feito por n\u00edvel da recurs\u00e3o. Question Compare o resultado acima com o obtido no mesmo teste na aula anterior. Agora voc\u00ea consegue explicar a raz\u00e3o do desempenho da nova implementa\u00e7\u00e3o ter sido t\u00e3o melhor? Resposta para a aula anterior 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 43 32830 536970 250518 792810 1550819 2119857 2475746 2710403 56370234 16347241 14514859 63885823 22061564 111961043 25164499 79575293 47368277 2373877 0 17059720 2265050 423517","title":"Analisando o bound"},{"location":"aulas/11-introducao-paralelismo/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); 11 - Introdu\u00e7\u00e3o a Paralelismo \u00b6 Compara\u00e7\u00e3o de implementa\u00e7\u00f5es diferentes para o mesmo algoritmo \u00b6 Nossa aula se inicia examinando o efeito de uma implementa\u00e7\u00e3o cuidadosa de um algoritmo no tempo de execu\u00e7\u00e3o final. import subprocess import time with open ( 'entradas-busca-local/in-10.txt' ) as f : start = time . perf_counter () proc = subprocess . run ([ './busca-local' ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () print ( 'Sa\u00edda:' , proc . stdout ) print ( 'Stderr:' , proc . stderr ) print ( 'Tempo total(s):' , end - start ) Vamos agora praticar usar este snippet para executar nossos testes automaticamente. Example Crie uma fun\u00e7\u00e3o roda_com_entrada(executavel, arquivo_in) que roda o primeiro argumento usando como entrada o conte\u00fado do segundo argumento. Teste seu c\u00f3digo com o execut\u00e1vel busca-local e com o arquivo de entrada entrada-pequena.txt presente na pasta da aula. Sua fun\u00e7\u00e3o dever\u00e1 devolver uma tupla (stdout,time) com stdout sendo a sa\u00edda do programa e time seu tempo de execu\u00e7\u00e3o em segundos. import subprocess import time def roda_com_entrada ( exec , arq ): with open ( arq ) as f : start = time . perf_counter () proc = subprocess . run ([ exec ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () return proc . stdout , end - start roda_com_entrada ( './bl-ruim' , 'entradas-busca-local/in-0.txt' ) ('8 0\\n4 0 3 2 1 \\n', 0.03241706400012845) Com esse c\u00f3digo, vamos criar um relat\u00f3rio interativo que roda nossos testes automaticamente e j\u00e1 plota informa\u00e7\u00f5es prontas para nossas an\u00e1lises. Vamos come\u00e7ar examinando o desempenho do execut\u00e1vel busca-local . Example Rode o busca-local com os arquivos de entrada na pasta entradas-busca-local . Guarde os tempos em uma lista. Example Leia o tamanho das entradas dos arquivos na pasta entradas-busca-local e guarde em uma segunda lista. Example Plote o tempo de execu\u00e7\u00e3o pelo tamanho da entrada usando matplotlib entradas = [ f 'entradas-busca-local/in- { i } .txt' for i in range ( 10 )] tamanhos = [] for i in range ( 10 ): with open ( f 'entradas-busca-local/in- { i } .txt' ) as f : tamanhos . append ( float ( f . readline ())) tempos_ruins = [ roda_com_entrada ( './bl-ruim' , ent )[ 1 ] for ent in entradas ] tempos_bom = [] for ent in entradas : tempos_bom . append ( roda_com_entrada ( './busca-local' , ent )[ 1 ]) import matplotlib.pyplot as plt print ( tamanhos , tempos_bom ) plt . scatter ( tamanhos , tempos_bom , label = 'busca-local' ) plt . scatter ( tamanhos , tempos_ruim , color = 'r' , label = 'bl-ruim' ) plt . title ( 'Desempenho busca local' ) plt . xlabel ( 'Tamannho (N)' ) plt . ylabel ( 'Tempo (s)' ) plt . legend () [5.0, 4.0, 4.0, 15.0, 20.0, 40.0, 100.0, 5.0, 10.0, 30.0] [0.005639722000069014, 0.0040926540000327805, 0.003906993999862607, 0.008973122000043077, 0.015713502000380686, 0.12898856999981945, 4.534637195999949, 0.005234286999893811, 0.00700339700006225, 0.06350802800034216] <matplotlib.legend.Legend at 0x7f3f0d40ed90> O arquivo busca-local cont\u00e9m uma implementa\u00e7\u00e3o cuidadosa da busca local do projeto. Ele n\u00e3o cont\u00e9m nenhuma t\u00e9cnica diferente das apresentadas em aula, mas evita ao m\u00e1ximo opera\u00e7\u00f5es desnecess\u00e1rias. Vamos agora comparar os resultados obtidos por ele com sua implementa\u00e7\u00e3o. Example Rode seu a busca local de seu projeto com as mesmas entradas acima e plote os tempos de ambos no mesmo gr\u00e1fico. N\u00e3o se esque\u00e7a de colocar legendas e t\u00edtulo! # seu c\u00f3digo aqui Question Interprete o gr\u00e1fico que voc\u00ea gerou na linha de cima. Existe diferen\u00e7a entre o tempo gasto pelas duas implementa\u00e7\u00f5es? At\u00e9 agora s\u00f3 testamos efici\u00eancia, mas poderia ser interessante testar tamb\u00e9m a qualidade da solu\u00e7\u00e3o produzida. Question Em qual situa\u00e7\u00e3o voc\u00ea entende que comparar a qualidade da solu\u00e7\u00e3o produzida \u00e9 v\u00e1lido? Como voc\u00ea faria essa compara\u00e7\u00e3o? Responda levando em conta tamanho das entradas usadas quantidade de execu\u00e7\u00f5es para cada arquivo de entrada quantidade de arquivos para cada tamanho de entrada. Expectativas de ganhos com paralelismo \u00b6 Agora que j\u00e1 conseguimos comparar implementa\u00e7\u00f5es de um mesmo algoritmo b\u00e1sico, vamos relembrar os tipos de paralelismo vistos em aula: Tipos de paralelismo Dados : opera\u00e7\u00e3o (lenta) \u00e9 feita em paralelo para cada elemento de um conjunto de dados. Tarefas : tarefas n\u00e3o dependentes entre si s\u00e3o executadas em paralelo. J\u00e1 vimos em aula que a busca exaustiva \u00e9 um problema que deveria ser facilmente paraleliz\u00e1vel, j\u00e1 que n\u00e3o possui depend\u00eancia entre as escolhas de um n\u00edvel da recurs\u00e3o. Example Me\u00e7a o tempo da busca exaustiva do seu projeto para as entradas da pasta entradas-busca-exaustiva . Salve em uma lista. Example Supondo que sua m\u00e1quina de testes tenha 8 cores , qual seria o tempo gasto para cada uma das entradas acima? Salve estes valores em uma nova lista. Example Plote abaixo o tempo real do algoritmo sequencial e o tempo esperado do seu projeto se ele fosse paralelizado. # seu c\u00f3digo aqui Vamos agora verificar se essa intui\u00e7\u00e3o se mant\u00e9m para uma implementa\u00e7\u00e3o cuidadosa do algoritmo de busca exaustiva e para uma paraleliza\u00e7\u00e3o bem feita. Os arquivos busca-exaustiva e busca-exaustiva-par cont\u00e9m essas implementa\u00e7\u00f5es. Example Execute ambos para as entradas da pasta entradas-busca-exaustiva e plote os tempos abaixo. Question As expectativas que voc\u00ea escreveu na pergunta anterior foram confirmadas? Como voc\u00ea avaliou isso? Houve grandes ganhos de desempenho, mas eles n\u00e3o s\u00e3o exatamente proporcionais ao n\u00famero de processadores. Isso \u00e9 normal, j\u00e1 que existe um custo em levantar o ambiente paralelizado. Vamos agora complicar um pouco. Example O arquivo busca-branch-and-bound possui uma implementa\u00e7\u00e3o sequencial de um bound razo\u00e1vel para o caixeiro viajante. Compare-o com busca-exaustiva-par . Question Quais foram os resultados da compara\u00e7\u00e3o? entrada2s = [ f 'entradas-busca-exaustiva/in- { i } .txt' for i in range ( 7 )] tamanhos2 = [] for i in range ( 7 ): with open ( f 'entradas-busca-exaustiva/in- { i } .txt' ) as f : tamanhos2 . append ( float ( f . readline ())) tempos_be = [ roda_com_entrada ( './busca-exaustiva' , ent )[ 1 ] for ent in entrada2s ] tempos_be_par = [ roda_com_entrada ( './busca-exaustiva-par' , ent )[ 1 ] for ent in entrada2s ] tempos_bound = [ roda_com_entrada ( './busca-branch-and-bound' , ent )[ 1 ] for ent in entrada2s ] plt . plot ( tamanhos2 , tempos_be , label = 'exaustivo' ) plt . plot ( tamanhos2 , tempos_be_par , label = 'paralelo' ) plt . plot ( tamanhos2 , tempos_bound , label = 'branch and bound' ) plt . legend () plt . title ( 'Desempenho - busca global' ) plt . xlabel ( 'Tamanho (N)' ) Text(0.5, 0, 'Tamanho (N)') N\u00famero de cores importa? \u00b6 Vamos agora finalizar nosso estudo verificando se o n\u00famero de cores afeta linearmente o desempenho. Tip Para configurar o n\u00famero de cores usados em busca-exaustiva-par usamos a vari\u00e1vel de ambiente OMP_NUM_THREADS Example Rode no terminal OMP_NUM_THREADS=2 ./busca-exaustiva-paralela < in-6.txt e verifique o consumo de CPU com htop . Varia o n\u00famero de CPUS usadas e verifique com htop que a prefer\u00eancia foi respeitada. Question Como voc\u00ea usaria o par\u00e2metro env de subprocess.run para configurar o n\u00famero de CPUs? Example Fa\u00e7a um experimento com in-6.txt variando o n\u00famero de CPUs de 1 at\u00e9 8 e plote os resultados. Question Mais cores sempre ajudam? Como voc\u00ea avalia isto? E se o tamanho do problema for maior? Relacione n\u00famero de cores, tamanho da entrada e desempenho.","title":"11 - Introdu\u00e7\u00e3o a paralelismo"},{"location":"aulas/11-introducao-paralelismo/#11-introducao-a-paralelismo","text":"","title":"11 - Introdu\u00e7\u00e3o a Paralelismo"},{"location":"aulas/11-introducao-paralelismo/#comparacao-de-implementacoes-diferentes-para-o-mesmo-algoritmo","text":"Nossa aula se inicia examinando o efeito de uma implementa\u00e7\u00e3o cuidadosa de um algoritmo no tempo de execu\u00e7\u00e3o final. import subprocess import time with open ( 'entradas-busca-local/in-10.txt' ) as f : start = time . perf_counter () proc = subprocess . run ([ './busca-local' ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () print ( 'Sa\u00edda:' , proc . stdout ) print ( 'Stderr:' , proc . stderr ) print ( 'Tempo total(s):' , end - start ) Vamos agora praticar usar este snippet para executar nossos testes automaticamente. Example Crie uma fun\u00e7\u00e3o roda_com_entrada(executavel, arquivo_in) que roda o primeiro argumento usando como entrada o conte\u00fado do segundo argumento. Teste seu c\u00f3digo com o execut\u00e1vel busca-local e com o arquivo de entrada entrada-pequena.txt presente na pasta da aula. Sua fun\u00e7\u00e3o dever\u00e1 devolver uma tupla (stdout,time) com stdout sendo a sa\u00edda do programa e time seu tempo de execu\u00e7\u00e3o em segundos. import subprocess import time def roda_com_entrada ( exec , arq ): with open ( arq ) as f : start = time . perf_counter () proc = subprocess . run ([ exec ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () return proc . stdout , end - start roda_com_entrada ( './bl-ruim' , 'entradas-busca-local/in-0.txt' ) ('8 0\\n4 0 3 2 1 \\n', 0.03241706400012845) Com esse c\u00f3digo, vamos criar um relat\u00f3rio interativo que roda nossos testes automaticamente e j\u00e1 plota informa\u00e7\u00f5es prontas para nossas an\u00e1lises. Vamos come\u00e7ar examinando o desempenho do execut\u00e1vel busca-local . Example Rode o busca-local com os arquivos de entrada na pasta entradas-busca-local . Guarde os tempos em uma lista. Example Leia o tamanho das entradas dos arquivos na pasta entradas-busca-local e guarde em uma segunda lista. Example Plote o tempo de execu\u00e7\u00e3o pelo tamanho da entrada usando matplotlib entradas = [ f 'entradas-busca-local/in- { i } .txt' for i in range ( 10 )] tamanhos = [] for i in range ( 10 ): with open ( f 'entradas-busca-local/in- { i } .txt' ) as f : tamanhos . append ( float ( f . readline ())) tempos_ruins = [ roda_com_entrada ( './bl-ruim' , ent )[ 1 ] for ent in entradas ] tempos_bom = [] for ent in entradas : tempos_bom . append ( roda_com_entrada ( './busca-local' , ent )[ 1 ]) import matplotlib.pyplot as plt print ( tamanhos , tempos_bom ) plt . scatter ( tamanhos , tempos_bom , label = 'busca-local' ) plt . scatter ( tamanhos , tempos_ruim , color = 'r' , label = 'bl-ruim' ) plt . title ( 'Desempenho busca local' ) plt . xlabel ( 'Tamannho (N)' ) plt . ylabel ( 'Tempo (s)' ) plt . legend () [5.0, 4.0, 4.0, 15.0, 20.0, 40.0, 100.0, 5.0, 10.0, 30.0] [0.005639722000069014, 0.0040926540000327805, 0.003906993999862607, 0.008973122000043077, 0.015713502000380686, 0.12898856999981945, 4.534637195999949, 0.005234286999893811, 0.00700339700006225, 0.06350802800034216] <matplotlib.legend.Legend at 0x7f3f0d40ed90> O arquivo busca-local cont\u00e9m uma implementa\u00e7\u00e3o cuidadosa da busca local do projeto. Ele n\u00e3o cont\u00e9m nenhuma t\u00e9cnica diferente das apresentadas em aula, mas evita ao m\u00e1ximo opera\u00e7\u00f5es desnecess\u00e1rias. Vamos agora comparar os resultados obtidos por ele com sua implementa\u00e7\u00e3o. Example Rode seu a busca local de seu projeto com as mesmas entradas acima e plote os tempos de ambos no mesmo gr\u00e1fico. N\u00e3o se esque\u00e7a de colocar legendas e t\u00edtulo! # seu c\u00f3digo aqui Question Interprete o gr\u00e1fico que voc\u00ea gerou na linha de cima. Existe diferen\u00e7a entre o tempo gasto pelas duas implementa\u00e7\u00f5es? At\u00e9 agora s\u00f3 testamos efici\u00eancia, mas poderia ser interessante testar tamb\u00e9m a qualidade da solu\u00e7\u00e3o produzida. Question Em qual situa\u00e7\u00e3o voc\u00ea entende que comparar a qualidade da solu\u00e7\u00e3o produzida \u00e9 v\u00e1lido? Como voc\u00ea faria essa compara\u00e7\u00e3o? Responda levando em conta tamanho das entradas usadas quantidade de execu\u00e7\u00f5es para cada arquivo de entrada quantidade de arquivos para cada tamanho de entrada.","title":"Compara\u00e7\u00e3o de implementa\u00e7\u00f5es diferentes para o mesmo algoritmo"},{"location":"aulas/11-introducao-paralelismo/#expectativas-de-ganhos-com-paralelismo","text":"Agora que j\u00e1 conseguimos comparar implementa\u00e7\u00f5es de um mesmo algoritmo b\u00e1sico, vamos relembrar os tipos de paralelismo vistos em aula: Tipos de paralelismo Dados : opera\u00e7\u00e3o (lenta) \u00e9 feita em paralelo para cada elemento de um conjunto de dados. Tarefas : tarefas n\u00e3o dependentes entre si s\u00e3o executadas em paralelo. J\u00e1 vimos em aula que a busca exaustiva \u00e9 um problema que deveria ser facilmente paraleliz\u00e1vel, j\u00e1 que n\u00e3o possui depend\u00eancia entre as escolhas de um n\u00edvel da recurs\u00e3o. Example Me\u00e7a o tempo da busca exaustiva do seu projeto para as entradas da pasta entradas-busca-exaustiva . Salve em uma lista. Example Supondo que sua m\u00e1quina de testes tenha 8 cores , qual seria o tempo gasto para cada uma das entradas acima? Salve estes valores em uma nova lista. Example Plote abaixo o tempo real do algoritmo sequencial e o tempo esperado do seu projeto se ele fosse paralelizado. # seu c\u00f3digo aqui Vamos agora verificar se essa intui\u00e7\u00e3o se mant\u00e9m para uma implementa\u00e7\u00e3o cuidadosa do algoritmo de busca exaustiva e para uma paraleliza\u00e7\u00e3o bem feita. Os arquivos busca-exaustiva e busca-exaustiva-par cont\u00e9m essas implementa\u00e7\u00f5es. Example Execute ambos para as entradas da pasta entradas-busca-exaustiva e plote os tempos abaixo. Question As expectativas que voc\u00ea escreveu na pergunta anterior foram confirmadas? Como voc\u00ea avaliou isso? Houve grandes ganhos de desempenho, mas eles n\u00e3o s\u00e3o exatamente proporcionais ao n\u00famero de processadores. Isso \u00e9 normal, j\u00e1 que existe um custo em levantar o ambiente paralelizado. Vamos agora complicar um pouco. Example O arquivo busca-branch-and-bound possui uma implementa\u00e7\u00e3o sequencial de um bound razo\u00e1vel para o caixeiro viajante. Compare-o com busca-exaustiva-par . Question Quais foram os resultados da compara\u00e7\u00e3o? entrada2s = [ f 'entradas-busca-exaustiva/in- { i } .txt' for i in range ( 7 )] tamanhos2 = [] for i in range ( 7 ): with open ( f 'entradas-busca-exaustiva/in- { i } .txt' ) as f : tamanhos2 . append ( float ( f . readline ())) tempos_be = [ roda_com_entrada ( './busca-exaustiva' , ent )[ 1 ] for ent in entrada2s ] tempos_be_par = [ roda_com_entrada ( './busca-exaustiva-par' , ent )[ 1 ] for ent in entrada2s ] tempos_bound = [ roda_com_entrada ( './busca-branch-and-bound' , ent )[ 1 ] for ent in entrada2s ] plt . plot ( tamanhos2 , tempos_be , label = 'exaustivo' ) plt . plot ( tamanhos2 , tempos_be_par , label = 'paralelo' ) plt . plot ( tamanhos2 , tempos_bound , label = 'branch and bound' ) plt . legend () plt . title ( 'Desempenho - busca global' ) plt . xlabel ( 'Tamanho (N)' ) Text(0.5, 0, 'Tamanho (N)')","title":"Expectativas de ganhos com paralelismo"},{"location":"aulas/11-introducao-paralelismo/#numero-de-cores-importa","text":"Vamos agora finalizar nosso estudo verificando se o n\u00famero de cores afeta linearmente o desempenho. Tip Para configurar o n\u00famero de cores usados em busca-exaustiva-par usamos a vari\u00e1vel de ambiente OMP_NUM_THREADS Example Rode no terminal OMP_NUM_THREADS=2 ./busca-exaustiva-paralela < in-6.txt e verifique o consumo de CPU com htop . Varia o n\u00famero de CPUS usadas e verifique com htop que a prefer\u00eancia foi respeitada. Question Como voc\u00ea usaria o par\u00e2metro env de subprocess.run para configurar o n\u00famero de CPUs? Example Fa\u00e7a um experimento com in-6.txt variando o n\u00famero de CPUs de 1 at\u00e9 8 e plote os resultados. Question Mais cores sempre ajudam? Como voc\u00ea avalia isto? E se o tamanho do problema for maior? Relacione n\u00famero de cores, tamanho da entrada e desempenho.","title":"N\u00famero de cores importa?"},{"location":"aulas/12-introducao-omp/","text":"12 - Introdu\u00e7\u00e3o a OpenMP \u00b6 OpenMP \u00e9 uma tecnologia de computa\u00e7\u00e3o multi-core usada para paralelizar programas. Sua principal vantagem \u00e9 oferecer uma transi\u00e7\u00e3o suave entre c\u00f3digo sequencial e c\u00f3digo paralelo. Primeiros passos \u00b6 Nesta parte do roteiro usaremos 4 chamadas do OpenMP para criar nossas primeiras threads. #pragma omp parallel cria um conjunto de threads. Deve ser aplicado acima de um bloco de c\u00f3digo limitado por { } int omp_get_num_threads(); retorna o n\u00famero de threads criadas (dentro de uma regi\u00e3o paralela) int omp_get_max_threads(); retorna o n\u00famero de m\u00e1ximo de threads (fora de uma regi\u00e3o paralela) int omp_get_thread_num(); retorna o id da thread atual (entre 0 e o valor acima, dentro de uma regi\u00e3o paralela) O c\u00f3digo abaixo ( exemplo1.cpp ) ilustra como utilizar OpenMP para criar um conjunto de threads que rodam em paralelo. #pragma omp parallel { std :: cout << \"ID:\" << omp_get_thread_num () << \"/\" << omp_get_num_threads () << \" \\n \" ; } Vamos agora fazer alguns experimentos com esse exemplo b\u00e1sico para entender como OpenMP funciona. Example Compile o programa de exemplo usando a seguinte linha de comando e rode-o. $ g++ -O3 exemplo1.cpp -o exemplo1 -fopenmp Question O OpenMP permite alterar o n\u00famero m\u00e1ximo de threads criados usando a vari\u00e1vel de ambiente OMP_NUM_THREADS . Rode exemplo1 como abaixo. OMP_NUM_THREADS=2 ./exemplo1 Quantas threads foram criadas? Question Rode agora sem a vari\u00e1vel de ambiente. Qual \u00e9 o valor padr\u00e3o assumido pelo OpenMP? \u00c9 uma boa ideia usar mais threads que o valor padr\u00e3o? A utiliza\u00e7\u00e3o de OMP_NUM_THREADS ajuda a realizar testes de modo a compreender os ganhos de desempenho de um programa conforme mais threads s\u00e3o utilizadas. Quando uma regi\u00e3o paralela inicia s\u00e3o criadas OMP_NUM_THREADS threads e cada uma roda o bloco de c\u00f3digo imediatamente abaixo de maneira independents. Question No trecho abaixo, quantas c\u00f3pias da vari\u00e1vel temp s\u00e3o criadas? E da vari\u00e1vel res ? Responda usando o n\u00famero de cores da m\u00e1quina como refer\u00eancia. double res = 0 ; #pragma omp parallel { double temp = 10 ; res *= temp ; } Resposta S\u00f3 uma vari\u00e1vel res existe, pois ela foi declarada fora da regi\u00e3o paralela. Existem N c\u00f3pias de temp , uma criada para cada thread existente. Question Voc\u00ea consegue prever o resultado do c\u00f3digo abaixo? Se sim, qual sua sa\u00edda? Se n\u00e3o, voc\u00ea consegue explicar o por que? int res = 1 ; #pragma omp parallel { for ( int i = 0 ; i < 10000 ; i ++ ) { res += 1 ; } } Example Rode o c\u00f3digo acima (arquivo exemplo2.cpp ) e veja se suas expectativas se cumprem. Aproveite e verifique se o programa retorna o mesmo resultado se executado v\u00e1rias vezes. Chame o professor se voc\u00ea se surpreender com o resultado. Resposta O c\u00f3digo dar\u00e1 resultados estranhos, com res n\u00e3o assumindo o valor N * 10000 . Quanto maior o n\u00famero de threads mais distante do correto o valor resultante ser\u00e1. Example Mude o limite do for para 1000 . Os resultados agora s\u00e3o os esperados? Por que? Danger Nos dois exemplos acima as vari\u00e1veis res eram usadas por m\u00faltiplas threads! Ou seja, cada thread possui uma depend\u00eancia em rela\u00e7\u00e3o a res . Escrever c\u00f3digo sem levar em conta as depend\u00eancias \u00e9 um problema que ser\u00e1 abordado nas pr\u00f3ximas aulas. Paralelismo de tarefas \u00b6 Vamos agora criar tarefas que podem ser executadas em paralelo. Defini\u00e7\u00e3o Uma tarefa \u00e9 um bloco de c\u00f3digo que \u00e9 rodado de maneira paralela usando OpenMP. Tarefas s\u00e3o alocadas para cada uma das threads criadas em um regi\u00e3o paralela. N\u00e3o existe uma associa\u00e7\u00e3o 1-1 entre threads e tarefas . Posso ter mais tarefas que threads e mais threads que tarefas . Veja abaixo um exemplo de cria\u00e7\u00e3o de tarefas. #pragma omp parallel { #pragma omp task { std :: cout << \"Estou rodando na tarefa \" << omp_get_thread_num () << \" \\n \" ; } } std :: cout << \"eu s\u00f3 rodo quanto TODAS tarefas acabarem. \\n \" ; Question O exemplo acima cria quantas tarefas, supondo que OMP_NUM_THREADS=4 ? Para controlar a cria\u00e7\u00e3o de tarefas em geral usamos a diretiva master , que executa somente na thread de \u00edndice 0 . #pragma omp parallel { #pragma omp master { std :: cout << \"s\u00f3 roda uma vez na thread:\" << omp_get_thread_num () << \" \\n \" ; #pragma omp task { std :: cout << \"Estou rodando na thread:\" << omp_get_thread_num () << \" \\n \" ; } } } Question Quantas tarefas s\u00e3o criadas no exemplo acima? Elas rodam em qual thread? Responda somente lendo o c\u00f3digo e depois confirme sua resposta rodando exemplo3.cpp . Question Execute exemplo3.cpp diversas vezes. Os resultados s\u00e3o sempre iguais? Por que? Example Complete exercicio1.cpp criando duas tarefas. A primeira dever\u00e1 rodar funcao1 e a segunda funcao2 . Salve seus resultados nas vari\u00e1veis indicadas no c\u00f3digo. Question Leia o c\u00f3digo e responda. Quanto tempo o c\u00f3digo sequencial demora? E o paralelo? Verifique que sua implementa\u00e7\u00e3o est\u00e1 de acordo com suas expectativas. Problema pr\u00e1tico \u00b6 Vamos agora para um exemplo pr\u00e1tico. O c\u00f3digo pi-numeric-integration.cpp calcula o pi usando uma t\u00e9cnica chamada integra\u00e7\u00e3o num\u00e9rica. Question Examine o arquivo acima. Onde haveriam oportunidades de paraleliza\u00e7\u00e3o? Question Suponha que voc\u00ea ir\u00e1 tentar dividir os c\u00e1lculos do programa em duas partes. Como voc\u00ea faria isso? Example Fa\u00e7a a divis\u00e3o do c\u00e1lculo do pi em duas tarefas. Sua primeira tarefa dever\u00e1 guardar seu resultado na vari\u00e1vel res_parte1 . A segunda tarefa dever\u00e1 guardar seu resultado na vari\u00e1vel res_parte2 . Voc\u00ea dever\u00e1 somar os dois resultados ap\u00f3s as tarefas acabarem. Question Me\u00e7a o tempo do programa paralelizado e compare com o original. Verifique tamb\u00e9m que os resultados continuam iguais.","title":"12 - Introdu\u00e7\u00e3o a OpenMP"},{"location":"aulas/12-introducao-omp/#12-introducao-a-openmp","text":"OpenMP \u00e9 uma tecnologia de computa\u00e7\u00e3o multi-core usada para paralelizar programas. Sua principal vantagem \u00e9 oferecer uma transi\u00e7\u00e3o suave entre c\u00f3digo sequencial e c\u00f3digo paralelo.","title":"12 - Introdu\u00e7\u00e3o a OpenMP"},{"location":"aulas/12-introducao-omp/#primeiros-passos","text":"Nesta parte do roteiro usaremos 4 chamadas do OpenMP para criar nossas primeiras threads. #pragma omp parallel cria um conjunto de threads. Deve ser aplicado acima de um bloco de c\u00f3digo limitado por { } int omp_get_num_threads(); retorna o n\u00famero de threads criadas (dentro de uma regi\u00e3o paralela) int omp_get_max_threads(); retorna o n\u00famero de m\u00e1ximo de threads (fora de uma regi\u00e3o paralela) int omp_get_thread_num(); retorna o id da thread atual (entre 0 e o valor acima, dentro de uma regi\u00e3o paralela) O c\u00f3digo abaixo ( exemplo1.cpp ) ilustra como utilizar OpenMP para criar um conjunto de threads que rodam em paralelo. #pragma omp parallel { std :: cout << \"ID:\" << omp_get_thread_num () << \"/\" << omp_get_num_threads () << \" \\n \" ; } Vamos agora fazer alguns experimentos com esse exemplo b\u00e1sico para entender como OpenMP funciona. Example Compile o programa de exemplo usando a seguinte linha de comando e rode-o. $ g++ -O3 exemplo1.cpp -o exemplo1 -fopenmp Question O OpenMP permite alterar o n\u00famero m\u00e1ximo de threads criados usando a vari\u00e1vel de ambiente OMP_NUM_THREADS . Rode exemplo1 como abaixo. OMP_NUM_THREADS=2 ./exemplo1 Quantas threads foram criadas? Question Rode agora sem a vari\u00e1vel de ambiente. Qual \u00e9 o valor padr\u00e3o assumido pelo OpenMP? \u00c9 uma boa ideia usar mais threads que o valor padr\u00e3o? A utiliza\u00e7\u00e3o de OMP_NUM_THREADS ajuda a realizar testes de modo a compreender os ganhos de desempenho de um programa conforme mais threads s\u00e3o utilizadas. Quando uma regi\u00e3o paralela inicia s\u00e3o criadas OMP_NUM_THREADS threads e cada uma roda o bloco de c\u00f3digo imediatamente abaixo de maneira independents. Question No trecho abaixo, quantas c\u00f3pias da vari\u00e1vel temp s\u00e3o criadas? E da vari\u00e1vel res ? Responda usando o n\u00famero de cores da m\u00e1quina como refer\u00eancia. double res = 0 ; #pragma omp parallel { double temp = 10 ; res *= temp ; } Resposta S\u00f3 uma vari\u00e1vel res existe, pois ela foi declarada fora da regi\u00e3o paralela. Existem N c\u00f3pias de temp , uma criada para cada thread existente. Question Voc\u00ea consegue prever o resultado do c\u00f3digo abaixo? Se sim, qual sua sa\u00edda? Se n\u00e3o, voc\u00ea consegue explicar o por que? int res = 1 ; #pragma omp parallel { for ( int i = 0 ; i < 10000 ; i ++ ) { res += 1 ; } } Example Rode o c\u00f3digo acima (arquivo exemplo2.cpp ) e veja se suas expectativas se cumprem. Aproveite e verifique se o programa retorna o mesmo resultado se executado v\u00e1rias vezes. Chame o professor se voc\u00ea se surpreender com o resultado. Resposta O c\u00f3digo dar\u00e1 resultados estranhos, com res n\u00e3o assumindo o valor N * 10000 . Quanto maior o n\u00famero de threads mais distante do correto o valor resultante ser\u00e1. Example Mude o limite do for para 1000 . Os resultados agora s\u00e3o os esperados? Por que? Danger Nos dois exemplos acima as vari\u00e1veis res eram usadas por m\u00faltiplas threads! Ou seja, cada thread possui uma depend\u00eancia em rela\u00e7\u00e3o a res . Escrever c\u00f3digo sem levar em conta as depend\u00eancias \u00e9 um problema que ser\u00e1 abordado nas pr\u00f3ximas aulas.","title":"Primeiros passos"},{"location":"aulas/12-introducao-omp/#paralelismo-de-tarefas","text":"Vamos agora criar tarefas que podem ser executadas em paralelo. Defini\u00e7\u00e3o Uma tarefa \u00e9 um bloco de c\u00f3digo que \u00e9 rodado de maneira paralela usando OpenMP. Tarefas s\u00e3o alocadas para cada uma das threads criadas em um regi\u00e3o paralela. N\u00e3o existe uma associa\u00e7\u00e3o 1-1 entre threads e tarefas . Posso ter mais tarefas que threads e mais threads que tarefas . Veja abaixo um exemplo de cria\u00e7\u00e3o de tarefas. #pragma omp parallel { #pragma omp task { std :: cout << \"Estou rodando na tarefa \" << omp_get_thread_num () << \" \\n \" ; } } std :: cout << \"eu s\u00f3 rodo quanto TODAS tarefas acabarem. \\n \" ; Question O exemplo acima cria quantas tarefas, supondo que OMP_NUM_THREADS=4 ? Para controlar a cria\u00e7\u00e3o de tarefas em geral usamos a diretiva master , que executa somente na thread de \u00edndice 0 . #pragma omp parallel { #pragma omp master { std :: cout << \"s\u00f3 roda uma vez na thread:\" << omp_get_thread_num () << \" \\n \" ; #pragma omp task { std :: cout << \"Estou rodando na thread:\" << omp_get_thread_num () << \" \\n \" ; } } } Question Quantas tarefas s\u00e3o criadas no exemplo acima? Elas rodam em qual thread? Responda somente lendo o c\u00f3digo e depois confirme sua resposta rodando exemplo3.cpp . Question Execute exemplo3.cpp diversas vezes. Os resultados s\u00e3o sempre iguais? Por que? Example Complete exercicio1.cpp criando duas tarefas. A primeira dever\u00e1 rodar funcao1 e a segunda funcao2 . Salve seus resultados nas vari\u00e1veis indicadas no c\u00f3digo. Question Leia o c\u00f3digo e responda. Quanto tempo o c\u00f3digo sequencial demora? E o paralelo? Verifique que sua implementa\u00e7\u00e3o est\u00e1 de acordo com suas expectativas.","title":"Paralelismo de tarefas"},{"location":"aulas/12-introducao-omp/#problema-pratico","text":"Vamos agora para um exemplo pr\u00e1tico. O c\u00f3digo pi-numeric-integration.cpp calcula o pi usando uma t\u00e9cnica chamada integra\u00e7\u00e3o num\u00e9rica. Question Examine o arquivo acima. Onde haveriam oportunidades de paraleliza\u00e7\u00e3o? Question Suponha que voc\u00ea ir\u00e1 tentar dividir os c\u00e1lculos do programa em duas partes. Como voc\u00ea faria isso? Example Fa\u00e7a a divis\u00e3o do c\u00e1lculo do pi em duas tarefas. Sua primeira tarefa dever\u00e1 guardar seu resultado na vari\u00e1vel res_parte1 . A segunda tarefa dever\u00e1 guardar seu resultado na vari\u00e1vel res_parte2 . Voc\u00ea dever\u00e1 somar os dois resultados ap\u00f3s as tarefas acabarem. Question Me\u00e7a o tempo do programa paralelizado e compare com o original. Verifique tamb\u00e9m que os resultados continuam iguais.","title":"Problema pr\u00e1tico"},{"location":"aulas/13-paralelismo-dados/","text":"13 - Paralelismo de dados \u00b6 Nesta pr\u00e1tica iremos usar a contru\u00e7\u00e3o omp parallel for para tratar casos de paralelismo de dados. O for paralelo \u00b6 Vamos come\u00e7ar nosso estudo do for paralelo executando alguns programas e entendendo como essa constru\u00e7\u00e3o divide as itera\u00e7\u00f5es entre threads. Question Voc\u00ea consegue predizer o resultado do c\u00f3digo abaixo? Se sim, qual seria sua sa\u00edda? Se n\u00e3o, explique por que. #pragma omp parallel for for ( int i = 0 ; i < 16 ; i ++ ) { std :: cout << \"Eu rodei na thread: \" << omp_get_thread_num () << \" \\n \" ; } Example O c\u00f3digo acima est\u00e1 no programa exemplo1.cpp . Execute-o v\u00e1rias vezes e veja se sua resposta acima \u00e9 condizente com a realidade. Resposta N\u00e3o \u00e9 poss\u00edvel predizer. No caso acima o loop foi dividido igualmente entre as threads, mas isso \u00e9 uma decis\u00e3o do compilador e n\u00e3o temos controle sobre qual ser\u00e1 seu comportamento. Isso pode variar de compilador para compilador. O comportamento autom\u00e1tico funciona bem na maioria das vezes. Question Examine o c\u00f3digo abaixo e responda. #pragma omp parallel for schedule(dynamic, 4) for ( int i = 0 ; i < 16 ; i ++ ) { std :: cout << \"Eu rodei na thread: \" << omp_get_thread_num () << \" \\n \" ; } Quantos cores, no m\u00e1ximo, ser\u00e3o usados? Voc\u00ea consegue dizer em qual thread cada itera\u00e7\u00e3o rodar\u00e1? Voc\u00ea consegue dizer quantas itera\u00e7\u00f5es cada thread rodar\u00e1? Suponha que a thread 4 iniciou a itera\u00e7\u00e3o i=4 . Ela processar\u00e1 somente essa itera\u00e7\u00e3o isoladamente? Se sim, explique por que. Se n\u00e3o, diga at\u00e9 qual valor de i ela executar\u00e1. As aloca\u00e7\u00f5es mudam a cada execu\u00e7\u00e3o do programa? Example O c\u00f3digo acima est\u00e1 no programa exemplo2.cpp . Execute-o v\u00e1rias vezes e veja se sua resposta acima \u00e9 condizente com a realidade. Question Examine o c\u00f3digo abaixo e responda. #pragma omp parallel for schedule(static, 4) for ( int i = 0 ; i < 16 ; i ++ ) { std :: cout << \"Eu rodei na thread: \" << omp_get_thread_num () << \" \\n \" ; } Quantos cores, no m\u00e1ximo, ser\u00e3o usados? Voc\u00ea consegue dizer em qual thread cada itera\u00e7\u00e3o rodar\u00e1? Voc\u00ea consegue dizer quantas itera\u00e7\u00f5es cada thread rodar\u00e1? As aloca\u00e7\u00f5es mudam a cada execu\u00e7\u00e3o do programa? Example O c\u00f3digo acima est\u00e1 no programa exemplo3.cpp . Execute-o v\u00e1rias vezes e veja se sua resposta acima \u00e9 condizente com a realidade. Vamos agora aplicar esses conhecimentos no exemplo do c\u00e1lculo do pi da aula passada. Example Modifique o c\u00f3digo sequencial para usar as constru\u00e7\u00f5es parallel for e reduce . Os resultados se mantiveram iguais? E o tempo? Example Multiplique num_steps por 10 e tente novamente. E agora? Os ganhos s\u00e3o mais aparentes? Se voc\u00ea achou f\u00e1cil \u00e9 por que \u00e9 mesmo. OpenMP \u00e9 ideal para situa\u00e7\u00f5es como esta: pouca ou nenhuma depend\u00eancia de dados pouca ou nenhuma sincroniza\u00e7\u00e3o loop que roda uma grande quantidade de vezes o mesmo c\u00f3digo. Tamb\u00e9m vimos a maior vantagem do OpenMP : uma pequena modifica\u00e7\u00e3o no c\u00f3digo produz paralelismo eficiente. O maior desafio \u00e9 entender onde est\u00e3o as oportunidades de paralelismo . Com isso identificado, adicionar as anota\u00e7\u00f5es no c\u00f3digo \u00e9 r\u00e1pido. Exerc\u00edcio pr\u00e1tico \u00b6 Vamos agora trabalhar com imagens e paralelizar alguns processamentos de imagem. A ideia ser\u00e1 programar alguns processamentos simples e verificar se o OpenMP traz ganhos de desempenho. Nossa primeira opera\u00e7\u00e3o ser\u00e1 adicionar ru\u00eddo a uma imagem . Isto \u00e9 um pr\u00e9-processamento comum feito para testar a robustez de algoritmos de processamento de imagens a pequenos defeitos. Nosso algoritmo ser\u00e1 o seguinte: para cada ponto da imagem sortearemos um n\u00famero entre 1 e 10 inclusive. Se o n\u00famero for 1 a cor atual deve ser substitu\u00edda por preto. Se o n\u00famero for 10 a cor atual deve ser substitu\u00edda por branco. Caso contr\u00e1rio n\u00e3o mexa na cor atual. Question Examine o cabe\u00e7alho imagem.hpp e verifique como usar a classe Imagem . Onde est\u00e3o armazenados o tamanho da imagem? E os pontos? Como acessar o elemento i, j da imagem? Qual \u00e9 o valor de um pixel branco? E de um pixel preto? Example Fa\u00e7a uma vers\u00e3o sequencial do algoritmo acima, colocando sua solu\u00e7\u00e3o no arquivo exercicio1.cpp . Teste-a com as imagens da pasta atual e veja se as sa\u00eddas incluem pontos brancos/pretos. Vamos agora tentar paralelizar seu programa acima. Question Identique quais partes do programa s\u00e3o paraleliz\u00e1veis. Existe alguma depend\u00eancia de dados? Qual? Question \u00c9 poss\u00edvel desfazer a depend\u00eancia acima? Ou ao menos evitar que ela estrague nosso programa? Como voc\u00ea faria isso? Resposta O gerador de n\u00fameros aleat\u00f3rios depende da ordem de uso para funcionar! Se as itera\u00e7\u00f5es rodarem fora de ordem ent\u00e3o o resultado do nosso programa ser\u00e1 imprevis\u00edvel! Example Antes de prosseguir, tente paralelizar seu programa usando OpenMP. Por enquanto, ignore as depend\u00eancias identificadas acima e finja que tudo dar\u00e1 certo. Question Execute o programa paralelo duas vezes. Os resultados s\u00e3o id\u00eanticos? E se executar o programa sequencial? Nossa solu\u00e7\u00e3o ser\u00e1 baseada em \"enganar\" o gerador de n\u00fameros aleat\u00f3rios para que ele continue gerando n\u00fameros a partir de um certo local de sua sequ\u00eancia. Question Na itera\u00e7\u00e3o i=300 do seu c\u00f3digo anterior, quantos n\u00fameros aleat\u00f3rios j\u00e1 foram gerados? Resposta J\u00e1 foram gerados 299 n\u00fameros. Question Veja a documenta\u00e7\u00e3o do m\u00e9todo discard de default random engine . Como esse m\u00e9todo pode nos ajudar? Resposta Podemos criar um novo gerador a cada passo e avan\u00e7\u00e1-lo para onde ele estaria no c\u00f3digo sequencial. Example Implemente o programa da resposta acima. Voc\u00ea dever\u00e1 usar discard para que os resultados sejam id\u00eanticos aos do programa sequencial. Danger Se seu programa ficou muito mais lento mas resultados id\u00eanticos, prossiga. Question Volte na documenta\u00e7\u00e3o de discard e procure por sua complexidade computacional. Voc\u00ea consegue explicar a raz\u00e3o do programa ter ficado mais lento? Done Se voc\u00ea chegou at\u00e9 aqui ent\u00e3o finalizamos nossa aula. Apesar de parecer simples, utilizar OpenMP para paralelizar c\u00f3digo pode ser bastante complexo. Isso \u00e9 especialmente verdade conforme nosso c\u00f3digo tem mais depend\u00eancias de dados. Na pr\u00f3xima aula falaremos de algumas t\u00e9cnicas que podemos usar para melhorar nossos programas.","title":"13 - Paralelismo de dados"},{"location":"aulas/13-paralelismo-dados/#13-paralelismo-de-dados","text":"Nesta pr\u00e1tica iremos usar a contru\u00e7\u00e3o omp parallel for para tratar casos de paralelismo de dados.","title":"13 - Paralelismo de dados"},{"location":"aulas/13-paralelismo-dados/#o-for-paralelo","text":"Vamos come\u00e7ar nosso estudo do for paralelo executando alguns programas e entendendo como essa constru\u00e7\u00e3o divide as itera\u00e7\u00f5es entre threads. Question Voc\u00ea consegue predizer o resultado do c\u00f3digo abaixo? Se sim, qual seria sua sa\u00edda? Se n\u00e3o, explique por que. #pragma omp parallel for for ( int i = 0 ; i < 16 ; i ++ ) { std :: cout << \"Eu rodei na thread: \" << omp_get_thread_num () << \" \\n \" ; } Example O c\u00f3digo acima est\u00e1 no programa exemplo1.cpp . Execute-o v\u00e1rias vezes e veja se sua resposta acima \u00e9 condizente com a realidade. Resposta N\u00e3o \u00e9 poss\u00edvel predizer. No caso acima o loop foi dividido igualmente entre as threads, mas isso \u00e9 uma decis\u00e3o do compilador e n\u00e3o temos controle sobre qual ser\u00e1 seu comportamento. Isso pode variar de compilador para compilador. O comportamento autom\u00e1tico funciona bem na maioria das vezes. Question Examine o c\u00f3digo abaixo e responda. #pragma omp parallel for schedule(dynamic, 4) for ( int i = 0 ; i < 16 ; i ++ ) { std :: cout << \"Eu rodei na thread: \" << omp_get_thread_num () << \" \\n \" ; } Quantos cores, no m\u00e1ximo, ser\u00e3o usados? Voc\u00ea consegue dizer em qual thread cada itera\u00e7\u00e3o rodar\u00e1? Voc\u00ea consegue dizer quantas itera\u00e7\u00f5es cada thread rodar\u00e1? Suponha que a thread 4 iniciou a itera\u00e7\u00e3o i=4 . Ela processar\u00e1 somente essa itera\u00e7\u00e3o isoladamente? Se sim, explique por que. Se n\u00e3o, diga at\u00e9 qual valor de i ela executar\u00e1. As aloca\u00e7\u00f5es mudam a cada execu\u00e7\u00e3o do programa? Example O c\u00f3digo acima est\u00e1 no programa exemplo2.cpp . Execute-o v\u00e1rias vezes e veja se sua resposta acima \u00e9 condizente com a realidade. Question Examine o c\u00f3digo abaixo e responda. #pragma omp parallel for schedule(static, 4) for ( int i = 0 ; i < 16 ; i ++ ) { std :: cout << \"Eu rodei na thread: \" << omp_get_thread_num () << \" \\n \" ; } Quantos cores, no m\u00e1ximo, ser\u00e3o usados? Voc\u00ea consegue dizer em qual thread cada itera\u00e7\u00e3o rodar\u00e1? Voc\u00ea consegue dizer quantas itera\u00e7\u00f5es cada thread rodar\u00e1? As aloca\u00e7\u00f5es mudam a cada execu\u00e7\u00e3o do programa? Example O c\u00f3digo acima est\u00e1 no programa exemplo3.cpp . Execute-o v\u00e1rias vezes e veja se sua resposta acima \u00e9 condizente com a realidade. Vamos agora aplicar esses conhecimentos no exemplo do c\u00e1lculo do pi da aula passada. Example Modifique o c\u00f3digo sequencial para usar as constru\u00e7\u00f5es parallel for e reduce . Os resultados se mantiveram iguais? E o tempo? Example Multiplique num_steps por 10 e tente novamente. E agora? Os ganhos s\u00e3o mais aparentes? Se voc\u00ea achou f\u00e1cil \u00e9 por que \u00e9 mesmo. OpenMP \u00e9 ideal para situa\u00e7\u00f5es como esta: pouca ou nenhuma depend\u00eancia de dados pouca ou nenhuma sincroniza\u00e7\u00e3o loop que roda uma grande quantidade de vezes o mesmo c\u00f3digo. Tamb\u00e9m vimos a maior vantagem do OpenMP : uma pequena modifica\u00e7\u00e3o no c\u00f3digo produz paralelismo eficiente. O maior desafio \u00e9 entender onde est\u00e3o as oportunidades de paralelismo . Com isso identificado, adicionar as anota\u00e7\u00f5es no c\u00f3digo \u00e9 r\u00e1pido.","title":"O for paralelo"},{"location":"aulas/13-paralelismo-dados/#exercicio-pratico","text":"Vamos agora trabalhar com imagens e paralelizar alguns processamentos de imagem. A ideia ser\u00e1 programar alguns processamentos simples e verificar se o OpenMP traz ganhos de desempenho. Nossa primeira opera\u00e7\u00e3o ser\u00e1 adicionar ru\u00eddo a uma imagem . Isto \u00e9 um pr\u00e9-processamento comum feito para testar a robustez de algoritmos de processamento de imagens a pequenos defeitos. Nosso algoritmo ser\u00e1 o seguinte: para cada ponto da imagem sortearemos um n\u00famero entre 1 e 10 inclusive. Se o n\u00famero for 1 a cor atual deve ser substitu\u00edda por preto. Se o n\u00famero for 10 a cor atual deve ser substitu\u00edda por branco. Caso contr\u00e1rio n\u00e3o mexa na cor atual. Question Examine o cabe\u00e7alho imagem.hpp e verifique como usar a classe Imagem . Onde est\u00e3o armazenados o tamanho da imagem? E os pontos? Como acessar o elemento i, j da imagem? Qual \u00e9 o valor de um pixel branco? E de um pixel preto? Example Fa\u00e7a uma vers\u00e3o sequencial do algoritmo acima, colocando sua solu\u00e7\u00e3o no arquivo exercicio1.cpp . Teste-a com as imagens da pasta atual e veja se as sa\u00eddas incluem pontos brancos/pretos. Vamos agora tentar paralelizar seu programa acima. Question Identique quais partes do programa s\u00e3o paraleliz\u00e1veis. Existe alguma depend\u00eancia de dados? Qual? Question \u00c9 poss\u00edvel desfazer a depend\u00eancia acima? Ou ao menos evitar que ela estrague nosso programa? Como voc\u00ea faria isso? Resposta O gerador de n\u00fameros aleat\u00f3rios depende da ordem de uso para funcionar! Se as itera\u00e7\u00f5es rodarem fora de ordem ent\u00e3o o resultado do nosso programa ser\u00e1 imprevis\u00edvel! Example Antes de prosseguir, tente paralelizar seu programa usando OpenMP. Por enquanto, ignore as depend\u00eancias identificadas acima e finja que tudo dar\u00e1 certo. Question Execute o programa paralelo duas vezes. Os resultados s\u00e3o id\u00eanticos? E se executar o programa sequencial? Nossa solu\u00e7\u00e3o ser\u00e1 baseada em \"enganar\" o gerador de n\u00fameros aleat\u00f3rios para que ele continue gerando n\u00fameros a partir de um certo local de sua sequ\u00eancia. Question Na itera\u00e7\u00e3o i=300 do seu c\u00f3digo anterior, quantos n\u00fameros aleat\u00f3rios j\u00e1 foram gerados? Resposta J\u00e1 foram gerados 299 n\u00fameros. Question Veja a documenta\u00e7\u00e3o do m\u00e9todo discard de default random engine . Como esse m\u00e9todo pode nos ajudar? Resposta Podemos criar um novo gerador a cada passo e avan\u00e7\u00e1-lo para onde ele estaria no c\u00f3digo sequencial. Example Implemente o programa da resposta acima. Voc\u00ea dever\u00e1 usar discard para que os resultados sejam id\u00eanticos aos do programa sequencial. Danger Se seu programa ficou muito mais lento mas resultados id\u00eanticos, prossiga. Question Volte na documenta\u00e7\u00e3o de discard e procure por sua complexidade computacional. Voc\u00ea consegue explicar a raz\u00e3o do programa ter ficado mais lento? Done Se voc\u00ea chegou at\u00e9 aqui ent\u00e3o finalizamos nossa aula. Apesar de parecer simples, utilizar OpenMP para paralelizar c\u00f3digo pode ser bastante complexo. Isso \u00e9 especialmente verdade conforme nosso c\u00f3digo tem mais depend\u00eancias de dados. Na pr\u00f3xima aula falaremos de algumas t\u00e9cnicas que podemos usar para melhorar nossos programas.","title":"Exerc\u00edcio pr\u00e1tico"},{"location":"aulas/14-efeitos-colaterais/","text":"14 - Efeitos colaterais \u00b6 Nesta aula iremos aprender a controlar os efeitos colaterais de programas paralelos. Nossa estrat\u00e9gia se basear\u00e1 na ideia de que o resultado de um programa paralelo dever\u00e1 se manter igual em toda execu\u00e7\u00e3o, a n\u00e3o ser que explicitamente seja pedido o contr\u00e1rio. Geradores de n\u00fameros aleat\u00f3rios \u00b6 Na \u00faltima aula vimos que nossa implementa\u00e7\u00e3o de discard era O(N) , o que tornava nosso algoritmo O(N^2) O(N^2) e invalidava qualquer ganho vindo do paralelismo. Vamos ent\u00e3o abdicar de uma implementa\u00e7\u00e3o literalmente igual \u00e0 sequencial e tomar como boa uma implementa\u00e7\u00e3o que, mantendo fixo o n\u00famero de threads, retorna sempre os mesmos resultados. Ou seja, adicionamos como par\u00e2metro do programa o n\u00famero de threads a serem usadas. Se mantivermos os mesmos par\u00e2metros (agora incluindo n\u00famero de threads) os resultados ser\u00e3o mantidos. Claramente n\u00e3o \u00e9 o ideal, mas \u00e9 suficiente se formos expl\u00edcitos nessa condi\u00e7\u00e3o. Lembrando que um dos nossos objetivos \u00e9 ganhar desempenho mantendo a previsibilidade e a reprodutibilidade. Nossa ideia ser\u00e1 ent\u00e3o, criar um gerador de n\u00fameros aleat\u00f3rios por thread. Question Explique por que esta ideia controla os efeitos colaterais. Quais funcionalidades do OpenMP nos ajudariam a fazer isto? Resposta Ao criar um gerador para cada thread evitamos o acesso desordenado a um \u00fanico gerador. Com somente um gerador global precisar\u00edamos for\u00e7ar uma ordem completa para ter resultados reprodut\u00edveis (j\u00e1 que n\u00e3o controlamos quando cada thread roda). Com um gerador por thread conseguimos garantir que cada thread ver\u00e1 sempre a mesma sequ\u00eancia de n\u00fameros. Faltaria s\u00f3 garantir que cada thread executa sempre as mesmas itera\u00e7\u00f5es do loop. Isso pode ser feito usando o agendamento static do for paralelo. Example Implemente a ideia descrita acima. Voc\u00ea pode quebrar nos seguintes passos: criar um gerador para cada thread. Use omp_get_max_threads para saber o m\u00e1ximo de threads cri\u00e1veis durante a execu\u00e7\u00e3o. use uma seed diferente para cada gerador. Voc\u00ea pode usar alguma conta relacionada ao id da thread para isto. dentro do loop, acesse somente o gerador da thread em execu\u00e7\u00e3o. Veja como pegar esse id nos exemplos da aula passada Question Execute diversas vezes o programa acima. Os resultados se mant\u00e9m? Use a imagem1.pgm como teste. Question Teste agora rodando com 3 threads. Os resultados se mant\u00e9m? Eles s\u00e3o iguais ao item anterior? Sincroniza\u00e7\u00e3o com regi\u00f5es cr\u00edticas \u00b6 Na expositiva vimos v\u00e1rios conceitos. Vamos agora ver sua execu\u00e7\u00e3o no OpenMP. O snippet abaixo mostra como indicar um bloco de c\u00f3digo como se\u00e7\u00e3o cr\u00edtica. #pragma omp critical { // s\u00f3 uma thread entra por vez } Os principais usos s\u00e3o: trabalhar com arquivos e entrada/sa\u00edda. Muito comum para acessar o terminal ou para arquivos de log; usar classes ou estruturas de dados complexas. Acessos de escrita a vetores ou dicion\u00e1rios, por exemplo; realizar opera\u00e7\u00f5es lentas que n\u00e3o podem ser interrompidas. Example Abra novamente o exemplo1.cpp da aula passada. Ao execut\u00e1-lo \u00e9 comum que os prints saiam embaralhados. Use critical para ter acesso exclusivo ao terminal e evitar isso. Vamos agora aprender exatamente como usar vari\u00e1veis compartilhadas e a diretiva critical para fazer o mesmo trabalho que a direriva reduction . Apesar de estarmos teoricamente reproduzindo um trabalho j\u00e1 bem implementado, temos duas vantagens pedag\u00f3gicas: conseguimos conferir a qualidade de nossos resultados rapidamente as t\u00e9cnicas usadas s\u00e3o aplic\u00e1veis tamb\u00e9m para paralelismo de tarefas reduction s\u00f3 funciona dentro de um for paralelo em que a vari\u00e1vel for um tipo b\u00e1sico. Podemos precisar de redu\u00e7\u00f5es com mais de uma vari\u00e1vel ou de um struct , por exemplo. Example Para fazermos compara\u00e7\u00f5es e deixarmos nossos experimentos organizados, crie uma fun\u00e7\u00e3o pi_sequencial(long num_steps) que calcula o pi sequencialmente. Nos pr\u00f3ximos exerc\u00edcios iremos criar vers\u00f5es paralelas do c\u00e1lculo do pi explorando constru\u00e7\u00f5es de sincroniza\u00e7\u00e3o do OpenMP para melhorar nosso desempenho. Question Um dos problemas de n\u00e3o usarmos a cl\u00e1usula reduction \u00e9 que acessos simult\u00e2neos a sum estragam seu valor (pois += n\u00e3o \u00e9 representado por apenas uma instru\u00e7\u00e3o em Assembly). Explique como critical pode ser usado para resolver este problema. Example Crie uma fun\u00e7\u00e3o pi_omp_critical1 que usa critical da maneira explicada acima para resolver os problemas de compartilhamento. Verifique que os resultados num\u00e9ricos continuam iguais. Question Voc\u00ea consegue explicar o desempenho do programa acima? Resposta A utiliza\u00e7\u00e3o de critical \u00e9 cara. Cada vez que uma thread chega na regi\u00e3o cr\u00edtica ela gasta tempo de processamento. Ou seja, entrar na regi\u00e3o cr\u00edtica muito frequentemente resulta em gastar tempo precioso em sincroniza\u00e7\u00e3o ao inv\u00e9s de gastar resolvendo nosso problema. Tip Sincroniza\u00e7\u00e3o \u00e9 caro e \u00e9 um custo relevante de qualquer projeto de alto desempenho que n\u00e3o seja ingenuamente paraleliz\u00e1vel. Nosso objetivo \u00e9 sempre quere minimizar a sincroniza\u00e7\u00e3o feita pelas threads. Tendo em vista o quadro acima, fa\u00e7a os pr\u00f3ximos exerc\u00edcios. Question Na parte 1 usamos a estrat\u00e9gia de criar uma c\u00f3pia do gerador de n\u00fameros aleat\u00f3rios para cada thread. Como poderiamos adaptar esta ideia para evitar o uso da regi\u00e3o cr\u00edtica? Resposta Basta novamente criar uma c\u00f3pia para cada thread e acumular os resultados na c\u00f3pia. Essa aloca\u00e7\u00e3o dever\u00e1 ser feita antes do in\u00edcio da regi\u00e3o paralela. Ao finalizar podemos simplesmente somar as somas parciais e tudo estar\u00e1 OK. Example Implemente a ideia acima e chame sua fun\u00e7\u00e3o de pi_omp_copias_parciais . Verifique que os valores continuam iguais. Question Me\u00e7a o tempo acima e verifique que houve ganho de desempenho em rela\u00e7\u00e3o ao uso de critical . A solu\u00e7\u00e3o acima \u00e9 funcional mas inconveniente: precisamos ficar alocando arrays a cada regi\u00e3o paralela e depois ficar somando tudo no final. Podemos eliminar esse vetor separando as diretivas parallel e for e tornar nosso c\u00f3digo mais enxuto e leg\u00edvel. Veja abaixo um exemplo. #pragma omp parallel { double local ; #pragma omp for for (...) { // cada thread mexe na sua c\u00f3pia de local } } Question Como voc\u00ea usaria a estrutura acima para chamar critical somente uma vez por thread? Explique por que sua solu\u00e7\u00e3o funciona e por que ela dever\u00e1 trazer grandes ganhos de desempenho. Example Implemente sua fun\u00e7\u00e3o como pi_omp_critical_local e verifique que os resultados continuam corretos. Question Me\u00e7a novamente o tempo de execu\u00e7\u00e3o. Como essa fun\u00e7\u00e3o se compara com as outras implementa\u00e7\u00f5es? Done Finalizamos esta atividade com a seguinte conclus\u00e3o: sincroniza\u00e7\u00e3o \u00e9 cara, mas por vezes \u00e9 o melhor que temos . Se precisamos fazer uma opera\u00e7\u00e3o que torna um bloco de c\u00f3digo uma regi\u00e3o cr\u00edtica , ent\u00e3o n\u00e3o temos op\u00e7\u00e3o e tudo o que podemos \u00e9 tornar essa regi\u00e3o o menor poss\u00edvel e somente entrar nela quando for estritamente necess\u00e1rio .","title":"14 - Efeitos colaterais"},{"location":"aulas/14-efeitos-colaterais/#14-efeitos-colaterais","text":"Nesta aula iremos aprender a controlar os efeitos colaterais de programas paralelos. Nossa estrat\u00e9gia se basear\u00e1 na ideia de que o resultado de um programa paralelo dever\u00e1 se manter igual em toda execu\u00e7\u00e3o, a n\u00e3o ser que explicitamente seja pedido o contr\u00e1rio.","title":"14 - Efeitos colaterais"},{"location":"aulas/14-efeitos-colaterais/#geradores-de-numeros-aleatorios","text":"Na \u00faltima aula vimos que nossa implementa\u00e7\u00e3o de discard era O(N) , o que tornava nosso algoritmo O(N^2) O(N^2) e invalidava qualquer ganho vindo do paralelismo. Vamos ent\u00e3o abdicar de uma implementa\u00e7\u00e3o literalmente igual \u00e0 sequencial e tomar como boa uma implementa\u00e7\u00e3o que, mantendo fixo o n\u00famero de threads, retorna sempre os mesmos resultados. Ou seja, adicionamos como par\u00e2metro do programa o n\u00famero de threads a serem usadas. Se mantivermos os mesmos par\u00e2metros (agora incluindo n\u00famero de threads) os resultados ser\u00e3o mantidos. Claramente n\u00e3o \u00e9 o ideal, mas \u00e9 suficiente se formos expl\u00edcitos nessa condi\u00e7\u00e3o. Lembrando que um dos nossos objetivos \u00e9 ganhar desempenho mantendo a previsibilidade e a reprodutibilidade. Nossa ideia ser\u00e1 ent\u00e3o, criar um gerador de n\u00fameros aleat\u00f3rios por thread. Question Explique por que esta ideia controla os efeitos colaterais. Quais funcionalidades do OpenMP nos ajudariam a fazer isto? Resposta Ao criar um gerador para cada thread evitamos o acesso desordenado a um \u00fanico gerador. Com somente um gerador global precisar\u00edamos for\u00e7ar uma ordem completa para ter resultados reprodut\u00edveis (j\u00e1 que n\u00e3o controlamos quando cada thread roda). Com um gerador por thread conseguimos garantir que cada thread ver\u00e1 sempre a mesma sequ\u00eancia de n\u00fameros. Faltaria s\u00f3 garantir que cada thread executa sempre as mesmas itera\u00e7\u00f5es do loop. Isso pode ser feito usando o agendamento static do for paralelo. Example Implemente a ideia descrita acima. Voc\u00ea pode quebrar nos seguintes passos: criar um gerador para cada thread. Use omp_get_max_threads para saber o m\u00e1ximo de threads cri\u00e1veis durante a execu\u00e7\u00e3o. use uma seed diferente para cada gerador. Voc\u00ea pode usar alguma conta relacionada ao id da thread para isto. dentro do loop, acesse somente o gerador da thread em execu\u00e7\u00e3o. Veja como pegar esse id nos exemplos da aula passada Question Execute diversas vezes o programa acima. Os resultados se mant\u00e9m? Use a imagem1.pgm como teste. Question Teste agora rodando com 3 threads. Os resultados se mant\u00e9m? Eles s\u00e3o iguais ao item anterior?","title":"Geradores de n\u00fameros aleat\u00f3rios"},{"location":"aulas/14-efeitos-colaterais/#sincronizacao-com-regioes-criticas","text":"Na expositiva vimos v\u00e1rios conceitos. Vamos agora ver sua execu\u00e7\u00e3o no OpenMP. O snippet abaixo mostra como indicar um bloco de c\u00f3digo como se\u00e7\u00e3o cr\u00edtica. #pragma omp critical { // s\u00f3 uma thread entra por vez } Os principais usos s\u00e3o: trabalhar com arquivos e entrada/sa\u00edda. Muito comum para acessar o terminal ou para arquivos de log; usar classes ou estruturas de dados complexas. Acessos de escrita a vetores ou dicion\u00e1rios, por exemplo; realizar opera\u00e7\u00f5es lentas que n\u00e3o podem ser interrompidas. Example Abra novamente o exemplo1.cpp da aula passada. Ao execut\u00e1-lo \u00e9 comum que os prints saiam embaralhados. Use critical para ter acesso exclusivo ao terminal e evitar isso. Vamos agora aprender exatamente como usar vari\u00e1veis compartilhadas e a diretiva critical para fazer o mesmo trabalho que a direriva reduction . Apesar de estarmos teoricamente reproduzindo um trabalho j\u00e1 bem implementado, temos duas vantagens pedag\u00f3gicas: conseguimos conferir a qualidade de nossos resultados rapidamente as t\u00e9cnicas usadas s\u00e3o aplic\u00e1veis tamb\u00e9m para paralelismo de tarefas reduction s\u00f3 funciona dentro de um for paralelo em que a vari\u00e1vel for um tipo b\u00e1sico. Podemos precisar de redu\u00e7\u00f5es com mais de uma vari\u00e1vel ou de um struct , por exemplo. Example Para fazermos compara\u00e7\u00f5es e deixarmos nossos experimentos organizados, crie uma fun\u00e7\u00e3o pi_sequencial(long num_steps) que calcula o pi sequencialmente. Nos pr\u00f3ximos exerc\u00edcios iremos criar vers\u00f5es paralelas do c\u00e1lculo do pi explorando constru\u00e7\u00f5es de sincroniza\u00e7\u00e3o do OpenMP para melhorar nosso desempenho. Question Um dos problemas de n\u00e3o usarmos a cl\u00e1usula reduction \u00e9 que acessos simult\u00e2neos a sum estragam seu valor (pois += n\u00e3o \u00e9 representado por apenas uma instru\u00e7\u00e3o em Assembly). Explique como critical pode ser usado para resolver este problema. Example Crie uma fun\u00e7\u00e3o pi_omp_critical1 que usa critical da maneira explicada acima para resolver os problemas de compartilhamento. Verifique que os resultados num\u00e9ricos continuam iguais. Question Voc\u00ea consegue explicar o desempenho do programa acima? Resposta A utiliza\u00e7\u00e3o de critical \u00e9 cara. Cada vez que uma thread chega na regi\u00e3o cr\u00edtica ela gasta tempo de processamento. Ou seja, entrar na regi\u00e3o cr\u00edtica muito frequentemente resulta em gastar tempo precioso em sincroniza\u00e7\u00e3o ao inv\u00e9s de gastar resolvendo nosso problema. Tip Sincroniza\u00e7\u00e3o \u00e9 caro e \u00e9 um custo relevante de qualquer projeto de alto desempenho que n\u00e3o seja ingenuamente paraleliz\u00e1vel. Nosso objetivo \u00e9 sempre quere minimizar a sincroniza\u00e7\u00e3o feita pelas threads. Tendo em vista o quadro acima, fa\u00e7a os pr\u00f3ximos exerc\u00edcios. Question Na parte 1 usamos a estrat\u00e9gia de criar uma c\u00f3pia do gerador de n\u00fameros aleat\u00f3rios para cada thread. Como poderiamos adaptar esta ideia para evitar o uso da regi\u00e3o cr\u00edtica? Resposta Basta novamente criar uma c\u00f3pia para cada thread e acumular os resultados na c\u00f3pia. Essa aloca\u00e7\u00e3o dever\u00e1 ser feita antes do in\u00edcio da regi\u00e3o paralela. Ao finalizar podemos simplesmente somar as somas parciais e tudo estar\u00e1 OK. Example Implemente a ideia acima e chame sua fun\u00e7\u00e3o de pi_omp_copias_parciais . Verifique que os valores continuam iguais. Question Me\u00e7a o tempo acima e verifique que houve ganho de desempenho em rela\u00e7\u00e3o ao uso de critical . A solu\u00e7\u00e3o acima \u00e9 funcional mas inconveniente: precisamos ficar alocando arrays a cada regi\u00e3o paralela e depois ficar somando tudo no final. Podemos eliminar esse vetor separando as diretivas parallel e for e tornar nosso c\u00f3digo mais enxuto e leg\u00edvel. Veja abaixo um exemplo. #pragma omp parallel { double local ; #pragma omp for for (...) { // cada thread mexe na sua c\u00f3pia de local } } Question Como voc\u00ea usaria a estrutura acima para chamar critical somente uma vez por thread? Explique por que sua solu\u00e7\u00e3o funciona e por que ela dever\u00e1 trazer grandes ganhos de desempenho. Example Implemente sua fun\u00e7\u00e3o como pi_omp_critical_local e verifique que os resultados continuam corretos. Question Me\u00e7a novamente o tempo de execu\u00e7\u00e3o. Como essa fun\u00e7\u00e3o se compara com as outras implementa\u00e7\u00f5es? Done Finalizamos esta atividade com a seguinte conclus\u00e3o: sincroniza\u00e7\u00e3o \u00e9 cara, mas por vezes \u00e9 o melhor que temos . Se precisamos fazer uma opera\u00e7\u00e3o que torna um bloco de c\u00f3digo uma regi\u00e3o cr\u00edtica , ent\u00e3o n\u00e3o temos op\u00e7\u00e3o e tudo o que podemos \u00e9 tornar essa regi\u00e3o o menor poss\u00edvel e somente entrar nela quando for estritamente necess\u00e1rio .","title":"Sincroniza\u00e7\u00e3o com regi\u00f5es cr\u00edticas"},{"location":"projetos/","text":"Travelling Sales Person (TSP) \u00b6 Nosso projeto do semestre ser\u00e1 o Caixeiro Viajante . Neste problema recebemos uma lista de cidades representadas por suas coordenadas (x_i, y_i)_{i=0}^N (x_i, y_i)_{i=0}^N e temos como objetivo encontrar o o caminho fechado que visite todas as cidades tenha o menor comprimento poss\u00edvel Note que podemos come\u00e7ar de qualquer cidade, j\u00e1 que nosso caminho \u00e9 fechado. Ou seja, ele come\u00e7a e termina no mesmo lugar. Este \u00e9 um problema muito estudado em otimiza\u00e7\u00e3o e existem v\u00e1rios m\u00e9todos que proporcionam solu\u00e7\u00f5es muito boas em pouqu\u00edssimo tempo. Por exemplo, o Gif abaixo usa uma t\u00e9cnica de otimiza\u00e7\u00e3o chamada Simulated annealing . \u00c9 f\u00e1cil de perceber que este problema ocorre frequentemente em log\u00edsitca, seja na forma que apresentamos ou em sua generaliza\u00e7\u00e3o, o Roteamento de Ve\u00edculos . Por que escolhemos esse problema? \u00b6 O TSP \u00e9 um problema de otimiza\u00e7\u00e3o dos mais dif\u00edceis ( NP-hard ). N\u00e3o existe algoritmo polinomial que encontre a melhor solu\u00e7\u00e3o nem algoritmo polinomial que cheque se uma solu\u00e7\u00e3o \u00e9 a melhor. Entramos ent\u00e3o em duas \u00e1reas: encontrar a melhor solu\u00e7\u00e3o o mais r\u00e1pido poss\u00edvel usar heur\u00edsticas para encontrar uma solu\u00e7\u00e3o boa o mais r\u00e1pido poss\u00edvel Trabalharemos com ambas as ideias durante a disciplina, focando tanto em implementa\u00e7\u00f5es sequenciais como paralelas. Avalia\u00e7\u00e3o e formatos de entrada e sa\u00edda \u00b6 O projeto \u00e9 individual e ser\u00e1 corrigido usando uma s\u00e9rie de scripts de corre\u00e7\u00e3o automatizada. Entrada N x1 y1 .... xN yN N \u00e9 o n\u00famero de cidades xi yi s\u00e3o as coordenadas de cada cidade Sa\u00edda L O c1 .... cN L \u00e9 o comprimento do tour O indica se o tour \u00e9 \u00f3timo (1) ou n\u00e3o (0) c1 ... cN \u00e9 a sequ\u00eancia de cidades visitadas para chegar no tour de comprimento L Importante Os formatos de entrada e sa\u00edda dever\u00e3o ser respeitados de maneira estrita Algumas entregas pedir\u00e3o tamb\u00e9m informa\u00e7\u00f5es mostradas na sa\u00edda de erros std:cerr Os scripts de corre\u00e7\u00e3o ser\u00e3o atualizados durante o semestre. 4. Entregas e Datas importantes \u00b6 O projeto de voc\u00eas dever\u00e1 ser entregue via um reposit\u00f3rio Git privado criado especialmente para este fim. Ele ser\u00e1 criado a partir das respostas do formul\u00e1rio a seguir. Cada aluno ir\u00e1 adicionar sua solu\u00e7\u00e3o ao seu reposit\u00f3rio, que j\u00e1 ir\u00e1 conter os arquivos de corre\u00e7\u00e3o autom\u00e1tica. A entrega dever\u00e1 cumprir todos os itens do Checklist de projeto . As etapas do projeto ser\u00e3o disponibilizadas depois de discuss\u00f5es em sala de aula e estar\u00e3o conectadas com uma aula espec\u00edfica. Atividade 1 - heur\u00edstica da cidade mais pr\u00f3xima : Entrega 18/09 Atividade 2 - busca local - troca de ordem : Entrega 30/09 Atividade 3 - busca exaustiva : Entrega 13/10 Atividade 4 - implementa\u00e7\u00f5es sequenciais eficientes : Entrega 04/11 Verifica\u00e7\u00e3o de resultados \u00b6 Voc\u00ea receber\u00e1 um convite para reposit\u00f3rio. Todas as atividades ser\u00e3o disponibilizadas neste reposit\u00f3rio e suas solu\u00e7\u00f5es devem ser adicionadas nos arquivos correspondentes. O corretor autom\u00e1tico depende do pacote grading-tools , que dever\u00e1 ser instalado como abaixo. $> python3.8 -m pip install --user git+https://github.com/igordsm/grading-tools Python 3.8 no Ubuntu Se seu python3 \u00e9 uma vers\u00e3o inferior ao 3.8, voc\u00ea pode instal\u00e1-lo com os pacotes abaixo: python3.8 python3.8-dev A partir da\u00ed poder\u00e1 seguir normalmente as instru\u00e7\u00f5es desta p\u00e1gina. Com isso configurado, \u00e9 s\u00f3 compilar seu programa e rodar python3.8 corretor.py executavel . Para baixar os novos exerc\u00edcios \u00e9 s\u00f3 rodar git pull . Os exerc\u00edcios ser\u00e3o entregues criando um commit com sua resposta e dando git push . Warning Fique atento a atualiza\u00e7\u00f5es no seu reposit\u00f3rio de projeto. Atualiza\u00e7\u00f5es no corretor ser\u00e3o feitas ao longo do semestre, assim como ser\u00e3o disponibilizados novos arquivos de entrada/sa\u00edda para cada parte a ser implementada.","title":"Travelling Sales Person (TSP)"},{"location":"projetos/#travelling-sales-person-tsp","text":"Nosso projeto do semestre ser\u00e1 o Caixeiro Viajante . Neste problema recebemos uma lista de cidades representadas por suas coordenadas (x_i, y_i)_{i=0}^N (x_i, y_i)_{i=0}^N e temos como objetivo encontrar o o caminho fechado que visite todas as cidades tenha o menor comprimento poss\u00edvel Note que podemos come\u00e7ar de qualquer cidade, j\u00e1 que nosso caminho \u00e9 fechado. Ou seja, ele come\u00e7a e termina no mesmo lugar. Este \u00e9 um problema muito estudado em otimiza\u00e7\u00e3o e existem v\u00e1rios m\u00e9todos que proporcionam solu\u00e7\u00f5es muito boas em pouqu\u00edssimo tempo. Por exemplo, o Gif abaixo usa uma t\u00e9cnica de otimiza\u00e7\u00e3o chamada Simulated annealing . \u00c9 f\u00e1cil de perceber que este problema ocorre frequentemente em log\u00edsitca, seja na forma que apresentamos ou em sua generaliza\u00e7\u00e3o, o Roteamento de Ve\u00edculos .","title":"Travelling Sales Person (TSP)"},{"location":"projetos/#por-que-escolhemos-esse-problema","text":"O TSP \u00e9 um problema de otimiza\u00e7\u00e3o dos mais dif\u00edceis ( NP-hard ). N\u00e3o existe algoritmo polinomial que encontre a melhor solu\u00e7\u00e3o nem algoritmo polinomial que cheque se uma solu\u00e7\u00e3o \u00e9 a melhor. Entramos ent\u00e3o em duas \u00e1reas: encontrar a melhor solu\u00e7\u00e3o o mais r\u00e1pido poss\u00edvel usar heur\u00edsticas para encontrar uma solu\u00e7\u00e3o boa o mais r\u00e1pido poss\u00edvel Trabalharemos com ambas as ideias durante a disciplina, focando tanto em implementa\u00e7\u00f5es sequenciais como paralelas.","title":"Por que escolhemos esse problema?"},{"location":"projetos/#avaliacao-e-formatos-de-entrada-e-saida","text":"O projeto \u00e9 individual e ser\u00e1 corrigido usando uma s\u00e9rie de scripts de corre\u00e7\u00e3o automatizada. Entrada N x1 y1 .... xN yN N \u00e9 o n\u00famero de cidades xi yi s\u00e3o as coordenadas de cada cidade Sa\u00edda L O c1 .... cN L \u00e9 o comprimento do tour O indica se o tour \u00e9 \u00f3timo (1) ou n\u00e3o (0) c1 ... cN \u00e9 a sequ\u00eancia de cidades visitadas para chegar no tour de comprimento L Importante Os formatos de entrada e sa\u00edda dever\u00e3o ser respeitados de maneira estrita Algumas entregas pedir\u00e3o tamb\u00e9m informa\u00e7\u00f5es mostradas na sa\u00edda de erros std:cerr Os scripts de corre\u00e7\u00e3o ser\u00e3o atualizados durante o semestre. 4.","title":"Avalia\u00e7\u00e3o e formatos de entrada e sa\u00edda"},{"location":"projetos/#entregas-e-datas-importantes","text":"O projeto de voc\u00eas dever\u00e1 ser entregue via um reposit\u00f3rio Git privado criado especialmente para este fim. Ele ser\u00e1 criado a partir das respostas do formul\u00e1rio a seguir. Cada aluno ir\u00e1 adicionar sua solu\u00e7\u00e3o ao seu reposit\u00f3rio, que j\u00e1 ir\u00e1 conter os arquivos de corre\u00e7\u00e3o autom\u00e1tica. A entrega dever\u00e1 cumprir todos os itens do Checklist de projeto . As etapas do projeto ser\u00e3o disponibilizadas depois de discuss\u00f5es em sala de aula e estar\u00e3o conectadas com uma aula espec\u00edfica. Atividade 1 - heur\u00edstica da cidade mais pr\u00f3xima : Entrega 18/09 Atividade 2 - busca local - troca de ordem : Entrega 30/09 Atividade 3 - busca exaustiva : Entrega 13/10 Atividade 4 - implementa\u00e7\u00f5es sequenciais eficientes : Entrega 04/11","title":"Entregas e Datas importantes"},{"location":"projetos/#verificacao-de-resultados","text":"Voc\u00ea receber\u00e1 um convite para reposit\u00f3rio. Todas as atividades ser\u00e3o disponibilizadas neste reposit\u00f3rio e suas solu\u00e7\u00f5es devem ser adicionadas nos arquivos correspondentes. O corretor autom\u00e1tico depende do pacote grading-tools , que dever\u00e1 ser instalado como abaixo. $> python3.8 -m pip install --user git+https://github.com/igordsm/grading-tools Python 3.8 no Ubuntu Se seu python3 \u00e9 uma vers\u00e3o inferior ao 3.8, voc\u00ea pode instal\u00e1-lo com os pacotes abaixo: python3.8 python3.8-dev A partir da\u00ed poder\u00e1 seguir normalmente as instru\u00e7\u00f5es desta p\u00e1gina. Com isso configurado, \u00e9 s\u00f3 compilar seu programa e rodar python3.8 corretor.py executavel . Para baixar os novos exerc\u00edcios \u00e9 s\u00f3 rodar git pull . Os exerc\u00edcios ser\u00e3o entregues criando um commit com sua resposta e dando git push . Warning Fique atento a atualiza\u00e7\u00f5es no seu reposit\u00f3rio de projeto. Atualiza\u00e7\u00f5es no corretor ser\u00e3o feitas ao longo do semestre, assim como ser\u00e3o disponibilizados novos arquivos de entrada/sa\u00edda para cada parte a ser implementada.","title":"Verifica\u00e7\u00e3o de resultados"},{"location":"projetos/busca-exaustiva/","text":".admonition p:nth-child(2) { font-size: 18pt; } Busca exaustiva \u00b6 Vamos agora explorar a cria\u00e7\u00e3o de um algoritmo que encontra o tour com a menor dist\u00e2ncia poss\u00edvel . Isto significa que teremos que listar todas as possibilidades e retornar a melhor poss\u00edvel. Nesta primeira etapa n\u00e3o iremos implementar algoritmos de busca exaustiva eficientes, como Branch and Bound e Best-first search . O requisito \u00e9 conseguir implementar um algoritmo recursivo simples para resolver o problema. Corre\u00e7\u00e3o autom\u00e1tica \u00b6 Al\u00e9m da resposta correta, seu algortimo dever\u00e1 tamb\u00e9m mostrar informa\u00e7\u00f5es na sa\u00edda de erros ( std::cerr ). Estas informa\u00e7\u00f5es ser\u00e3o usadas para checar corretude de sua implementa\u00e7\u00e3o. Para auxiliar na corre\u00e7\u00e3o voc\u00ea dever\u00e1 mostrar na sa\u00edda de erros os n\u00famero de vezes que seu programa encontrou uma solu\u00e7\u00e3o v\u00e1lida (que \u00e9 igual tamb\u00e9m ao n\u00famero de vezes que \u00e9 feita a compara\u00e7\u00e3o com a melhor solu\u00e7\u00e3o at\u00e9 o momento). Formate sua sa\u00edda como mostrado abaixo num_leaf XXX","title":"Busca exaustiva"},{"location":"projetos/busca-exaustiva/#busca-exaustiva","text":"Vamos agora explorar a cria\u00e7\u00e3o de um algoritmo que encontra o tour com a menor dist\u00e2ncia poss\u00edvel . Isto significa que teremos que listar todas as possibilidades e retornar a melhor poss\u00edvel. Nesta primeira etapa n\u00e3o iremos implementar algoritmos de busca exaustiva eficientes, como Branch and Bound e Best-first search . O requisito \u00e9 conseguir implementar um algoritmo recursivo simples para resolver o problema.","title":"Busca exaustiva"},{"location":"projetos/busca-exaustiva/#correcao-automatica","text":"Al\u00e9m da resposta correta, seu algortimo dever\u00e1 tamb\u00e9m mostrar informa\u00e7\u00f5es na sa\u00edda de erros ( std::cerr ). Estas informa\u00e7\u00f5es ser\u00e3o usadas para checar corretude de sua implementa\u00e7\u00e3o. Para auxiliar na corre\u00e7\u00e3o voc\u00ea dever\u00e1 mostrar na sa\u00edda de erros os n\u00famero de vezes que seu programa encontrou uma solu\u00e7\u00e3o v\u00e1lida (que \u00e9 igual tamb\u00e9m ao n\u00famero de vezes que \u00e9 feita a compara\u00e7\u00e3o com a melhor solu\u00e7\u00e3o at\u00e9 o momento). Formate sua sa\u00edda como mostrado abaixo num_leaf XXX","title":"Corre\u00e7\u00e3o autom\u00e1tica"},{"location":"projetos/busca-local/","text":"Busca local \u00b6 .admonition p:nth-child(2) { font-size: 18pt; } Nossa busca local consistir\u00e1 na seguinte estrat\u00e9gia: Quote Trocar a ordem de visita de duas cidades Ou seja, se for poss\u00edvel inverter a ordem de visita\u00e7\u00e3o de duas cidades e isso melhorar a solu\u00e7\u00e3o ent\u00e3o fa\u00e7a a troca. S\u00f3 pare quando isso n\u00e3o for mais poss\u00edvel. Para uniformizar nossas solu\u00e7\u00f5es vamos adotar a seguinte estrat\u00e9gia de desempates: Quote Se houver mais de uma troca, escolha a com primeira cidade de menor \u00edndice. Se houve empate escolha a com a segunda cidade com menor \u00edndice. Gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00b6 Seu programa dever\u00e1 retornar o mesmo resultado em todas execu\u00e7\u00f5es. Dever\u00e1 ser poss\u00edvel configurar a seed usada no programa usando a vari\u00e1vel de ambiente SEED . `$> SEED=20 ./busca-local < in.txt Se n\u00e3o for passada via vari\u00e1vel de ambiente, assuma SEED=10 . O algoritmo dever\u00e1 gerar 10N solu\u00e7\u00f5es e retornar a melhor delas. Corre\u00e7\u00e3o autom\u00e1tica \u00b6 Al\u00e9m da resposta correta, seu algortimo dever\u00e1 tamb\u00e9m mostrar informa\u00e7\u00f5es na sa\u00edda de erros ( std::cerr ). Estas informa\u00e7\u00f5es ser\u00e3o usadas para checar corretude de sua implementa\u00e7\u00e3o. Quote A cada solu\u00e7\u00e3o gerada pela busca local (ap\u00f3s o processo de trocas), seu programa dever\u00e1 mostra em uma linha da sa\u00edda de erros a seguinte linha: local: size c1 c2 ... cN size \u00e9 o tamanho do tour encontrado c1 .... cN \u00e9 o tour que tem tamanho size Ser\u00e1 verificado na corre\u00e7\u00e3o autom\u00e1tica se as solu\u00e7\u00f5es locais produzidas obedecem \u00e0 regra do in\u00edcio da se\u00e7\u00e3o.","title":"Busca local"},{"location":"projetos/busca-local/#busca-local","text":".admonition p:nth-child(2) { font-size: 18pt; } Nossa busca local consistir\u00e1 na seguinte estrat\u00e9gia: Quote Trocar a ordem de visita de duas cidades Ou seja, se for poss\u00edvel inverter a ordem de visita\u00e7\u00e3o de duas cidades e isso melhorar a solu\u00e7\u00e3o ent\u00e3o fa\u00e7a a troca. S\u00f3 pare quando isso n\u00e3o for mais poss\u00edvel. Para uniformizar nossas solu\u00e7\u00f5es vamos adotar a seguinte estrat\u00e9gia de desempates: Quote Se houver mais de uma troca, escolha a com primeira cidade de menor \u00edndice. Se houve empate escolha a com a segunda cidade com menor \u00edndice.","title":"Busca local"},{"location":"projetos/busca-local/#geracao-de-numeros-aleatorios","text":"Seu programa dever\u00e1 retornar o mesmo resultado em todas execu\u00e7\u00f5es. Dever\u00e1 ser poss\u00edvel configurar a seed usada no programa usando a vari\u00e1vel de ambiente SEED . `$> SEED=20 ./busca-local < in.txt Se n\u00e3o for passada via vari\u00e1vel de ambiente, assuma SEED=10 . O algoritmo dever\u00e1 gerar 10N solu\u00e7\u00f5es e retornar a melhor delas.","title":"Gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios"},{"location":"projetos/busca-local/#correcao-automatica","text":"Al\u00e9m da resposta correta, seu algortimo dever\u00e1 tamb\u00e9m mostrar informa\u00e7\u00f5es na sa\u00edda de erros ( std::cerr ). Estas informa\u00e7\u00f5es ser\u00e3o usadas para checar corretude de sua implementa\u00e7\u00e3o. Quote A cada solu\u00e7\u00e3o gerada pela busca local (ap\u00f3s o processo de trocas), seu programa dever\u00e1 mostra em uma linha da sa\u00edda de erros a seguinte linha: local: size c1 c2 ... cN size \u00e9 o tamanho do tour encontrado c1 .... cN \u00e9 o tour que tem tamanho size Ser\u00e1 verificado na corre\u00e7\u00e3o autom\u00e1tica se as solu\u00e7\u00f5es locais produzidas obedecem \u00e0 regra do in\u00edcio da se\u00e7\u00e3o.","title":"Corre\u00e7\u00e3o autom\u00e1tica"},{"location":"projetos/checklist/","text":"Checklist de projeto \u00b6 Alguns requisitos de projeto b\u00e1sicos ser\u00e3o verificados em todas as entregas. O objetivo aqui \u00e9 evitar que uma evid\u00eancia importante de aprendizado deixe de ser enviada e prejudique a avalia\u00e7\u00e3o. N\u00e3o cumprir algum desses requisitos implica em reentrega valendo D . Script de compila\u00e7\u00e3o (CMake, Makefile, bash script). Relat\u00f3rio feito em Jupyter Notebook ou PWeave. Vers\u00e3o em PDF (ou HTML) do relat\u00f3rio Instru\u00e7\u00f5es para replicar os testes realizados. Se isto estiver incluso no relat\u00f3rio execut\u00e1vel basta indicar no texto. Se\u00e7\u00e3o explicando onde est\u00e1 e como usar o script de compila\u00e7\u00e3o. Requisitos de qualidade \u00b6 Al\u00e9m dos requisitos acima, que s\u00e3o obrigat\u00f3rios, os seguintes itens procuram medir a qualidade da implementa\u00e7\u00e3o que voc\u00eas desenvolveram. Assim como explicado na aula 01, eles n\u00e3o reprovam, mas diminuem a nota de projeto. Cada item que n\u00e3o for cumprido implica em desconto de 1,0 na nota de projeto. Programa compila sem warnings quando compilado com g++ -O3 -Wall -pedantic -std=c++11 ; Programa n\u00e3o tem warnings detectados pelo clang-tidy . Veja este v\u00eddeo para um breve tutorial de uso; usar os checks read*,performance*,hicpp*,modern*,-modernize-use-trailing-return-type . N\u00e3o h\u00e1 repeti\u00e7\u00e3o desnecess\u00e1ria de c\u00f3digo; Implementaremos v\u00e1rias solu\u00e7\u00f5es para o mesmo problema. \u00c9 importante compartilhar o m\u00e1ximo de c\u00f3digo poss\u00edvel entre todas as implementa\u00e7\u00f5es; Utilizar struct ou class para agregar grupos de vari\u00e1veis que sempre s\u00e3o usadas junto (Exemplo: todos os dados de entrada do programa); Utilizar typdef para renomear tipos com nomes grandes. (Exemplo seria um vector de um struct ou pair ); Utilizar corretamente os recursos de C++. Em geral o que for apresentado em aula e n\u00e3o conflitar com os itens acima \u00e9 OK. Em geral c\u00f3digo copiado da internet n\u00e3o passa nesse quesito. Na d\u00favida pergunte.","title":"Checklist de projeto"},{"location":"projetos/checklist/#checklist-de-projeto","text":"Alguns requisitos de projeto b\u00e1sicos ser\u00e3o verificados em todas as entregas. O objetivo aqui \u00e9 evitar que uma evid\u00eancia importante de aprendizado deixe de ser enviada e prejudique a avalia\u00e7\u00e3o. N\u00e3o cumprir algum desses requisitos implica em reentrega valendo D . Script de compila\u00e7\u00e3o (CMake, Makefile, bash script). Relat\u00f3rio feito em Jupyter Notebook ou PWeave. Vers\u00e3o em PDF (ou HTML) do relat\u00f3rio Instru\u00e7\u00f5es para replicar os testes realizados. Se isto estiver incluso no relat\u00f3rio execut\u00e1vel basta indicar no texto. Se\u00e7\u00e3o explicando onde est\u00e1 e como usar o script de compila\u00e7\u00e3o.","title":"Checklist de projeto"},{"location":"projetos/checklist/#requisitos-de-qualidade","text":"Al\u00e9m dos requisitos acima, que s\u00e3o obrigat\u00f3rios, os seguintes itens procuram medir a qualidade da implementa\u00e7\u00e3o que voc\u00eas desenvolveram. Assim como explicado na aula 01, eles n\u00e3o reprovam, mas diminuem a nota de projeto. Cada item que n\u00e3o for cumprido implica em desconto de 1,0 na nota de projeto. Programa compila sem warnings quando compilado com g++ -O3 -Wall -pedantic -std=c++11 ; Programa n\u00e3o tem warnings detectados pelo clang-tidy . Veja este v\u00eddeo para um breve tutorial de uso; usar os checks read*,performance*,hicpp*,modern*,-modernize-use-trailing-return-type . N\u00e3o h\u00e1 repeti\u00e7\u00e3o desnecess\u00e1ria de c\u00f3digo; Implementaremos v\u00e1rias solu\u00e7\u00f5es para o mesmo problema. \u00c9 importante compartilhar o m\u00e1ximo de c\u00f3digo poss\u00edvel entre todas as implementa\u00e7\u00f5es; Utilizar struct ou class para agregar grupos de vari\u00e1veis que sempre s\u00e3o usadas junto (Exemplo: todos os dados de entrada do programa); Utilizar typdef para renomear tipos com nomes grandes. (Exemplo seria um vector de um struct ou pair ); Utilizar corretamente os recursos de C++. Em geral o que for apresentado em aula e n\u00e3o conflitar com os itens acima \u00e9 OK. Em geral c\u00f3digo copiado da internet n\u00e3o passa nesse quesito. Na d\u00favida pergunte.","title":"Requisitos de qualidade"},{"location":"projetos/desempenho-sequencial/","text":"Desempenho sequencial \u00b6 At\u00e9 o momento n\u00e3o nos preocupamos com a efici\u00eancia de nossos programas. Checamos sua corretude em termos dos resultados obtidos, mas n\u00e3o da efici\u00eancia de sua implementa\u00e7\u00e3o. Agora vamos focar nisso. Como visto na aula 11 , paralelizar um algoritmo ruim traz ganhos de desempenho muito limitados. \u00c9 s\u00f3 quando aliamos algoritmo, implementa\u00e7\u00e3o eficiente e paralelismo que desenvolvemos uma solu\u00e7\u00e3o de alto desempenho. Checagem autom\u00e1tica \u00b6 Continuaremos usando o corretor.pyc , que agora ir\u00e1 testar a efici\u00eancia dos algoritmos de busca local e exaustiva. No primeiro caso, voc\u00eas ir\u00e3o precisar implementar corretamente um algoritmo que avalie somente a diferen\u00e7a causada pela troca sem reavaliar o tour inteiro. No segundo caso, \u00e9 imposs\u00edvel passar em todos os testes sem implementar algum tipo de branch-and-bound/best-first search. Os testes de desempenho n\u00e3o ir\u00e3o considerar a sa\u00edda de erros, verificando somente o tempo de execu\u00e7\u00e3o e a validade da sa\u00edda final. Para desabilitar isso voc\u00eas devem modificar o programa de voc\u00eas para ler o estado de uma vari\u00e1vel de ambiente chamada DEBUG . Se DEBUG=1 seu programa dever\u00e1 mostrar as mensagens na sa\u00edda de erros. Caso DEBUG n\u00e3o esteja definido ou seu valor n\u00e3o seja 1 , seu programa n\u00e3o dever\u00e1 mostrar as mensagens na sa\u00edda de erros. Note que o resultado final continuar\u00e1 o mesmo, estamos desligando apenas as Danger Dado que estamos permitindo que o programa cheque se est\u00e1 rodando no modo medi\u00e7\u00e3o de desempenho, se for feito algo al\u00e9m do desligamento dos print seu trabalho automaticamente falha nesta atividade.","title":"Desempenho sequencial"},{"location":"projetos/desempenho-sequencial/#desempenho-sequencial","text":"At\u00e9 o momento n\u00e3o nos preocupamos com a efici\u00eancia de nossos programas. Checamos sua corretude em termos dos resultados obtidos, mas n\u00e3o da efici\u00eancia de sua implementa\u00e7\u00e3o. Agora vamos focar nisso. Como visto na aula 11 , paralelizar um algoritmo ruim traz ganhos de desempenho muito limitados. \u00c9 s\u00f3 quando aliamos algoritmo, implementa\u00e7\u00e3o eficiente e paralelismo que desenvolvemos uma solu\u00e7\u00e3o de alto desempenho.","title":"Desempenho sequencial"},{"location":"projetos/desempenho-sequencial/#checagem-automatica","text":"Continuaremos usando o corretor.pyc , que agora ir\u00e1 testar a efici\u00eancia dos algoritmos de busca local e exaustiva. No primeiro caso, voc\u00eas ir\u00e3o precisar implementar corretamente um algoritmo que avalie somente a diferen\u00e7a causada pela troca sem reavaliar o tour inteiro. No segundo caso, \u00e9 imposs\u00edvel passar em todos os testes sem implementar algum tipo de branch-and-bound/best-first search. Os testes de desempenho n\u00e3o ir\u00e3o considerar a sa\u00edda de erros, verificando somente o tempo de execu\u00e7\u00e3o e a validade da sa\u00edda final. Para desabilitar isso voc\u00eas devem modificar o programa de voc\u00eas para ler o estado de uma vari\u00e1vel de ambiente chamada DEBUG . Se DEBUG=1 seu programa dever\u00e1 mostrar as mensagens na sa\u00edda de erros. Caso DEBUG n\u00e3o esteja definido ou seu valor n\u00e3o seja 1 , seu programa n\u00e3o dever\u00e1 mostrar as mensagens na sa\u00edda de erros. Note que o resultado final continuar\u00e1 o mesmo, estamos desligando apenas as Danger Dado que estamos permitindo que o programa cheque se est\u00e1 rodando no modo medi\u00e7\u00e3o de desempenho, se for feito algo al\u00e9m do desligamento dos print seu trabalho automaticamente falha nesta atividade.","title":"Checagem autom\u00e1tica"},{"location":"projetos/heuristica/","text":"Heur\u00edstica da cidade mais pr\u00f3xima \u00b6 A primeira solu\u00e7\u00e3o para o proejeto da disciplina ser\u00e1 a cidade mais pr\u00f3xima . Come\u00e7ando na cidade 0 , selecione iterativamente a cidade mais pr\u00f3xima n\u00e3o visitada at\u00e9 fazer o tour completo \u00b6 Esta heur\u00edstica d\u00e1 bons resultados e pode ser implementada de maneira bastante eficiente. Avalia\u00e7\u00e3o de resultados \u00b6 Os arquivos in/out-*.txt na pasta heuristico representam a sa\u00edda esperada de seu programa para uma s\u00e9rie de entradas exemplo. Use o corretor seguindo as instru\u00e7\u00f5es neste link","title":"Heur\u00edstica da cidade mais pr\u00f3xima"},{"location":"projetos/heuristica/#heuristica-da-cidade-mais-proxima","text":"A primeira solu\u00e7\u00e3o para o proejeto da disciplina ser\u00e1 a cidade mais pr\u00f3xima .","title":"Heur\u00edstica da cidade mais pr\u00f3xima"},{"location":"projetos/heuristica/#comecando-na-cidade-0-selecione-iterativamente-a-cidade-mais-proxima-nao-visitada-ate-fazer-o-tour-completo","text":"Esta heur\u00edstica d\u00e1 bons resultados e pode ser implementada de maneira bastante eficiente.","title":"Come\u00e7ando na cidade 0, selecione iterativamente a cidade mais pr\u00f3xima n\u00e3o visitada at\u00e9 fazer o tour completo"},{"location":"projetos/heuristica/#avaliacao-de-resultados","text":"Os arquivos in/out-*.txt na pasta heuristico representam a sa\u00edda esperada de seu programa para uma s\u00e9rie de entradas exemplo. Use o corretor seguindo as instru\u00e7\u00f5es neste link","title":"Avalia\u00e7\u00e3o de resultados"}]}