{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SuperComputa\u00e7\u00e3o \u00b6 Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2021/1. Professores : Igor Montagner (Turma A) Ant\u00f4nio Selvatici (Turma B) Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; O projeto da disciplina ser\u00e1 composto por m\u00faltiplas partes. Mais detalhes na p\u00e1gina de projetos A m\u00e9dia final \u00e9 dada por 55% Projeto 45% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Projeto >= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados) Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Home"},{"location":"#supercomputacao","text":"Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2021/1. Professores : Igor Montagner (Turma A) Ant\u00f4nio Selvatici (Turma B)","title":"SuperComputa\u00e7\u00e3o"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; O projeto da disciplina ser\u00e1 composto por m\u00faltiplas partes. Mais detalhes na p\u00e1gina de projetos A m\u00e9dia final \u00e9 dada por 55% Projeto 45% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Projeto >= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados) Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Avalia\u00e7\u00e3o"},{"location":"sobre/","text":"Burocracias \u00b6 Turma B \u00b6 Hor\u00e1rios: TER - 09:45 SEX - 13:30 Atendimento SEX - 15:30 Alunos TBA Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 23/02 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 26/02 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 02/03 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa. 05/03 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 09/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 12/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 16/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 19/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 23/03 Quando uma otimiza\u00e7\u00e3o vale a pena? Qual m\u00e9todo \u00e9 o mais eficaz em resolver um problema? An\u00e1lise de resultados de execu\u00e7\u00e3o 26/03 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 30/03 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 02/04 Feriado Feriado 06/04 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 09/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 13/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 16/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 20/04 nan nan 23/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 27/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 30/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 04/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 07/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 11/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 14/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 18/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 21/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 25/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 28/05 Quiz para PF Quiz para PF 01/06 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 04/06 Feriado Feriado 08/06 nan nan 11/06 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria Turma A \u00b6 Hor\u00e1rios: QUA - 13:30 SEX - 07:30 Atendimento SEX - 09:30 Alunos TBA Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 24/02 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 26/02 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 03/03 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa. 05/03 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 10/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 12/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 17/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 19/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 24/03 Quando uma otimiza\u00e7\u00e3o vale a pena? Qual m\u00e9todo \u00e9 o mais eficaz em resolver um problema? An\u00e1lise de resultados de execu\u00e7\u00e3o 26/03 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 31/03 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 02/04 Feriado Feriado 07/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 09/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 14/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 16/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 21/04 nan nan 23/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 28/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 30/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 05/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 07/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 12/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 14/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 19/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 21/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 26/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 28/05 Quiz para PF Quiz para PF 02/06 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 04/06 Feriado Feriado 09/06 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 11/06 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria","title":"Burocracias"},{"location":"sobre/#burocracias","text":"","title":"Burocracias"},{"location":"sobre/#turma-b","text":"Hor\u00e1rios: TER - 09:45 SEX - 13:30 Atendimento SEX - 15:30 Alunos TBA Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 23/02 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 26/02 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 02/03 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa. 05/03 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 09/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 12/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 16/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 19/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 23/03 Quando uma otimiza\u00e7\u00e3o vale a pena? Qual m\u00e9todo \u00e9 o mais eficaz em resolver um problema? An\u00e1lise de resultados de execu\u00e7\u00e3o 26/03 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 30/03 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 02/04 Feriado Feriado 06/04 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 09/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 13/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 16/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 20/04 nan nan 23/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 27/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 30/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 04/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 07/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 11/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 14/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 18/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 21/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 25/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 28/05 Quiz para PF Quiz para PF 01/06 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 04/06 Feriado Feriado 08/06 nan nan 11/06 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria","title":"Turma B"},{"location":"sobre/#turma-a","text":"Hor\u00e1rios: QUA - 13:30 SEX - 07:30 Atendimento SEX - 09:30 Alunos TBA Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 24/02 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Implementa\u00e7\u00e3o de algoritmos simples; Refer\u00eancia: Pacheco Cap 2. 26/02 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Passagem de argumentos por refer\u00eancia e valor; Recursos de C++. 03/03 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho. Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa. 05/03 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dificeis Introdu\u00e7\u00e3o ao projeto da disciplina; Heur\u00edsticas, busca local e global; Revis\u00e3o de complexidade computacional. 10/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades da solu\u00e7\u00e3o \u00f3tima; Vizinhan\u00e7a de solu\u00e7\u00f5es; 12/03 Solu\u00e7\u00f5es sub-\u00f3timas usando busca local. Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 17/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 19/03 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho. 24/03 Quando uma otimiza\u00e7\u00e3o vale a pena? Qual m\u00e9todo \u00e9 o mais eficaz em resolver um problema? An\u00e1lise de resultados de execu\u00e7\u00e3o 26/03 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa. 31/03 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edveis al\u00e9m do branch-and-bound. 02/04 Feriado Feriado 07/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 09/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 14/04 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 16/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 21/04 nan nan 23/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 28/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 30/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 05/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 07/05 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 12/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 14/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 19/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 21/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 26/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 28/05 Quiz para PF Quiz para PF 02/06 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 04/06 Feriado Feriado 09/06 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria 11/06 Prova Intermedi\u00e1ria Prova Intermedi\u00e1ria","title":"Turma A"},{"location":"aulas/01-introducao/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); 01 - Introdu\u00e7\u00e3o a SuperComputa\u00e7\u00e3o \u00b6 Como vimos na expositiva, uma solu\u00e7\u00e3o de alto desempenho depende de tr\u00eas partes: algoritmos eficientes implementa\u00e7\u00f5es eficientes paralelismo Na atividade de hoje vamos estudar o primeiro ponto e quantificar o efeito de algoritmos eficientes na resolu\u00e7\u00e3o de um problema complexo. Problemas estudados em SuperComputa\u00e7\u00e3o \u00b6 Em Desafios de Programa\u00e7\u00e3o conhecemos a classe dos problemas NP-completo, que s\u00e3o aqueles que acreditamos n\u00e3o existir nenhum algoritmo determin\u00edstico que os resolvem em tempo polinomial. Ou seja, s\u00e3o problemas importantes cuja solu\u00e7\u00e3o \u00e9 dif\u00edcil. Em geral temos classes de algoritmos para resolv\u00ea-los: \u00f3timos globais: algoritmo que encontra a solu\u00e7\u00e3o \"correta\" do problema. \u00f3timos locais: algoritmo que encontra uma solu\u00e7\u00e3o \"boa\" e que n\u00e3o pode ser melhorada por pequenas modifica\u00e7\u00f5es. aproxima\u00e7\u00e3o: algoritmos que garantem estar \"perto o suficiente\" da solu\u00e7\u00e3o \u00f3tima. Este tipo de algoritmo n\u00e3o nos interessa em SuperComputa\u00e7\u00e3o. Iremos analisar hoje 4 execut\u00e1veis que resolvem o problema do Caixeiro Viajante . busca-local-1 - implementa\u00e7\u00e3o de um m\u00e9todo de busca r\u00e1pida, por\u00e9m n\u00e3o \u00f3tima. busca-local-1-par - implementa\u00e7\u00e3o paralela do programa acima. busca-local-2 - implementa\u00e7\u00e3o alternativa do mesmo m\u00e9todo acima. Os resultados de ambos s\u00e3o id\u00eanticos. busca-local-2-par - implementa\u00e7\u00e3o paralela do programa acima. Important N\u00e3o estamos interessados no Caixeiro Viajante em si hoje. Queremos \u00e9 comparar diferentes maneiras de resolv\u00ea-lo para entendermos o papel de t\u00e9cnicas de SuperComputa\u00e7\u00e3o na velocidade de processamento e nos resultados obtidos. Ferramental \u00b6 Realizar testes de maneira automatizada \u00e9 muito importante para quantificar os efeitos de diferentes algoritmos e t\u00e9cnicas de paralelismo. O snippet abaixo executa import subprocess import time with open ( 'entradas-busca-local/in-0.txt' ) as f : start = time . perf_counter () proc = subprocess . run ([ './busca-local-1' ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () print ( 'Sa\u00edda:' , proc . stdout ) print ( 'Stderr:' , proc . stderr ) print ( 'Tempo total(s):' , end - start ) Sa\u00edda: 232.234 0 3 0 4 1 2 Stderr: Tempo total(s): 0.013778032999653078 Vamos agora praticar usar este snippet para executar nossos testes automaticamente. Example Crie uma fun\u00e7\u00e3o roda_com_entrada(executavel, arquivo_in) que roda o primeiro argumento usando como entrada o conte\u00fado do segundo argumento. Teste seu c\u00f3digo com o execut\u00e1vel busca-local-1 e com o arquivo de entrada in-0.txt usado no exemplo acima. Sua fun\u00e7\u00e3o dever\u00e1 devolver uma tupla (stdout,time) com stdout sendo a sa\u00edda do programa e time seu tempo de execu\u00e7\u00e3o em segundos. def roda ( ex , in_f ): with open ( in_f ) as f : start = time . perf_counter () proc = subprocess . run ([ ex ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () return proc . stdout , end - start roda ( './busca-local-1' , 'entradas-busca-local/in-0.txt' ) ('232.234 0\\n3 0 4 1 2 \\n', 0.009169607999865548) Algoritmos sequenciais \u00b6 Com esse c\u00f3digo, vamos criar um relat\u00f3rio interativo que roda nossos testes automaticamente e j\u00e1 plota informa\u00e7\u00f5es prontas para nossas an\u00e1lises. Vamos come\u00e7ar examinando o desempenho do execut\u00e1vel busca-local-1 . Example Rode o busca-local com os arquivos de entrada na pasta entradas-busca-local . Guarde os tempos em uma lista. Example Leia o tamanho das entradas dos arquivos na pasta entradas-busca-local e guarde em uma segunda lista. Example Plote o tempo de execu\u00e7\u00e3o pelo tamanho da entrada usando matplotlib arqs = [ f 'entradas-busca-local/in- { i } .txt' for i in range ( 10 )] tempos = [ roda ( './busca-local-1' , arq )[ 1 ] for arq in arqs ] N = [] for arq in arqs : with open ( arq ) as f : n = int ( f . readlines ()[ 0 ]) N . append ( n ) print ( N ) import matplotlib.pyplot as plt plt . plot ( tempos ) [<matplotlib.lines.Line2D at 0x7fe533947550>] 2021-02-24T14:47:06.578856 image/svg+xml Matplotlib v3.3.4, https://matplotlib.org/ *{stroke-linecap:butt;stroke-linejoin:round;} Example Repita os tr\u00eas passos acima para o execut\u00e1vel busca-local-2 . Finalize plotando os tempos de execu\u00e7\u00e3o de ambos os execut\u00e1veis no mesmo gr\u00e1fico. tempos2 = [ roda ( './busca-local-2' , arq )[ 1 ] for arq in arqs ] plt . plot ( tempos ) plt . plot ( tempos2 ) [<matplotlib.lines.Line2D at 0x7fe5335e47c0>] 2021-02-24T14:48:22.282797 image/svg+xml Matplotlib v3.3.4, https://matplotlib.org/ *{stroke-linecap:butt;stroke-linejoin:round;} Example Segundo uma coleta de dados informal e altamente confi\u00e1vel, 93,17% dos alunos n\u00e3o colocam legendas nem t\u00edtulos nos gr\u00e1ficos gerados. Fa\u00e7a isso agora. Question Interprete o gr\u00e1fico que voc\u00ea gerou na linha de cima. Question Compare manualmente a sa\u00edda dos programas. Existe diferen\u00e7a em seus resultados? Question Resgate seus conhecimentos de Desafios de Programa\u00e7\u00e3o e explique a diferen\u00e7a entre os algoritmos. Algoritmos paralelos \u00b6 Na discuss\u00e3o inicial da expositiva chegamos \u00e0 conclus\u00e3o de que se conseguimos realizar N opera\u00e7\u00f5es em paralelo teremos um ganho de no m\u00e1ximo N vezes no desempenho de nosso programa. Nesta parte iremos estudar esta afirma\u00e7\u00e3o usando implementa\u00e7\u00f5es paralelas dos algoritmos da se\u00e7\u00e3o anterior. Example Execute os algoritmos paralelos com as mesmas entradas e compare com suas vers\u00f5es paralelas. Use um gr\u00e1fico para facilitar as compara\u00e7\u00f5es Question Compare os tempos obtidos. Qual foi o ganho m\u00e9dio? Quantos n\u00facleos a m\u00e1quina que voc\u00ea est\u00e1 usando possui? Responda comparando cada algoritmo sequencial com sua vers\u00e3o paralela. J\u00e1 estabelecemos que busca-local-2 \u00e9 melhor que busca-local-1 por ser utilizar um algoritmo mais eficiente e vimos na pr\u00e1tica a diferen\u00e7a entre um algoritmo O(n^3) O(n^3) e um algoritmo O(n^2) O(n^2) . Vamos agora examinar a seguinte quest\u00e3o. \u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2 ? Example Compare o desempenho de busca-local-1-par com busca-local-2 . Fa\u00e7a um gr\u00e1fico Question Com base em seu gr\u00e1fico acima, responda a pergunta: \"\u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2?\" Vamos agora generalizar a pergunta: Question Dados dois algoritmos com complexidades computacionais diferentes, sendo que o primeiro \u00e9 inferior ao segundo. \u00c9 poss\u00edvel usar paralelismo para tornar o primeiro mais r\u00e1pido que o segundo para todos tamanhos de entrada? Assuma que voc\u00ea possui um n\u00famero fixo de n\u00facleos .","title":"01 - Introdu\u00e7\u00e3o"},{"location":"aulas/01-introducao/#01-introducao-a-supercomputacao","text":"Como vimos na expositiva, uma solu\u00e7\u00e3o de alto desempenho depende de tr\u00eas partes: algoritmos eficientes implementa\u00e7\u00f5es eficientes paralelismo Na atividade de hoje vamos estudar o primeiro ponto e quantificar o efeito de algoritmos eficientes na resolu\u00e7\u00e3o de um problema complexo.","title":"01 - Introdu\u00e7\u00e3o a SuperComputa\u00e7\u00e3o"},{"location":"aulas/01-introducao/#problemas-estudados-em-supercomputacao","text":"Em Desafios de Programa\u00e7\u00e3o conhecemos a classe dos problemas NP-completo, que s\u00e3o aqueles que acreditamos n\u00e3o existir nenhum algoritmo determin\u00edstico que os resolvem em tempo polinomial. Ou seja, s\u00e3o problemas importantes cuja solu\u00e7\u00e3o \u00e9 dif\u00edcil. Em geral temos classes de algoritmos para resolv\u00ea-los: \u00f3timos globais: algoritmo que encontra a solu\u00e7\u00e3o \"correta\" do problema. \u00f3timos locais: algoritmo que encontra uma solu\u00e7\u00e3o \"boa\" e que n\u00e3o pode ser melhorada por pequenas modifica\u00e7\u00f5es. aproxima\u00e7\u00e3o: algoritmos que garantem estar \"perto o suficiente\" da solu\u00e7\u00e3o \u00f3tima. Este tipo de algoritmo n\u00e3o nos interessa em SuperComputa\u00e7\u00e3o. Iremos analisar hoje 4 execut\u00e1veis que resolvem o problema do Caixeiro Viajante . busca-local-1 - implementa\u00e7\u00e3o de um m\u00e9todo de busca r\u00e1pida, por\u00e9m n\u00e3o \u00f3tima. busca-local-1-par - implementa\u00e7\u00e3o paralela do programa acima. busca-local-2 - implementa\u00e7\u00e3o alternativa do mesmo m\u00e9todo acima. Os resultados de ambos s\u00e3o id\u00eanticos. busca-local-2-par - implementa\u00e7\u00e3o paralela do programa acima. Important N\u00e3o estamos interessados no Caixeiro Viajante em si hoje. Queremos \u00e9 comparar diferentes maneiras de resolv\u00ea-lo para entendermos o papel de t\u00e9cnicas de SuperComputa\u00e7\u00e3o na velocidade de processamento e nos resultados obtidos.","title":"Problemas estudados em SuperComputa\u00e7\u00e3o"},{"location":"aulas/01-introducao/#ferramental","text":"Realizar testes de maneira automatizada \u00e9 muito importante para quantificar os efeitos de diferentes algoritmos e t\u00e9cnicas de paralelismo. O snippet abaixo executa import subprocess import time with open ( 'entradas-busca-local/in-0.txt' ) as f : start = time . perf_counter () proc = subprocess . run ([ './busca-local-1' ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () print ( 'Sa\u00edda:' , proc . stdout ) print ( 'Stderr:' , proc . stderr ) print ( 'Tempo total(s):' , end - start ) Sa\u00edda: 232.234 0 3 0 4 1 2 Stderr: Tempo total(s): 0.013778032999653078 Vamos agora praticar usar este snippet para executar nossos testes automaticamente. Example Crie uma fun\u00e7\u00e3o roda_com_entrada(executavel, arquivo_in) que roda o primeiro argumento usando como entrada o conte\u00fado do segundo argumento. Teste seu c\u00f3digo com o execut\u00e1vel busca-local-1 e com o arquivo de entrada in-0.txt usado no exemplo acima. Sua fun\u00e7\u00e3o dever\u00e1 devolver uma tupla (stdout,time) com stdout sendo a sa\u00edda do programa e time seu tempo de execu\u00e7\u00e3o em segundos. def roda ( ex , in_f ): with open ( in_f ) as f : start = time . perf_counter () proc = subprocess . run ([ ex ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () return proc . stdout , end - start roda ( './busca-local-1' , 'entradas-busca-local/in-0.txt' ) ('232.234 0\\n3 0 4 1 2 \\n', 0.009169607999865548)","title":"Ferramental"},{"location":"aulas/01-introducao/#algoritmos-sequenciais","text":"Com esse c\u00f3digo, vamos criar um relat\u00f3rio interativo que roda nossos testes automaticamente e j\u00e1 plota informa\u00e7\u00f5es prontas para nossas an\u00e1lises. Vamos come\u00e7ar examinando o desempenho do execut\u00e1vel busca-local-1 . Example Rode o busca-local com os arquivos de entrada na pasta entradas-busca-local . Guarde os tempos em uma lista. Example Leia o tamanho das entradas dos arquivos na pasta entradas-busca-local e guarde em uma segunda lista. Example Plote o tempo de execu\u00e7\u00e3o pelo tamanho da entrada usando matplotlib arqs = [ f 'entradas-busca-local/in- { i } .txt' for i in range ( 10 )] tempos = [ roda ( './busca-local-1' , arq )[ 1 ] for arq in arqs ] N = [] for arq in arqs : with open ( arq ) as f : n = int ( f . readlines ()[ 0 ]) N . append ( n ) print ( N ) import matplotlib.pyplot as plt plt . plot ( tempos ) [<matplotlib.lines.Line2D at 0x7fe533947550>] 2021-02-24T14:47:06.578856 image/svg+xml Matplotlib v3.3.4, https://matplotlib.org/ *{stroke-linecap:butt;stroke-linejoin:round;} Example Repita os tr\u00eas passos acima para o execut\u00e1vel busca-local-2 . Finalize plotando os tempos de execu\u00e7\u00e3o de ambos os execut\u00e1veis no mesmo gr\u00e1fico. tempos2 = [ roda ( './busca-local-2' , arq )[ 1 ] for arq in arqs ] plt . plot ( tempos ) plt . plot ( tempos2 ) [<matplotlib.lines.Line2D at 0x7fe5335e47c0>] 2021-02-24T14:48:22.282797 image/svg+xml Matplotlib v3.3.4, https://matplotlib.org/ *{stroke-linecap:butt;stroke-linejoin:round;} Example Segundo uma coleta de dados informal e altamente confi\u00e1vel, 93,17% dos alunos n\u00e3o colocam legendas nem t\u00edtulos nos gr\u00e1ficos gerados. Fa\u00e7a isso agora. Question Interprete o gr\u00e1fico que voc\u00ea gerou na linha de cima. Question Compare manualmente a sa\u00edda dos programas. Existe diferen\u00e7a em seus resultados? Question Resgate seus conhecimentos de Desafios de Programa\u00e7\u00e3o e explique a diferen\u00e7a entre os algoritmos.","title":"Algoritmos sequenciais"},{"location":"aulas/01-introducao/#algoritmos-paralelos","text":"Na discuss\u00e3o inicial da expositiva chegamos \u00e0 conclus\u00e3o de que se conseguimos realizar N opera\u00e7\u00f5es em paralelo teremos um ganho de no m\u00e1ximo N vezes no desempenho de nosso programa. Nesta parte iremos estudar esta afirma\u00e7\u00e3o usando implementa\u00e7\u00f5es paralelas dos algoritmos da se\u00e7\u00e3o anterior. Example Execute os algoritmos paralelos com as mesmas entradas e compare com suas vers\u00f5es paralelas. Use um gr\u00e1fico para facilitar as compara\u00e7\u00f5es Question Compare os tempos obtidos. Qual foi o ganho m\u00e9dio? Quantos n\u00facleos a m\u00e1quina que voc\u00ea est\u00e1 usando possui? Responda comparando cada algoritmo sequencial com sua vers\u00e3o paralela. J\u00e1 estabelecemos que busca-local-2 \u00e9 melhor que busca-local-1 por ser utilizar um algoritmo mais eficiente e vimos na pr\u00e1tica a diferen\u00e7a entre um algoritmo O(n^3) O(n^3) e um algoritmo O(n^2) O(n^2) . Vamos agora examinar a seguinte quest\u00e3o. \u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2 ? Example Compare o desempenho de busca-local-1-par com busca-local-2 . Fa\u00e7a um gr\u00e1fico Question Com base em seu gr\u00e1fico acima, responda a pergunta: \"\u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2?\" Vamos agora generalizar a pergunta: Question Dados dois algoritmos com complexidades computacionais diferentes, sendo que o primeiro \u00e9 inferior ao segundo. \u00c9 poss\u00edvel usar paralelismo para tornar o primeiro mais r\u00e1pido que o segundo para todos tamanhos de entrada? Assuma que voc\u00ea possui um n\u00famero fixo de n\u00facleos .","title":"Algoritmos paralelos"},{"location":"aulas/02-03-implementacao-c%2B%2B/","text":"02/03 - Implementa\u00e7\u00e3o em C++ \u00b6 A disciplina utilizar\u00e1 a linguagem C++ para implementa\u00e7\u00e3o dos programas. Ela \u00e9 muito usada em implementa\u00e7\u00f5es de alto desempenho e possui recursos muito \u00fateis e que simplificam a programa\u00e7\u00e3o se comparada com C puro. Nas aulas 02 e 03 aprenderemos alguns desses recursos e os utilizaremos para implementa\u00e7\u00e3o de algoritmos simples. Gabaritos e respostas Este curso n\u00e3o fornece c\u00f3digo de resposta para os exerc\u00edcios de sala. Cada exerc\u00edcio \u00e9 acompanhado de um algoritmo em pseudo-c\u00f3digo e alguns pares de arquivos entrada/sa\u00edda. Isto j\u00e1 \u00e9 suficiente para que voc\u00eas verifiquem se sua solu\u00e7\u00e3o est\u00e1 correta. Boas pr\u00e1ticas de programa\u00e7\u00e3o ser\u00e3o demonstradas em exerc\u00edcios corrigidos pelo professor durante o semestre. Compila\u00e7\u00e3o \u00b6 Programas em C++ s\u00e3o compilados com o comando g++ . Ele funciona igual ao gcc que voc\u00eas j\u00e1 usaram em Desafios e Sistemas Hardware-Software. $> g++ -Wall -O3 arquivo.cpp -o executavel Entrada e sa\u00edda em C++ \u00b6 Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream). A maior vantagem de usar cin e cout \u00e9 que n\u00e3o precisamos mais daquelas strings de formata\u00e7\u00e3o estranhas com %d , %s e afins. Podemos passar vari\u00e1veis diretamente para a sa\u00edda do terminal usando o operador << . Veja um exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << \"Sa\u00edda: \" << a << \";\" << b << \" \\n \" ; Example Crie um arquivo entrada-saida.cpp com uma fun\u00e7\u00e3o main que roda o c\u00f3digo acima. Compile e execute seu programa e verifique que ele mostra o valor correto no terminal. O mesmo vale para a entrada, mas desta vez \"tiramos\" os dados do objeto std::cin . O exemplo abaixo l\u00ea um inteiro e um double do terminal. int a ; double b ; std :: cin >> a >> b ; Example Modifique seu programa entrada-saida.cpp para ler \u00ea um n\u00famero inteiro n e mostrar sua divis\u00e3o fracion\u00e1ria por 2. Ou seja, antes de dividir converta n para double . E esse std:: ? Em C++ podemos ter v\u00e1rias fun\u00e7\u00f5es, vari\u00e1veis e objetos em geral com o mesmo nome. Para evitar que eles colidam e n\u00e3o se saiba a qual estamos nos referindo cada nome deve ser definido um namespace (literalmente espaco de nomes ). Podemos ter namespace s aninhados.Por exemplo, std::chrono cont\u00e9m as fun\u00e7\u00f5es relacionadas contagem de tempo durante a execu\u00e7\u00e3o de um programa. Todas as fun\u00e7\u00f5es, classes e globais na biblioteca padr\u00e3o est\u00e3o definidas no espa\u00e7o std . Se quisermos, podemos omitir escrever std:: toda vez digitando using namespace std . Isso pode ser feito tamb\u00e9m com namespaces aninhados. A implementa\u00e7\u00e3o de algoritmos definidos usando express\u00f5es matem\u00e1ticas \u00e9 uma habilidade importante neste curso. Example Escreva um programa que receba um inteiro n e calcule a seguinte s\u00e9rie. S = \\sum_{i=0}^n \\frac{1}{2^i} S = \\sum_{i=0}^n \\frac{1}{2^i} Mostre as primeiras 15 casas decimais de S . Veja a documenta\u00e7\u00e3o de std::setprecision aqui . Resposta Essa s\u00e9rie converge para o n\u00famero 2, mas sua resposta dever\u00e1 ser sempre menor que este n\u00famero. Logo, quanto maior n mais pr\u00f3xima sua resposta ser\u00e1. Seu programa dever\u00e1 implementar algo como o algoritmo abaixo. leia inteiro n s = 0.0 para i=0 at\u00e9 n s += 1 / (2 elevado a i) print(s) Aloca\u00e7\u00e3o de mem\u00f3ria e vetores em C++ \u00b6 Em C usamos as fun\u00e7\u00f5es malloc e free para alocar mem\u00f3ria dinamicamente. Um inconveniente dessas fun\u00e7\u00f5es \u00e9 que sempre temos que passar o tamanho que queremos em bytes. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m est\u00e3o dispon\u00edveis, mas us\u00e1-las \u00e9 considerado uma m\u00e1 pr\u00e1tica. Ao inv\u00e9s, usamos os operadores new e delete para alocar mem\u00f3ria. Existem duas vantagens em us\u00e1-los. Podemos escrever diretamente o tipo que queremos, em vez de seu tamanho em bytes. A aloca\u00e7\u00e3o de arrays \u00e9 feita de maneira natural usando os colchetes [] . Vejamos o exemplo abaixo. int n ; std :: cin >> n ; double * values = new double [ n ]; /* usar values aqui */ delete [] values ; \u00c9 alocado um vetor de double de tamanho n (lido do terminal). Ap\u00f3s ele ser usado liberamos o espa\u00e7o alocado usando delete[] . E se eu quiser alocar um s\u00f3 valor? \u00c9 simples! \u00c9 s\u00f3 usar new sem os colchetes [] ! Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Resposta Use o programa t4.py para gerar entradas e sa\u00eddas de teste para seu programa. Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas? Resposta M\u00e9dia e vari\u00e2ncia. Apesar do uso de new[] e delete[] mostrado na se\u00e7\u00e3o anterior j\u00e1 ser mais conveniente, ainda s\u00e3o essencialmente um programa em C com sintaxe ligeiramente mais agrad\u00e1vel. Para tornar a programa\u00e7\u00e3o em C++ mais produtiva sua biblioteca padr\u00e3o conta com estruturas de dados prontas para uso. A estrutura std::vector \u00e9 um vetor din\u00e2mico que tem funcionalidades parecidas com a lista de Python ou o ArrayList de Java. O c\u00f3digo abaixo exemplifica seu uso e mostra algumas de suas fun\u00e7\u00f5es. Note que omitimos o uso de std no c\u00f3digo abaixo. int n ; cin >> n ; vector < double > vec ; for ( int i = 0 ; i < n ; i ++ ) { vec . push_back ( i * i ) } cout << \"Tamanho do vetor: \" << vec . size () << \" \\n \" ; cout << \"Primeiro elemento: \" << vec . front () << \" \\n \" ; cout << \"\u00daltimo elemento: \" << vec . back () << \" \\n \" ; cout << \"Elemento 3: \" << vec [ 2 ] << \" \\n \" ; Alguns pontos interessantes deste exemplo: N\u00e3o sabemos o tamanho de vec ao cri\u00e1-lo. O m\u00e9todo push_back aumenta ele quando necess\u00e1rio e n\u00e3o precisamos nos preocupar com isso. O n\u00famero de elementos colocados no vetor \u00e9 retornado pelo m\u00e9todo size() O acesso \u00e9 feito exatamente igual ao array de C, usando os colchetes [] E esse <double> na declara\u00e7\u00e3o? Em C++ tipos passados entre < > s\u00e3o usados para parametrizar tipos gen\u00e9ricos. Ou seja, um vetor pode guardar qualquer tipo de dado e precisamos indicar qual ao cri\u00e1-lo. Note que, portanto, um vetor vector<int> e um vetor vector<double> s\u00e3o considerados de tipos diferentes e n\u00e3o posso passar o primeiro para uma fun\u00e7\u00e3o esperando o segundo. Example Modifique sua Tarefa 4 para usar vector . Verifique que o programa continua produzindo os mesmos resultados. Matrizes (vers\u00e3o 1) \u00b6 Dados N pontos com coordenadas (x_i, y_i)_{i=0}^N (x_i, y_i)_{i=0}^N , computar a matriz de dist\u00e2ncias D D tal que D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) Tip Use t6.py para gerar os arquivos de entrada/sa\u00edda da tarefa abaixo. Example Implemente um programa que calcule a matriz D acima. Sua entrada dever\u00e1 estar no formato dos arquivos t6-in-*.txt e sua sa\u00edda no formato dos arquivos t6-out-*.txt . Mostre as dist\u00e2ncias com 2 casas decimais. Dicas : a maneira mais f\u00e1cil (n\u00e3o necessariamente a melhor) de alocar uma matriz \u00e9 usando um vetor em que cada elemento \u00e9 outro vetor. fa\u00e7a uma implementa\u00e7\u00e3o o mais simples poss\u00edvel. Vamos melhor\u00e1-la nas pr\u00f3ximas tarefas. Resposta leia inteiro N leia vetores X e Y seja D uma matriz NxN para i=1..N: para j=1..N: DX = X[i] - X[j] DY = Y[i] - Y[j] D[i,j] = sqrt(DX*DX + DY*DY) Question Anote abaixo o tempo de execu\u00e7\u00e3o para os arquivos t6-in-*.txt e t6-out-*.txt Question Qual \u00e9 a complexidade computacional de sua implementa\u00e7\u00e3o? Refer\u00eancias e passagem de dados \u00b6 Na parte anterior fizemos nosso programa inteiro no main . Vamos agora organiz\u00e1-lo melhor. Example Crie uma fun\u00e7\u00e3o calcula_distancias que recebe a matriz e os dados recebidos na entrada e a preenche. Sua fun\u00e7\u00e3o n\u00e3o dever\u00e1 retornar nenhum valor. Ao terminar, me\u00e7a o tempo de execu\u00e7\u00e3o para o arquivo t6-out-4.txt . Resposta Aqui podem ocorrer dois problemas: Seu programa deu \"Segmentation Fault\". Seu programa rodou at\u00e9 o fim, mas a sa\u00edda \u00e9 vazia (ou cheia de 0). O problema em si depende de como voc\u00ea fez o for duplo para mostrar os resultados. De qualquer maneira, simplesmente mover c\u00f3digo para uma outra fun\u00e7\u00e3o n\u00e3o funciona neste caso. Ambos problemas descritos na solu\u00e7\u00e3o s\u00e3o previs\u00edveis e ocorrem pela mesma raz\u00e3o: ao passar um vector para uma fun\u00e7\u00e3o \u00e9 feita uma c\u00f3pia de seu conte\u00fado . Ou seja, a matriz usada dentro de calcula_distancias n\u00e3o \u00e9 a mesma do main ! Isto \u00e9 considerado uma feature em C++ : por padr\u00e3o toda vari\u00e1vel \u00e9 passada por c\u00f3pia . Isto evita que uma fun\u00e7\u00e3o modifique um valor sem que o c\u00f3digo chamador fique sabendo. Em C podemos passar vari\u00e1veis por refer\u00eancia passando um ponteiro para elas. Apesar de funcional, isso n\u00e3o \u00e9 muito pr\u00e1tico pois temos que acessar a vari\u00e1vel sempre usando * . Em C++ temos um novo recurso: refer\u00eancias. Ao declarar uma vari\u00e1vel como uma refer\u00eancia crio uma esp\u00e9cie de ponteiro constante que sempre acessa a vari\u00e1vel apontada. Veja o exemplo abaixo. int x = 10 ; int & ref = x ; // refer\u00eancias s\u00e3o declaradas colocando & na frente do nome da vari\u00e1vel // a partir daqui ref e x representam a mesma vari\u00e1vel ref = 15 ; cout << x << \" \\n \" ; // 15 O mesmo poderia ser feito com ponteiros (como mostrado abaixo). A grande vantagem da refer\u00eancia \u00e9 que n\u00e3o precisamos usar *ref para nos referirmos \u00e0 vari\u00e1vel x ! Na atribui\u00e7\u00e3o tamb\u00e9m podemos usar direto int &ref = x , o que torna o c\u00f3digo mais limpo e f\u00e1cil de entender. int x = 10 ; int * ref = & x ; // precisamos de &x para apontar ref para a vari\u00e1vel x * ref = 15 ; // precisamos indicar *ref para atribuir a vari\u00e1vel x cout << x << \" \\n \" ; // 15 Dicas Note que uma refer\u00eancia tem que ser inicializada com a vari\u00e1vel a que ela se refere. Ou seja, ao declarar tenho que j\u00e1 indicar a vari\u00e1vel destino e esse destino n\u00e3o pode ser modificado. Example Modifique sua fun\u00e7\u00e3o para usar refer\u00eancias. Verifique que ele volta a funcionar e que seu tempo de execu\u00e7\u00e3o continua parecido com a vers\u00e3o que rodava no main . Resposta Basta adicionar & na frente dos nomes dos argumentos (vetores x, y e matriz). A chamada da fun\u00e7\u00e3o n\u00e3o muda. Dica Em C++ precisamos estar sempre atentos \u00e0 maneira que passamos os dados. Se n\u00e3o indicarmos ser\u00e1 por c\u00f3pia. Para compartilhar o mesmo objeto entre v\u00e1rias fun\u00e7\u00f5es usamos refer\u00eancias & . Uma primeira otimiza\u00e7\u00e3o \u00b6 Nossa primeira implementa\u00e7\u00e3o \u00e9 bastante direta da defini\u00e7\u00e3o e n\u00e3o tenta ser eficiente. Question Analisando a defini\u00e7ao da Tarefa 1, como seria poss\u00edvel economizar trabalho? Resposta Podemos ver que a matriz D \u00e9 sim\u00e9trica. Ou seja, D[i,j] == D[j,i] . Isso significa que poder\u00edamos calcular s\u00f3 um deles e copiar o valor para a outra posi\u00e7\u00e3o. Question Como isso poderia ser usado para melhorar o tempo de execu\u00e7\u00e3o de calcula_distancias ? Question Seu programa criado na tarefa 1 consegue ser adaptado para implementar sua ideia da quest\u00e3o anterior? O que precisaria ser modificado? Resposta Duas respostas s\u00e3o poss\u00edveis e corretas aqui: Preciso checar se o i > j e usar o valor j\u00e1 calculado de D[j,i] . \u00c9 preciso alocar a matriz inteira antes de come\u00e7ar. Se formos dando push_back linha a linha n\u00e3o conseguimos atribuir um valor ao mesmo tempo a D[i,j] e D[j,i] , j\u00e1 que um deles ainda n\u00e3o ter\u00e1 sido criado. Baseado na resposta acima vamos tentar nossa primeira otimiza\u00e7\u00e3o: s\u00f3 vamos calcular D[i,j] para i <= j (ou seja, s\u00f3 a metade \"de cima\" de D ). Example Use a estrat\u00e9gia acima para evitar calcular a matriz inteira. Verifique se houve melhora no tempo do teste t6-in-3.txt . Dica : tente de novo usar a ideia mais simples poss\u00edvel e implemente adicionando um so if no seu programa. Resposta N\u00e3o dever\u00e1 haver ganho de desempenho significativo. Veremos exatamente o por que na pr\u00f3xima aula.","title":"02/03 - Implementa\u00e7\u00e3o em C++"},{"location":"aulas/02-03-implementacao-c%2B%2B/#0203-implementacao-em-c","text":"A disciplina utilizar\u00e1 a linguagem C++ para implementa\u00e7\u00e3o dos programas. Ela \u00e9 muito usada em implementa\u00e7\u00f5es de alto desempenho e possui recursos muito \u00fateis e que simplificam a programa\u00e7\u00e3o se comparada com C puro. Nas aulas 02 e 03 aprenderemos alguns desses recursos e os utilizaremos para implementa\u00e7\u00e3o de algoritmos simples. Gabaritos e respostas Este curso n\u00e3o fornece c\u00f3digo de resposta para os exerc\u00edcios de sala. Cada exerc\u00edcio \u00e9 acompanhado de um algoritmo em pseudo-c\u00f3digo e alguns pares de arquivos entrada/sa\u00edda. Isto j\u00e1 \u00e9 suficiente para que voc\u00eas verifiquem se sua solu\u00e7\u00e3o est\u00e1 correta. Boas pr\u00e1ticas de programa\u00e7\u00e3o ser\u00e3o demonstradas em exerc\u00edcios corrigidos pelo professor durante o semestre.","title":"02/03 - Implementa\u00e7\u00e3o em C++"},{"location":"aulas/02-03-implementacao-c%2B%2B/#compilacao","text":"Programas em C++ s\u00e3o compilados com o comando g++ . Ele funciona igual ao gcc que voc\u00eas j\u00e1 usaram em Desafios e Sistemas Hardware-Software. $> g++ -Wall -O3 arquivo.cpp -o executavel","title":"Compila\u00e7\u00e3o"},{"location":"aulas/02-03-implementacao-c%2B%2B/#entrada-e-saida-em-c","text":"Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream). A maior vantagem de usar cin e cout \u00e9 que n\u00e3o precisamos mais daquelas strings de formata\u00e7\u00e3o estranhas com %d , %s e afins. Podemos passar vari\u00e1veis diretamente para a sa\u00edda do terminal usando o operador << . Veja um exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << \"Sa\u00edda: \" << a << \";\" << b << \" \\n \" ; Example Crie um arquivo entrada-saida.cpp com uma fun\u00e7\u00e3o main que roda o c\u00f3digo acima. Compile e execute seu programa e verifique que ele mostra o valor correto no terminal. O mesmo vale para a entrada, mas desta vez \"tiramos\" os dados do objeto std::cin . O exemplo abaixo l\u00ea um inteiro e um double do terminal. int a ; double b ; std :: cin >> a >> b ; Example Modifique seu programa entrada-saida.cpp para ler \u00ea um n\u00famero inteiro n e mostrar sua divis\u00e3o fracion\u00e1ria por 2. Ou seja, antes de dividir converta n para double . E esse std:: ? Em C++ podemos ter v\u00e1rias fun\u00e7\u00f5es, vari\u00e1veis e objetos em geral com o mesmo nome. Para evitar que eles colidam e n\u00e3o se saiba a qual estamos nos referindo cada nome deve ser definido um namespace (literalmente espaco de nomes ). Podemos ter namespace s aninhados.Por exemplo, std::chrono cont\u00e9m as fun\u00e7\u00f5es relacionadas contagem de tempo durante a execu\u00e7\u00e3o de um programa. Todas as fun\u00e7\u00f5es, classes e globais na biblioteca padr\u00e3o est\u00e3o definidas no espa\u00e7o std . Se quisermos, podemos omitir escrever std:: toda vez digitando using namespace std . Isso pode ser feito tamb\u00e9m com namespaces aninhados. A implementa\u00e7\u00e3o de algoritmos definidos usando express\u00f5es matem\u00e1ticas \u00e9 uma habilidade importante neste curso. Example Escreva um programa que receba um inteiro n e calcule a seguinte s\u00e9rie. S = \\sum_{i=0}^n \\frac{1}{2^i} S = \\sum_{i=0}^n \\frac{1}{2^i} Mostre as primeiras 15 casas decimais de S . Veja a documenta\u00e7\u00e3o de std::setprecision aqui . Resposta Essa s\u00e9rie converge para o n\u00famero 2, mas sua resposta dever\u00e1 ser sempre menor que este n\u00famero. Logo, quanto maior n mais pr\u00f3xima sua resposta ser\u00e1. Seu programa dever\u00e1 implementar algo como o algoritmo abaixo. leia inteiro n s = 0.0 para i=0 at\u00e9 n s += 1 / (2 elevado a i) print(s)","title":"Entrada e sa\u00edda em C++"},{"location":"aulas/02-03-implementacao-c%2B%2B/#alocacao-de-memoria-e-vetores-em-c","text":"Em C usamos as fun\u00e7\u00f5es malloc e free para alocar mem\u00f3ria dinamicamente. Um inconveniente dessas fun\u00e7\u00f5es \u00e9 que sempre temos que passar o tamanho que queremos em bytes. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m est\u00e3o dispon\u00edveis, mas us\u00e1-las \u00e9 considerado uma m\u00e1 pr\u00e1tica. Ao inv\u00e9s, usamos os operadores new e delete para alocar mem\u00f3ria. Existem duas vantagens em us\u00e1-los. Podemos escrever diretamente o tipo que queremos, em vez de seu tamanho em bytes. A aloca\u00e7\u00e3o de arrays \u00e9 feita de maneira natural usando os colchetes [] . Vejamos o exemplo abaixo. int n ; std :: cin >> n ; double * values = new double [ n ]; /* usar values aqui */ delete [] values ; \u00c9 alocado um vetor de double de tamanho n (lido do terminal). Ap\u00f3s ele ser usado liberamos o espa\u00e7o alocado usando delete[] . E se eu quiser alocar um s\u00f3 valor? \u00c9 simples! \u00c9 s\u00f3 usar new sem os colchetes [] ! Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Resposta Use o programa t4.py para gerar entradas e sa\u00eddas de teste para seu programa. Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas? Resposta M\u00e9dia e vari\u00e2ncia. Apesar do uso de new[] e delete[] mostrado na se\u00e7\u00e3o anterior j\u00e1 ser mais conveniente, ainda s\u00e3o essencialmente um programa em C com sintaxe ligeiramente mais agrad\u00e1vel. Para tornar a programa\u00e7\u00e3o em C++ mais produtiva sua biblioteca padr\u00e3o conta com estruturas de dados prontas para uso. A estrutura std::vector \u00e9 um vetor din\u00e2mico que tem funcionalidades parecidas com a lista de Python ou o ArrayList de Java. O c\u00f3digo abaixo exemplifica seu uso e mostra algumas de suas fun\u00e7\u00f5es. Note que omitimos o uso de std no c\u00f3digo abaixo. int n ; cin >> n ; vector < double > vec ; for ( int i = 0 ; i < n ; i ++ ) { vec . push_back ( i * i ) } cout << \"Tamanho do vetor: \" << vec . size () << \" \\n \" ; cout << \"Primeiro elemento: \" << vec . front () << \" \\n \" ; cout << \"\u00daltimo elemento: \" << vec . back () << \" \\n \" ; cout << \"Elemento 3: \" << vec [ 2 ] << \" \\n \" ; Alguns pontos interessantes deste exemplo: N\u00e3o sabemos o tamanho de vec ao cri\u00e1-lo. O m\u00e9todo push_back aumenta ele quando necess\u00e1rio e n\u00e3o precisamos nos preocupar com isso. O n\u00famero de elementos colocados no vetor \u00e9 retornado pelo m\u00e9todo size() O acesso \u00e9 feito exatamente igual ao array de C, usando os colchetes [] E esse <double> na declara\u00e7\u00e3o? Em C++ tipos passados entre < > s\u00e3o usados para parametrizar tipos gen\u00e9ricos. Ou seja, um vetor pode guardar qualquer tipo de dado e precisamos indicar qual ao cri\u00e1-lo. Note que, portanto, um vetor vector<int> e um vetor vector<double> s\u00e3o considerados de tipos diferentes e n\u00e3o posso passar o primeiro para uma fun\u00e7\u00e3o esperando o segundo. Example Modifique sua Tarefa 4 para usar vector . Verifique que o programa continua produzindo os mesmos resultados.","title":"Aloca\u00e7\u00e3o de mem\u00f3ria e vetores em C++"},{"location":"aulas/02-03-implementacao-c%2B%2B/#matrizes-versao-1","text":"Dados N pontos com coordenadas (x_i, y_i)_{i=0}^N (x_i, y_i)_{i=0}^N , computar a matriz de dist\u00e2ncias D D tal que D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j) Tip Use t6.py para gerar os arquivos de entrada/sa\u00edda da tarefa abaixo. Example Implemente um programa que calcule a matriz D acima. Sua entrada dever\u00e1 estar no formato dos arquivos t6-in-*.txt e sua sa\u00edda no formato dos arquivos t6-out-*.txt . Mostre as dist\u00e2ncias com 2 casas decimais. Dicas : a maneira mais f\u00e1cil (n\u00e3o necessariamente a melhor) de alocar uma matriz \u00e9 usando um vetor em que cada elemento \u00e9 outro vetor. fa\u00e7a uma implementa\u00e7\u00e3o o mais simples poss\u00edvel. Vamos melhor\u00e1-la nas pr\u00f3ximas tarefas. Resposta leia inteiro N leia vetores X e Y seja D uma matriz NxN para i=1..N: para j=1..N: DX = X[i] - X[j] DY = Y[i] - Y[j] D[i,j] = sqrt(DX*DX + DY*DY) Question Anote abaixo o tempo de execu\u00e7\u00e3o para os arquivos t6-in-*.txt e t6-out-*.txt Question Qual \u00e9 a complexidade computacional de sua implementa\u00e7\u00e3o?","title":"Matrizes (vers\u00e3o 1)"},{"location":"aulas/02-03-implementacao-c%2B%2B/#referencias-e-passagem-de-dados","text":"Na parte anterior fizemos nosso programa inteiro no main . Vamos agora organiz\u00e1-lo melhor. Example Crie uma fun\u00e7\u00e3o calcula_distancias que recebe a matriz e os dados recebidos na entrada e a preenche. Sua fun\u00e7\u00e3o n\u00e3o dever\u00e1 retornar nenhum valor. Ao terminar, me\u00e7a o tempo de execu\u00e7\u00e3o para o arquivo t6-out-4.txt . Resposta Aqui podem ocorrer dois problemas: Seu programa deu \"Segmentation Fault\". Seu programa rodou at\u00e9 o fim, mas a sa\u00edda \u00e9 vazia (ou cheia de 0). O problema em si depende de como voc\u00ea fez o for duplo para mostrar os resultados. De qualquer maneira, simplesmente mover c\u00f3digo para uma outra fun\u00e7\u00e3o n\u00e3o funciona neste caso. Ambos problemas descritos na solu\u00e7\u00e3o s\u00e3o previs\u00edveis e ocorrem pela mesma raz\u00e3o: ao passar um vector para uma fun\u00e7\u00e3o \u00e9 feita uma c\u00f3pia de seu conte\u00fado . Ou seja, a matriz usada dentro de calcula_distancias n\u00e3o \u00e9 a mesma do main ! Isto \u00e9 considerado uma feature em C++ : por padr\u00e3o toda vari\u00e1vel \u00e9 passada por c\u00f3pia . Isto evita que uma fun\u00e7\u00e3o modifique um valor sem que o c\u00f3digo chamador fique sabendo. Em C podemos passar vari\u00e1veis por refer\u00eancia passando um ponteiro para elas. Apesar de funcional, isso n\u00e3o \u00e9 muito pr\u00e1tico pois temos que acessar a vari\u00e1vel sempre usando * . Em C++ temos um novo recurso: refer\u00eancias. Ao declarar uma vari\u00e1vel como uma refer\u00eancia crio uma esp\u00e9cie de ponteiro constante que sempre acessa a vari\u00e1vel apontada. Veja o exemplo abaixo. int x = 10 ; int & ref = x ; // refer\u00eancias s\u00e3o declaradas colocando & na frente do nome da vari\u00e1vel // a partir daqui ref e x representam a mesma vari\u00e1vel ref = 15 ; cout << x << \" \\n \" ; // 15 O mesmo poderia ser feito com ponteiros (como mostrado abaixo). A grande vantagem da refer\u00eancia \u00e9 que n\u00e3o precisamos usar *ref para nos referirmos \u00e0 vari\u00e1vel x ! Na atribui\u00e7\u00e3o tamb\u00e9m podemos usar direto int &ref = x , o que torna o c\u00f3digo mais limpo e f\u00e1cil de entender. int x = 10 ; int * ref = & x ; // precisamos de &x para apontar ref para a vari\u00e1vel x * ref = 15 ; // precisamos indicar *ref para atribuir a vari\u00e1vel x cout << x << \" \\n \" ; // 15 Dicas Note que uma refer\u00eancia tem que ser inicializada com a vari\u00e1vel a que ela se refere. Ou seja, ao declarar tenho que j\u00e1 indicar a vari\u00e1vel destino e esse destino n\u00e3o pode ser modificado. Example Modifique sua fun\u00e7\u00e3o para usar refer\u00eancias. Verifique que ele volta a funcionar e que seu tempo de execu\u00e7\u00e3o continua parecido com a vers\u00e3o que rodava no main . Resposta Basta adicionar & na frente dos nomes dos argumentos (vetores x, y e matriz). A chamada da fun\u00e7\u00e3o n\u00e3o muda. Dica Em C++ precisamos estar sempre atentos \u00e0 maneira que passamos os dados. Se n\u00e3o indicarmos ser\u00e1 por c\u00f3pia. Para compartilhar o mesmo objeto entre v\u00e1rias fun\u00e7\u00f5es usamos refer\u00eancias & .","title":"Refer\u00eancias e passagem de dados"},{"location":"aulas/02-03-implementacao-c%2B%2B/#uma-primeira-otimizacao","text":"Nossa primeira implementa\u00e7\u00e3o \u00e9 bastante direta da defini\u00e7\u00e3o e n\u00e3o tenta ser eficiente. Question Analisando a defini\u00e7ao da Tarefa 1, como seria poss\u00edvel economizar trabalho? Resposta Podemos ver que a matriz D \u00e9 sim\u00e9trica. Ou seja, D[i,j] == D[j,i] . Isso significa que poder\u00edamos calcular s\u00f3 um deles e copiar o valor para a outra posi\u00e7\u00e3o. Question Como isso poderia ser usado para melhorar o tempo de execu\u00e7\u00e3o de calcula_distancias ? Question Seu programa criado na tarefa 1 consegue ser adaptado para implementar sua ideia da quest\u00e3o anterior? O que precisaria ser modificado? Resposta Duas respostas s\u00e3o poss\u00edveis e corretas aqui: Preciso checar se o i > j e usar o valor j\u00e1 calculado de D[j,i] . \u00c9 preciso alocar a matriz inteira antes de come\u00e7ar. Se formos dando push_back linha a linha n\u00e3o conseguimos atribuir um valor ao mesmo tempo a D[i,j] e D[j,i] , j\u00e1 que um deles ainda n\u00e3o ter\u00e1 sido criado. Baseado na resposta acima vamos tentar nossa primeira otimiza\u00e7\u00e3o: s\u00f3 vamos calcular D[i,j] para i <= j (ou seja, s\u00f3 a metade \"de cima\" de D ). Example Use a estrat\u00e9gia acima para evitar calcular a matriz inteira. Verifique se houve melhora no tempo do teste t6-in-3.txt . Dica : tente de novo usar a ideia mais simples poss\u00edvel e implemente adicionando um so if no seu programa. Resposta N\u00e3o dever\u00e1 haver ganho de desempenho significativo. Veremos exatamente o por que na pr\u00f3xima aula.","title":"Uma primeira otimiza\u00e7\u00e3o"},{"location":"aulas/04-profiling/","text":"04 - Medi\u00e7\u00e3o de desempenho \u00b6 Apesar de podermos medir o tempo que nosso programa demora usando o comando time , n\u00e3o conseguimos nenhuma informa\u00e7\u00e3o importante de qual parte do programa est\u00e1 consumindo mais tempo. Este processo de dissecar um programa e entender exatamente qual parte demora quanto \u00e9 chamada de Profiling . Software Para esta aula precisaremos dos seguintes pacotes instalados. valgrind - ferramenta de an\u00e1lise de c\u00f3digo execut\u00e1vel kcachegrind - visualizador de resultados do valgrind Prepara\u00e7\u00e3o \u00b6 \u00c9 preciso compilar um execut\u00e1vel com profiling habilitado para medir os tempos. g++ -g euclides-ingenuo.cpp -o euclides-ingenuo Ap\u00f3s este passo, devemos executar o programa usando o valgrind com as op\u00e7\u00f5es abaixo. valgrind --tool=callgrind ./seu_exec < entrada > saida Para mostrar os resultados usando o kcachegrind usamos o seguinte comando. kcachegrind callgrind.out.(pid aqui) Medindo os tempos no seu pr\u00f3prio programa \u00b6 Na demonstra\u00e7\u00e3o pudemos ver que grande parte do tempo do programa da Tarefa 1 \u00e9 gasto mostrando a sa\u00edda no terminal. Isto nos leva \u00e0 primeira conclus\u00e3o da atividade de hoje: Entrada e sa\u00edda de dados s\u00e3o opera\u00e7\u00f5es muito lentas Example Fa\u00e7a o teste da demonstra\u00e7\u00e3o em seu pr\u00f3prio programa e anote abaixo, para as duas vers\u00f5es de calcula_distancias , o tempo relativo de execu\u00e7\u00e3o o n\u00famero absoluto de instru\u00e7\u00f5es executadas Question O n\u00famero absoluto de intru\u00e7\u00f5es executadas diminuiu significativamente depois de nossa otimiza\u00e7\u00e3o? Teoricamente s\u00f3 calculamos metade da matriz, esse n\u00famero \u00e9 quase metade da vers\u00e3o n\u00e3o otimizada? Voc\u00ea consegue dizer por que? Resposta Deve ter havido uma diminui\u00e7\u00e3o, mas n\u00e3o chega nem perto de metade. Isso ocorre por v\u00e1rias raz\u00f5es: nosso for duplo continua percorrendo a matriz inteira, apesar de s\u00f3 fazer o c\u00e1lculo em metade das posi\u00e7\u00f5es. alocamos a matriz elemento a elemento enquanto fazemos os c\u00e1lculos. Com isso em mente, vamos agora otimizar a fun\u00e7\u00e3o calcula_distancias . J\u00e1 sabemos que o efeito no tempo final n\u00e3o ser\u00e1 grande. Nosso objetivo ent\u00e3o ser\u00e1 verificar a seguinte afirma\u00e7\u00e3o. Dois algoritmos de mesma complexidade computacional podem ter tempos de execu\u00e7\u00e3o muito diferentes Question A resposta da quest\u00e3o anterior indica que s\u00f3 usar um if para evitar o c\u00e1lculo repetido n\u00e3o \u00e9 suficiente. Precisamos efetivamente fazer um for que percorre s\u00f3 metade da matriz. Supondo que a matriz j\u00e1 esteja inteira alocada, escreva em pseudo-c\u00f3digo como faz\u00ea-lo. Resposta para i=1..N: para j=i..N: DX = X[i] - X[j] DY = Y[i] - Y[j] DIST = sqrt(DX*DX + DY*DY) D[i,j] = DIST D[j,i] = DIST Matrizes (vers\u00e3o 2) \u00b6 Nossa implementa\u00e7\u00e3o usando vector<vector<double>> tem um problema s\u00e9rio: ela aloca elemento a elemento uma estrutura grande que j\u00e1 sabemos o tamanho de in\u00edcio. Seria muito melhor se pud\u00e9ssemos alocar todas as N^2 N^2 posi\u00e7\u00f5es da matriz de uma s\u00f3 vez! Fazemos isso trabalhando com um layout de mem\u00f3ria cont\u00ednuo. Ou seja, armazenaremos a matriz linha a linha como um \u00fanico vetor de tamanho n*n . Temos v\u00e1rias vantagens: tempo de aloca\u00e7\u00e3o de mem\u00f3ria \u00e9 reduzido, j\u00e1 que s\u00f3 fazemos uma chamada podemos acessar qualquer posi\u00e7\u00e3o a qualquer momento melhor desempenho de cache A figura abaixo exemplifica esse layout de mem\u00f3ria: Question Em uma matriz de tamanho 4x7 (4 linhas, 7 colunas), qual \u00e9 o elemento do vetor que representa a posi\u00e7\u00e3o 2x5 (linha 3, coluna 6)? Details Estamos considerando que come\u00e7amos a contar as linhas e colunas do zero. A posi\u00e7\u00e3o do vetor \u00e9 19 . Este n\u00famero \u00e9 obtido pela express\u00e3o i * c + j i \u00e9 a linha a ser acessada j \u00e9 a coluna c \u00e9 o n\u00famero de colunas da matriz 19 = 2 * 7 + 5 Tip Conseguimos redimensionar um vetor usando o m\u00e9todo resize , que recebe o novo n\u00famero de elementos do vetor. Example Fa\u00e7a uma terceira vers\u00e3o de calcula_distancias , desta vez usando o layout de mem\u00f3ria acima. Verifique que o programa continua retornando os mesmos resultados que as vers\u00f5es anteriores. Question Rode novamente os testes de profiling e verifique o n\u00famero de instru\u00e7\u00f5es para esta nova vers\u00e3o. Compare este valor com os anteriores e comente.","title":"04 - Medi\u00e7\u00e3o de desempenho"},{"location":"aulas/04-profiling/#04-medicao-de-desempenho","text":"Apesar de podermos medir o tempo que nosso programa demora usando o comando time , n\u00e3o conseguimos nenhuma informa\u00e7\u00e3o importante de qual parte do programa est\u00e1 consumindo mais tempo. Este processo de dissecar um programa e entender exatamente qual parte demora quanto \u00e9 chamada de Profiling . Software Para esta aula precisaremos dos seguintes pacotes instalados. valgrind - ferramenta de an\u00e1lise de c\u00f3digo execut\u00e1vel kcachegrind - visualizador de resultados do valgrind","title":"04 - Medi\u00e7\u00e3o de desempenho"},{"location":"aulas/04-profiling/#preparacao","text":"\u00c9 preciso compilar um execut\u00e1vel com profiling habilitado para medir os tempos. g++ -g euclides-ingenuo.cpp -o euclides-ingenuo Ap\u00f3s este passo, devemos executar o programa usando o valgrind com as op\u00e7\u00f5es abaixo. valgrind --tool=callgrind ./seu_exec < entrada > saida Para mostrar os resultados usando o kcachegrind usamos o seguinte comando. kcachegrind callgrind.out.(pid aqui)","title":"Prepara\u00e7\u00e3o"},{"location":"aulas/04-profiling/#medindo-os-tempos-no-seu-proprio-programa","text":"Na demonstra\u00e7\u00e3o pudemos ver que grande parte do tempo do programa da Tarefa 1 \u00e9 gasto mostrando a sa\u00edda no terminal. Isto nos leva \u00e0 primeira conclus\u00e3o da atividade de hoje: Entrada e sa\u00edda de dados s\u00e3o opera\u00e7\u00f5es muito lentas Example Fa\u00e7a o teste da demonstra\u00e7\u00e3o em seu pr\u00f3prio programa e anote abaixo, para as duas vers\u00f5es de calcula_distancias , o tempo relativo de execu\u00e7\u00e3o o n\u00famero absoluto de instru\u00e7\u00f5es executadas Question O n\u00famero absoluto de intru\u00e7\u00f5es executadas diminuiu significativamente depois de nossa otimiza\u00e7\u00e3o? Teoricamente s\u00f3 calculamos metade da matriz, esse n\u00famero \u00e9 quase metade da vers\u00e3o n\u00e3o otimizada? Voc\u00ea consegue dizer por que? Resposta Deve ter havido uma diminui\u00e7\u00e3o, mas n\u00e3o chega nem perto de metade. Isso ocorre por v\u00e1rias raz\u00f5es: nosso for duplo continua percorrendo a matriz inteira, apesar de s\u00f3 fazer o c\u00e1lculo em metade das posi\u00e7\u00f5es. alocamos a matriz elemento a elemento enquanto fazemos os c\u00e1lculos. Com isso em mente, vamos agora otimizar a fun\u00e7\u00e3o calcula_distancias . J\u00e1 sabemos que o efeito no tempo final n\u00e3o ser\u00e1 grande. Nosso objetivo ent\u00e3o ser\u00e1 verificar a seguinte afirma\u00e7\u00e3o. Dois algoritmos de mesma complexidade computacional podem ter tempos de execu\u00e7\u00e3o muito diferentes Question A resposta da quest\u00e3o anterior indica que s\u00f3 usar um if para evitar o c\u00e1lculo repetido n\u00e3o \u00e9 suficiente. Precisamos efetivamente fazer um for que percorre s\u00f3 metade da matriz. Supondo que a matriz j\u00e1 esteja inteira alocada, escreva em pseudo-c\u00f3digo como faz\u00ea-lo. Resposta para i=1..N: para j=i..N: DX = X[i] - X[j] DY = Y[i] - Y[j] DIST = sqrt(DX*DX + DY*DY) D[i,j] = DIST D[j,i] = DIST","title":"Medindo os tempos no seu pr\u00f3prio programa"},{"location":"aulas/04-profiling/#matrizes-versao-2","text":"Nossa implementa\u00e7\u00e3o usando vector<vector<double>> tem um problema s\u00e9rio: ela aloca elemento a elemento uma estrutura grande que j\u00e1 sabemos o tamanho de in\u00edcio. Seria muito melhor se pud\u00e9ssemos alocar todas as N^2 N^2 posi\u00e7\u00f5es da matriz de uma s\u00f3 vez! Fazemos isso trabalhando com um layout de mem\u00f3ria cont\u00ednuo. Ou seja, armazenaremos a matriz linha a linha como um \u00fanico vetor de tamanho n*n . Temos v\u00e1rias vantagens: tempo de aloca\u00e7\u00e3o de mem\u00f3ria \u00e9 reduzido, j\u00e1 que s\u00f3 fazemos uma chamada podemos acessar qualquer posi\u00e7\u00e3o a qualquer momento melhor desempenho de cache A figura abaixo exemplifica esse layout de mem\u00f3ria: Question Em uma matriz de tamanho 4x7 (4 linhas, 7 colunas), qual \u00e9 o elemento do vetor que representa a posi\u00e7\u00e3o 2x5 (linha 3, coluna 6)? Details Estamos considerando que come\u00e7amos a contar as linhas e colunas do zero. A posi\u00e7\u00e3o do vetor \u00e9 19 . Este n\u00famero \u00e9 obtido pela express\u00e3o i * c + j i \u00e9 a linha a ser acessada j \u00e9 a coluna c \u00e9 o n\u00famero de colunas da matriz 19 = 2 * 7 + 5 Tip Conseguimos redimensionar um vetor usando o m\u00e9todo resize , que recebe o novo n\u00famero de elementos do vetor. Example Fa\u00e7a uma terceira vers\u00e3o de calcula_distancias , desta vez usando o layout de mem\u00f3ria acima. Verifique que o programa continua retornando os mesmos resultados que as vers\u00f5es anteriores. Question Rode novamente os testes de profiling e verifique o n\u00famero de instru\u00e7\u00f5es para esta nova vers\u00e3o. Compare este valor com os anteriores e comente.","title":"Matrizes (vers\u00e3o 2)"},{"location":"aulas/05-heuristicas/","text":"05 - Heur\u00edsticas \u00b6 A atividade pr\u00e1tica de hoje consiste em implementar heur\u00edsticas para a solu\u00e7\u00e3o do problema da Mochila bin\u00e1ria . Resumo do problema \u00b6 Dados N objetos e uma mochila que comporta at\u00e9 W quilos, cada um com peso w_i w_i e valor v_i v_i , selecionar objetos com o maior valor poss\u00edvel que caibam dentro da mochila. Entrada : N W w1 v1 .... wN vN Sa\u00edda : W V opt o1 ... oT W - peso dos objetos selecionados V - valor dos objetos selecionados opt 0 se for usada uma heur\u00edstica ou busca local 1 se a solu\u00e7\u00e3o for \u00f3timo global oi s\u00e3o os \u00edndices ( em ordem crescente ) dos objetos selecionados Tip Arquivos para verificar a corretude das suas implementa\u00e7\u00f5es est\u00e3o dispon\u00edveis nesta pasta. Eles est\u00e3o nomeados como in-*.txt , mais-caro-out-*.txt e mais-leve-out-*.txt . Mais caro primeiro \u00b6 A ideia desta heur\u00edstica \u00e9 n\u00e3o deixar nenhum objeto valioso para tr\u00e1s! Por isso vamos ser ganaciosos e pegar primeiro os objetos mais caros ! Se um objeto valioso n\u00e3o couber passamos para os mais baratos e prosseguimos at\u00e9 examinar todos objetos. Question Escreva abaixo um algoritmo em pseudo-c\u00f3digo para implementar a heur\u00edstica descrita acima. Resposta ids = // vetor inicializado com ids[i] = i ordene os vetores ids, v e w de acordo com o vetor de valores v peso = 0 valor = 0 resposta = //vetor inicializado com 0 T = 0 // n\u00famero de objetos selecionados para i=1..N se peso + w[i] < W ent\u00e3o resposta[T] = ids[i] peso += w[i] valor += v[i] T += 1 print peso, valor, 0 print resposta[0 .. T] Question Qual \u00e9 a complexidade computacional deste algoritmo? Ele \u00e9 a melhor implementa\u00e7\u00e3o poss\u00edvel? Resposta Se o algoritmo descrito em sua resposta anterior envolver ordena\u00e7\u00e3o, ent\u00e3o ele tem complexidade \\mathcal{O}(n\\log n) \\mathcal{O}(n\\log n) e \u00e9 o melhor poss\u00edvel sim (voc\u00ea consegue explicar por que?). Se voc\u00ea fez um loop duplo que procura pelo maior a cada itera\u00e7\u00e3o ent\u00e3o seu algoritmo \u00e9 \\mathcal{O}(n^2) \\mathcal{O}(n^2) . Example Agora que temos um algoritmo, crie uma implementa\u00e7\u00e3o do programa acima. Dicas : C++ j\u00e1 possui um algoritmo de ordena\u00e7\u00e3o implementado no cabe\u00e7alho <algorithm> . Use-o. Busque por ordena\u00e7\u00e3o indireta para entender como ordenar os tr\u00eas vetores ao mesmo tempo. Pode ser conveniente organizar os dados usando struct . Mais leve primeiro \u00b6 Vamos testar uma abordagem oposta: quantidade agora \u00e9 o foco . Por isso vamos ser pr\u00e1ticos e pegar o maior n\u00famero de objetos poss\u00edvel ! Come\u00e7aremos agora pelos objetos mais leves e vamos torcer para que a quantidade grande de objetos selecionados resulte em uma mochila com alto valor. Question Compare esta heur\u00edstica com a da se\u00e7\u00e3o anterior levando em conta o algoritmo em pseudo-c\u00f3digo e sua complexidade computacional. Question Quais partes do programa da heur\u00edstica anterior podem ser aproveitadas para implementar a descrita acima? Example Implemente agora a heur\u00edstica do mais leve. Chame seu programa de mais_leve , mantendo tamb\u00e9m o c\u00f3digo do anterior. Analisando nossas heur\u00edsticas \u00b6 Question Crie uma entrada em que a heur\u00edstica do mais valioso seja muito melhor que a do mais leve. Escreva abaixo as sa\u00eddas de cada programa. Question Crie uma entrada em que a heur\u00edstica do mais leve seja muito melhor que a do mais valioso. Escreva abaixo as sa\u00eddas de cada programa. Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais valioso \u00e9 melhor? Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais leve \u00e9 melhor?","title":"05 - Heur\u00edsticas"},{"location":"aulas/05-heuristicas/#05-heuristicas","text":"A atividade pr\u00e1tica de hoje consiste em implementar heur\u00edsticas para a solu\u00e7\u00e3o do problema da Mochila bin\u00e1ria .","title":"05 - Heur\u00edsticas"},{"location":"aulas/05-heuristicas/#resumo-do-problema","text":"Dados N objetos e uma mochila que comporta at\u00e9 W quilos, cada um com peso w_i w_i e valor v_i v_i , selecionar objetos com o maior valor poss\u00edvel que caibam dentro da mochila. Entrada : N W w1 v1 .... wN vN Sa\u00edda : W V opt o1 ... oT W - peso dos objetos selecionados V - valor dos objetos selecionados opt 0 se for usada uma heur\u00edstica ou busca local 1 se a solu\u00e7\u00e3o for \u00f3timo global oi s\u00e3o os \u00edndices ( em ordem crescente ) dos objetos selecionados Tip Arquivos para verificar a corretude das suas implementa\u00e7\u00f5es est\u00e3o dispon\u00edveis nesta pasta. Eles est\u00e3o nomeados como in-*.txt , mais-caro-out-*.txt e mais-leve-out-*.txt .","title":"Resumo do problema"},{"location":"aulas/05-heuristicas/#mais-caro-primeiro","text":"A ideia desta heur\u00edstica \u00e9 n\u00e3o deixar nenhum objeto valioso para tr\u00e1s! Por isso vamos ser ganaciosos e pegar primeiro os objetos mais caros ! Se um objeto valioso n\u00e3o couber passamos para os mais baratos e prosseguimos at\u00e9 examinar todos objetos. Question Escreva abaixo um algoritmo em pseudo-c\u00f3digo para implementar a heur\u00edstica descrita acima. Resposta ids = // vetor inicializado com ids[i] = i ordene os vetores ids, v e w de acordo com o vetor de valores v peso = 0 valor = 0 resposta = //vetor inicializado com 0 T = 0 // n\u00famero de objetos selecionados para i=1..N se peso + w[i] < W ent\u00e3o resposta[T] = ids[i] peso += w[i] valor += v[i] T += 1 print peso, valor, 0 print resposta[0 .. T] Question Qual \u00e9 a complexidade computacional deste algoritmo? Ele \u00e9 a melhor implementa\u00e7\u00e3o poss\u00edvel? Resposta Se o algoritmo descrito em sua resposta anterior envolver ordena\u00e7\u00e3o, ent\u00e3o ele tem complexidade \\mathcal{O}(n\\log n) \\mathcal{O}(n\\log n) e \u00e9 o melhor poss\u00edvel sim (voc\u00ea consegue explicar por que?). Se voc\u00ea fez um loop duplo que procura pelo maior a cada itera\u00e7\u00e3o ent\u00e3o seu algoritmo \u00e9 \\mathcal{O}(n^2) \\mathcal{O}(n^2) . Example Agora que temos um algoritmo, crie uma implementa\u00e7\u00e3o do programa acima. Dicas : C++ j\u00e1 possui um algoritmo de ordena\u00e7\u00e3o implementado no cabe\u00e7alho <algorithm> . Use-o. Busque por ordena\u00e7\u00e3o indireta para entender como ordenar os tr\u00eas vetores ao mesmo tempo. Pode ser conveniente organizar os dados usando struct .","title":"Mais caro primeiro"},{"location":"aulas/05-heuristicas/#mais-leve-primeiro","text":"Vamos testar uma abordagem oposta: quantidade agora \u00e9 o foco . Por isso vamos ser pr\u00e1ticos e pegar o maior n\u00famero de objetos poss\u00edvel ! Come\u00e7aremos agora pelos objetos mais leves e vamos torcer para que a quantidade grande de objetos selecionados resulte em uma mochila com alto valor. Question Compare esta heur\u00edstica com a da se\u00e7\u00e3o anterior levando em conta o algoritmo em pseudo-c\u00f3digo e sua complexidade computacional. Question Quais partes do programa da heur\u00edstica anterior podem ser aproveitadas para implementar a descrita acima? Example Implemente agora a heur\u00edstica do mais leve. Chame seu programa de mais_leve , mantendo tamb\u00e9m o c\u00f3digo do anterior.","title":"Mais leve primeiro"},{"location":"aulas/05-heuristicas/#analisando-nossas-heuristicas","text":"Question Crie uma entrada em que a heur\u00edstica do mais valioso seja muito melhor que a do mais leve. Escreva abaixo as sa\u00eddas de cada programa. Question Crie uma entrada em que a heur\u00edstica do mais leve seja muito melhor que a do mais valioso. Escreva abaixo as sa\u00eddas de cada programa. Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais valioso \u00e9 melhor? Question Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais leve \u00e9 melhor?","title":"Analisando nossas heur\u00edsticas"},{"location":"aulas/06-aleatorizacao/","text":"06 - Algoritmos Aleatorizados \u00b6 Um gerador de n\u00fameros pseudo-aleat\u00f3rios (RNG) \u00e9 um algoritmo determin\u00edstico que gera uma sequ\u00eancia de n\u00fameros que parece aleat\u00f3ria. Essa frase possui dois termos importantes que precisamos destrinchar: determin\u00edstico : Um RNG tipicamente recebe como entrada um inteiro seed (que representa uma sequ\u00eancia de bits \"aleat\u00f3ria\") e gera uma sequ\u00eancia de n\u00fameros baseada no seed . Ou seja, o algoritmo \u00e9 determin\u00edstico pois gera sempre a mesma sequ\u00eancia para uma determinada entrada ( seed ). parece aleat\u00f3ria : Se compararmos duas sequ\u00eancias de n\u00fameros, uma gerada por um RNG e outra por uma distribui\u00e7\u00e3o uniforme de verdade, n\u00e3o conseguimos dizer qual sequ\u00eancia foi gerada pelo RNG . Ou seja, ao escolhermos um seed a sequ\u00eancia gerada ser\u00e1 sempre a mesma, mesmo se executarmos o programa em outras m\u00e1quinas. Isso torna a utiliza\u00e7\u00e3o de RNGs para experimentos bastante interessante: \u00e9 poss\u00edvel reproduzir os resultados feitos por outros desenvolvedores/cientistas. Para isto \u00e9 necess\u00e1rio que o programa permita escolher o seed da simula\u00e7\u00e3o; que o seed usado seja publicado junto com os resultados. Question E se quisermos gerar uma sequ\u00eancia diferente a cada execu\u00e7\u00e3o do programa? Como poder\u00edamos configurar o seed para que isto aconte\u00e7a? Iniciando com RNGs \u00b6 Muitas implementa\u00e7\u00f5es de RNGs s\u00e3o divididas em duas partes: engine / random state : algoritmo que gera um inteiro cujos bits formam uma sequ\u00eancia pseudo-aleat\u00f3ria. distribution : utiliza os bits acima para retornar n\u00fameros que sigam alguma distribui\u00e7\u00e3o estat\u00edstica (como normal ou uniforme). Question A biblioteca padr\u00e3o de C++ disponibiliza diversas fun\u00e7\u00f5es para utiliza\u00e7\u00e3o de *RNG*s (cabe\u00e7alho <random> - documenta\u00e7\u00e3o neste link ). Se voc\u00ea quisesse sortear n\u00fameros aleat\u00f3rios inteiros entre -2 e 5 quais fun\u00e7\u00f5es usaria? Resposta #include <random> ... std::default_random_engine generator; std::uniform_int_distribution<int> distribution(-2,5); distribution(generator); // gera n\u00famero Question E se voc\u00ea quisesse sortear um n\u00famero real entre 0 e 1 ? Resposta #include <random> ... std::default_random_engine generator; std::uniform_real_distribution<double> distribution(0.0, 1.0); distribution(generator); // gera n\u00famero Agora que voc\u00ea j\u00e1 consegue gerar n\u00fameros aleat\u00f3rios, vamos implementar nossa primeira vers\u00e3o de uma heur\u00edstica aleatorizada. Example Adicionaremos a seguinte varia\u00e7\u00e3o na nossa heur\u00edstica: a cada passo de sele\u00e7\u00e3o temos 25% de chance de selecionar um objeto aleat\u00f3rio que ainda n\u00e3o foi utilizado. Ou seja, cada passo do algoritmo segue a seguinte regra Fa\u00e7a um sorteio aleat\u00f3rio Com probabilidade 75% pegue o pr\u00f3ximo objeto n\u00e3o selecionado de acordo com a heur\u00edstica (mais leve ou mais caro) Com probabilidade 25% selecione um objeto qualquer dos que n\u00e3o foram analisados ainda. Note que n\u00e3o mudamos o pr\u00f3ximo elemento ao fazer a sele\u00e7\u00e3o aleat\u00f3ria. Adote seed=10 nesta tarefa. Dica : agora \u00e9 poss\u00edvel que eu olhe um produto mais de uma vez. Voc\u00ea precisar\u00e1 checar isso no seu programa! Resposta Os arquivos in-*.txt cont\u00e9m entradas para teste. Os arquivos out-caro-(rand-?)*.txt cont\u00e9m as sa\u00eddas esperadas para as heur\u00edsticas do mais caro. Note que como estamos falando de uma probabilidade, o sorteio dever\u00e1 ser feito no intervalo [0, 1] . Question Rode a heur\u00edstica aleatorizada 10 vezes (como fazer isso?) e anote os valores das mochilas obtidas. Em m\u00e9dia, \u00e9 melhor ou pior que a heuristca sem aleatoriza\u00e7\u00e3o? Construindo uma solu\u00e7\u00e3o inteira aleat\u00f3ria \u00b6 Vamos agora fazer algo mais absurdo: e se criarmos uma solu\u00e7\u00e3o toda aleat\u00f3ria? Question Como voc\u00ea criaria uma solu\u00e7\u00e3o aleatoriamente? Resposta N\u00e3o existe uma resposta certa aqui. Duas solu\u00e7\u00f5es s\u00e3o mais comuns: passando por cada objeto, pegue-o com probabilidade 50% . percorra a lista em ordem aleat\u00f3ria, fazendo o mesmo algoritmo do mais caro/leve. Example Tente implementar a abordagem 1 da resposta acima. Example Tente implementar a abordagem 2 da resposta acima. Question Rode ambos programas acima com v\u00e1rios seeds diferentes e anote abaixo os resultados. Question Anote aqui coment\u00e1rios sobre a qualidade das solu\u00e7\u00f5es aleat\u00f3rias. Considere tanto o valor dos objetos selecionados quanto o peso. Warning Iremos discutir esses resultados na pr\u00f3xima aula.","title":"06 - Algoritmos Aleatorizados"},{"location":"aulas/06-aleatorizacao/#06-algoritmos-aleatorizados","text":"Um gerador de n\u00fameros pseudo-aleat\u00f3rios (RNG) \u00e9 um algoritmo determin\u00edstico que gera uma sequ\u00eancia de n\u00fameros que parece aleat\u00f3ria. Essa frase possui dois termos importantes que precisamos destrinchar: determin\u00edstico : Um RNG tipicamente recebe como entrada um inteiro seed (que representa uma sequ\u00eancia de bits \"aleat\u00f3ria\") e gera uma sequ\u00eancia de n\u00fameros baseada no seed . Ou seja, o algoritmo \u00e9 determin\u00edstico pois gera sempre a mesma sequ\u00eancia para uma determinada entrada ( seed ). parece aleat\u00f3ria : Se compararmos duas sequ\u00eancias de n\u00fameros, uma gerada por um RNG e outra por uma distribui\u00e7\u00e3o uniforme de verdade, n\u00e3o conseguimos dizer qual sequ\u00eancia foi gerada pelo RNG . Ou seja, ao escolhermos um seed a sequ\u00eancia gerada ser\u00e1 sempre a mesma, mesmo se executarmos o programa em outras m\u00e1quinas. Isso torna a utiliza\u00e7\u00e3o de RNGs para experimentos bastante interessante: \u00e9 poss\u00edvel reproduzir os resultados feitos por outros desenvolvedores/cientistas. Para isto \u00e9 necess\u00e1rio que o programa permita escolher o seed da simula\u00e7\u00e3o; que o seed usado seja publicado junto com os resultados. Question E se quisermos gerar uma sequ\u00eancia diferente a cada execu\u00e7\u00e3o do programa? Como poder\u00edamos configurar o seed para que isto aconte\u00e7a?","title":"06 - Algoritmos Aleatorizados"},{"location":"aulas/06-aleatorizacao/#iniciando-com-rngs","text":"Muitas implementa\u00e7\u00f5es de RNGs s\u00e3o divididas em duas partes: engine / random state : algoritmo que gera um inteiro cujos bits formam uma sequ\u00eancia pseudo-aleat\u00f3ria. distribution : utiliza os bits acima para retornar n\u00fameros que sigam alguma distribui\u00e7\u00e3o estat\u00edstica (como normal ou uniforme). Question A biblioteca padr\u00e3o de C++ disponibiliza diversas fun\u00e7\u00f5es para utiliza\u00e7\u00e3o de *RNG*s (cabe\u00e7alho <random> - documenta\u00e7\u00e3o neste link ). Se voc\u00ea quisesse sortear n\u00fameros aleat\u00f3rios inteiros entre -2 e 5 quais fun\u00e7\u00f5es usaria? Resposta #include <random> ... std::default_random_engine generator; std::uniform_int_distribution<int> distribution(-2,5); distribution(generator); // gera n\u00famero Question E se voc\u00ea quisesse sortear um n\u00famero real entre 0 e 1 ? Resposta #include <random> ... std::default_random_engine generator; std::uniform_real_distribution<double> distribution(0.0, 1.0); distribution(generator); // gera n\u00famero Agora que voc\u00ea j\u00e1 consegue gerar n\u00fameros aleat\u00f3rios, vamos implementar nossa primeira vers\u00e3o de uma heur\u00edstica aleatorizada. Example Adicionaremos a seguinte varia\u00e7\u00e3o na nossa heur\u00edstica: a cada passo de sele\u00e7\u00e3o temos 25% de chance de selecionar um objeto aleat\u00f3rio que ainda n\u00e3o foi utilizado. Ou seja, cada passo do algoritmo segue a seguinte regra Fa\u00e7a um sorteio aleat\u00f3rio Com probabilidade 75% pegue o pr\u00f3ximo objeto n\u00e3o selecionado de acordo com a heur\u00edstica (mais leve ou mais caro) Com probabilidade 25% selecione um objeto qualquer dos que n\u00e3o foram analisados ainda. Note que n\u00e3o mudamos o pr\u00f3ximo elemento ao fazer a sele\u00e7\u00e3o aleat\u00f3ria. Adote seed=10 nesta tarefa. Dica : agora \u00e9 poss\u00edvel que eu olhe um produto mais de uma vez. Voc\u00ea precisar\u00e1 checar isso no seu programa! Resposta Os arquivos in-*.txt cont\u00e9m entradas para teste. Os arquivos out-caro-(rand-?)*.txt cont\u00e9m as sa\u00eddas esperadas para as heur\u00edsticas do mais caro. Note que como estamos falando de uma probabilidade, o sorteio dever\u00e1 ser feito no intervalo [0, 1] . Question Rode a heur\u00edstica aleatorizada 10 vezes (como fazer isso?) e anote os valores das mochilas obtidas. Em m\u00e9dia, \u00e9 melhor ou pior que a heuristca sem aleatoriza\u00e7\u00e3o?","title":"Iniciando com RNGs"},{"location":"aulas/06-aleatorizacao/#construindo-uma-solucao-inteira-aleatoria","text":"Vamos agora fazer algo mais absurdo: e se criarmos uma solu\u00e7\u00e3o toda aleat\u00f3ria? Question Como voc\u00ea criaria uma solu\u00e7\u00e3o aleatoriamente? Resposta N\u00e3o existe uma resposta certa aqui. Duas solu\u00e7\u00f5es s\u00e3o mais comuns: passando por cada objeto, pegue-o com probabilidade 50% . percorra a lista em ordem aleat\u00f3ria, fazendo o mesmo algoritmo do mais caro/leve. Example Tente implementar a abordagem 1 da resposta acima. Example Tente implementar a abordagem 2 da resposta acima. Question Rode ambos programas acima com v\u00e1rios seeds diferentes e anote abaixo os resultados. Question Anote aqui coment\u00e1rios sobre a qualidade das solu\u00e7\u00f5es aleat\u00f3rias. Considere tanto o valor dos objetos selecionados quanto o peso. Warning Iremos discutir esses resultados na pr\u00f3xima aula.","title":"Construindo uma solu\u00e7\u00e3o inteira aleat\u00f3ria"},{"location":"aulas/07-busca-local/","text":"07 - Busca local \u00b6 Nesta aula trabalharemos com um algoritmo chamado \"Busca local\", que consiste basicamente em fazer pequenas atualiza\u00e7\u00f5es que melhoram sucessivamente uma solu\u00e7\u00e3o. Solu\u00e7\u00e3o aleatorizada \u00b6 Vamos iniciar criando solu\u00e7\u00f5es aleat\u00f3rias. Isto nos permitiria criar uma grande quantidade de solu\u00e7\u00f5es e, eventualmente, pegar a melhor delas. Apesar de ser muito mais simples que a busca heur\u00edstica, a quantidade massiva de solu\u00e7\u00f5es geradas tem potencial de encontrar boas solu\u00e7\u00f5es. Vamos trabalhar com um algoritmo bem simples para gerar solu\u00e7\u00f5es aleat\u00f3rias: Para cada objeto, selecione-o com probabilidade 0.5 . Se o objeto for selecionado, coloque-o na mochile se couber. Question Supondo que s\u00f3 existe uma solu\u00e7\u00e3o \u00f3tima global, qual \u00e9 a chance de a encontrarmos repetindo o algoritmo acima? Question Supondo que todos os objetos caibam na mochila, quantos s\u00e3o selecionados em m\u00e9dia? Example Implemente o algoritmo acima. Use seed=10 . Example Repita o algoritmo 10 vezes e pegue somente a melhor solu\u00e7\u00e3o. Tip Use os arquivos de entrada/sa\u00edda disponibilizados nas aulas passadas. Busca local \u00b6 Vamos agora implementar uma busca local para a Mochila Bin\u00e1ria seguindo os dois algoritmos vistos na expositiva. Mochila cheia \u00b6 Para implementar a Mochila cheia iremos adotar a seguinte estrat\u00e9gia: Gere uma solu\u00e7\u00e3o aleat\u00f3ria. Percorre novamente todos os objetos (na ordem da entrada) Se um objeto couber na mochila, inclua-o. Example Implemente o algoritmo acima. Example Rode a Mochila cheia 10 vezes e retorne a melhor solu\u00e7\u00e3o. Question Houve melhoria em rela\u00e7\u00e3o ao aleat\u00f3rio sozinho? Foi significativa? Fechamento \u00b6 Question Como voc\u00ea avalia os ganhos obtidos pela busca local em rela\u00e7\u00e3o ao aleat\u00f3rio? E em rela\u00e7\u00e3o a heur\u00edstica?","title":"07 - Busca local"},{"location":"aulas/07-busca-local/#07-busca-local","text":"Nesta aula trabalharemos com um algoritmo chamado \"Busca local\", que consiste basicamente em fazer pequenas atualiza\u00e7\u00f5es que melhoram sucessivamente uma solu\u00e7\u00e3o.","title":"07 - Busca local"},{"location":"aulas/07-busca-local/#solucao-aleatorizada","text":"Vamos iniciar criando solu\u00e7\u00f5es aleat\u00f3rias. Isto nos permitiria criar uma grande quantidade de solu\u00e7\u00f5es e, eventualmente, pegar a melhor delas. Apesar de ser muito mais simples que a busca heur\u00edstica, a quantidade massiva de solu\u00e7\u00f5es geradas tem potencial de encontrar boas solu\u00e7\u00f5es. Vamos trabalhar com um algoritmo bem simples para gerar solu\u00e7\u00f5es aleat\u00f3rias: Para cada objeto, selecione-o com probabilidade 0.5 . Se o objeto for selecionado, coloque-o na mochile se couber. Question Supondo que s\u00f3 existe uma solu\u00e7\u00e3o \u00f3tima global, qual \u00e9 a chance de a encontrarmos repetindo o algoritmo acima? Question Supondo que todos os objetos caibam na mochila, quantos s\u00e3o selecionados em m\u00e9dia? Example Implemente o algoritmo acima. Use seed=10 . Example Repita o algoritmo 10 vezes e pegue somente a melhor solu\u00e7\u00e3o. Tip Use os arquivos de entrada/sa\u00edda disponibilizados nas aulas passadas.","title":"Solu\u00e7\u00e3o aleatorizada"},{"location":"aulas/07-busca-local/#busca-local","text":"Vamos agora implementar uma busca local para a Mochila Bin\u00e1ria seguindo os dois algoritmos vistos na expositiva.","title":"Busca local"},{"location":"aulas/07-busca-local/#mochila-cheia","text":"Para implementar a Mochila cheia iremos adotar a seguinte estrat\u00e9gia: Gere uma solu\u00e7\u00e3o aleat\u00f3ria. Percorre novamente todos os objetos (na ordem da entrada) Se um objeto couber na mochila, inclua-o. Example Implemente o algoritmo acima. Example Rode a Mochila cheia 10 vezes e retorne a melhor solu\u00e7\u00e3o. Question Houve melhoria em rela\u00e7\u00e3o ao aleat\u00f3rio sozinho? Foi significativa?","title":"Mochila cheia"},{"location":"aulas/07-busca-local/#fechamento","text":"Question Como voc\u00ea avalia os ganhos obtidos pela busca local em rela\u00e7\u00e3o ao aleat\u00f3rio? E em rela\u00e7\u00e3o a heur\u00edstica?","title":"Fechamento"},{"location":"aulas/08-busca-global/","text":"08 - Busca exaustiva \u00b6 Pseudo-c\u00f3digo \u00b6 Vamos iniciar tentando escrever um algoritmo em pseudo-c\u00f3digo para a seguinte ideia: Iniciando com o objeto 0: N\u00e3o inclua ele na mochila: resolva o problema com o restante dos objetos e retorne esse resultado Inclua ele na mochila: resolva o problema com o restante dos objetos e uma mochila de capacidade C - p[0] . Retorne o resultado + v[0] . Escolhe a melhor das duas op\u00e7\u00f5es acima e retorne. Tip Note que pedimos para resolver o problema de novo, mas com menos objetos. Parece que esse \u00e9 um algoritmo recursivo! Question Escreva um algoritmo recursivo em pseudo-c\u00f3digo para resolver o problema da mochila. Seu algoritmo dever\u00e1 retornar o valor da mochila \u00f3tima, mas N\u00c3O precisa ainda retornar a mochila que tem esse valor. Question Adapte seu algoritmo acima para, al\u00e9m de retornar a melhor solu\u00e7\u00e3o, tamb\u00e9m retornar a mochila que tem esse valor. Dica : pode ser \u00fatil passar um vetor para guardar a melhor solu\u00e7\u00e3o encontrada. Implementa\u00e7\u00e3o \u00b6 Vamos agora tentar implementar o algoritmo de busca global que fizemos. Example Implemente em C++ seu algoritmo acima. Question Teste o seu programa com a entrada in-aula.txt (que \u00e9 a entrada dos slides). Voc\u00ea consegue agora responder \u00e0 pergunta Existe mochila com valor maior que 13 ? Fechamento \u00b6 Question Como voc\u00ea avalia os ganhos obtidos pela busca global em rela\u00e7\u00e3o \u00e0 busca local?","title":"08 - Busca exaustiva"},{"location":"aulas/08-busca-global/#08-busca-exaustiva","text":"","title":"08 - Busca exaustiva"},{"location":"aulas/08-busca-global/#pseudo-codigo","text":"Vamos iniciar tentando escrever um algoritmo em pseudo-c\u00f3digo para a seguinte ideia: Iniciando com o objeto 0: N\u00e3o inclua ele na mochila: resolva o problema com o restante dos objetos e retorne esse resultado Inclua ele na mochila: resolva o problema com o restante dos objetos e uma mochila de capacidade C - p[0] . Retorne o resultado + v[0] . Escolhe a melhor das duas op\u00e7\u00f5es acima e retorne. Tip Note que pedimos para resolver o problema de novo, mas com menos objetos. Parece que esse \u00e9 um algoritmo recursivo! Question Escreva um algoritmo recursivo em pseudo-c\u00f3digo para resolver o problema da mochila. Seu algoritmo dever\u00e1 retornar o valor da mochila \u00f3tima, mas N\u00c3O precisa ainda retornar a mochila que tem esse valor. Question Adapte seu algoritmo acima para, al\u00e9m de retornar a melhor solu\u00e7\u00e3o, tamb\u00e9m retornar a mochila que tem esse valor. Dica : pode ser \u00fatil passar um vetor para guardar a melhor solu\u00e7\u00e3o encontrada.","title":"Pseudo-c\u00f3digo"},{"location":"aulas/08-busca-global/#implementacao","text":"Vamos agora tentar implementar o algoritmo de busca global que fizemos. Example Implemente em C++ seu algoritmo acima. Question Teste o seu programa com a entrada in-aula.txt (que \u00e9 a entrada dos slides). Voc\u00ea consegue agora responder \u00e0 pergunta Existe mochila com valor maior que 13 ?","title":"Implementa\u00e7\u00e3o"},{"location":"aulas/08-busca-global/#fechamento","text":"Question Como voc\u00ea avalia os ganhos obtidos pela busca global em rela\u00e7\u00e3o \u00e0 busca local?","title":"Fechamento"},{"location":"guias-tecnicos/container-remoto/","text":"Tutorial Acesso \u00e0 maquina Monstr\u00e3o via VsCode \u00b6 Voc\u00ea deve ter acesso a sua maquina virtual no monstr\u00e3o e o VsCode instalado. Este Tutorial ir\u00e1 seguir as seguintes etapas. Etapas : Instalar extens\u00e3o no VsCode; Fazer acesso ssh; Instalar o Jupyter notebook; Rodar o notebook na pasta alvo. Instalar extens\u00e3o SSH Remote no VScode \u00b6 Dentro do aplicativo do VsCode Ctrl+Shift+X Buscar e instalar os pacotes do Remote-SSH Acesso SSH \u00b6 Clicar no icone a esquerda Remote Explorer Adicionar um novo SSH TARGET Na linha de comando digitar ssh user@<seu IP do monstr\u00e3o> Clicar Enter para ignorar o acesso via par de chaves O VsCode ir\u00e1 conectar na sua M\u00e1quina virtual e pedir a senha Digite a senha de acesso do seu usu\u00e1rio Como instalar e iniciar o Jupyter Notebook com Python no Ubuntu 20.04 \u00b6 Instala\u00e7\u00f5es iniciais : sudo apt update sudo apt upgrade -y sudo apt install build-essential sudo snap install jupyter clonar via git, o reposit\u00f3rio da disciplina Acessar a pasta com o projeto e rodar o comando: jupyter notebook Neste momento o Jupyter ir\u00e1 iniciar o servidor na m\u00e1quina virtual e o VsCode ir\u00e1 mostrar uma mensagem perguntando se deseja abrir via Browser. Aceitar Copiar o token gerado no terminal e colar na aba aberta no Browser. PRONTO. \u00b6 Outra dica \u00b6 Se quiser fazer via Tunel SSH, pode rodar o comando abaixo no seu terminal e acessar o Browser na porta 8888 ssh -L 8888:localhost:8888 user@< digite aqui ip da sua maquina virtual no monstr\u00e3o > * Acesse o localhost:8888 no seu Browser.","title":"Tutorial Acesso \u00e0 maquina Monstr\u00e3o via VsCode"},{"location":"guias-tecnicos/container-remoto/#tutorial-acesso-a-maquina-monstrao-via-vscode","text":"Voc\u00ea deve ter acesso a sua maquina virtual no monstr\u00e3o e o VsCode instalado. Este Tutorial ir\u00e1 seguir as seguintes etapas. Etapas : Instalar extens\u00e3o no VsCode; Fazer acesso ssh; Instalar o Jupyter notebook; Rodar o notebook na pasta alvo.","title":"Tutorial Acesso \u00e0 maquina Monstr\u00e3o via VsCode"},{"location":"guias-tecnicos/container-remoto/#instalar-extensao-ssh-remote-no-vscode","text":"Dentro do aplicativo do VsCode Ctrl+Shift+X Buscar e instalar os pacotes do Remote-SSH","title":"Instalar extens\u00e3o SSH Remote no VScode"},{"location":"guias-tecnicos/container-remoto/#acesso-ssh","text":"Clicar no icone a esquerda Remote Explorer Adicionar um novo SSH TARGET Na linha de comando digitar ssh user@<seu IP do monstr\u00e3o> Clicar Enter para ignorar o acesso via par de chaves O VsCode ir\u00e1 conectar na sua M\u00e1quina virtual e pedir a senha Digite a senha de acesso do seu usu\u00e1rio","title":"Acesso SSH"},{"location":"guias-tecnicos/container-remoto/#como-instalar-e-iniciar-o-jupyter-notebook-com-python-no-ubuntu-2004","text":"Instala\u00e7\u00f5es iniciais : sudo apt update sudo apt upgrade -y sudo apt install build-essential sudo snap install jupyter clonar via git, o reposit\u00f3rio da disciplina Acessar a pasta com o projeto e rodar o comando: jupyter notebook Neste momento o Jupyter ir\u00e1 iniciar o servidor na m\u00e1quina virtual e o VsCode ir\u00e1 mostrar uma mensagem perguntando se deseja abrir via Browser. Aceitar Copiar o token gerado no terminal e colar na aba aberta no Browser.","title":"Como instalar e iniciar o Jupyter Notebook com Python no Ubuntu 20.04"},{"location":"guias-tecnicos/container-remoto/#pronto","text":"","title":"PRONTO."},{"location":"guias-tecnicos/container-remoto/#outra-dica","text":"Se quiser fazer via Tunel SSH, pode rodar o comando abaixo no seu terminal e acessar o Browser na porta 8888 ssh -L 8888:localhost:8888 user@< digite aqui ip da sua maquina virtual no monstr\u00e3o > * Acesse o localhost:8888 no seu Browser.","title":"Outra dica"},{"location":"projetos/","text":"Maximin Share \u00b6 Dados M objetos com valor V[i], i=1..M e N pessoas, desejamos dividir estes objetos de maneira mais igualit\u00e1ria poss\u00edvel. Como n\u00e3o \u00e9 poss\u00edvel \"quebrar\" objetos, naturalmente alguns ficar\u00e3o com objetos de maior valor que os outros. Nosso objetivo neste projeto \u00e9 definir qual seria o menor valor que uma pessoa deveria aceitar nesta divis\u00e3o . Para fazer isso vamos usar o seguinte procedimento: uma pessoa do grupo ser\u00e1 respons\u00e1vel por fazer a divis\u00e3o dos objetos em N grupos. Por\u00e9m, ela dever\u00e1 permitir que todas as outras N-1 pessoas escolham primeiro qual grupo elas desejam . Ou seja, a pessoa que fez a divis\u00e3o naturalmente ficar\u00e1 com o grupo de menor valor. Portanto nosso objetivo ser\u00e1 maximizar o valor do grupo de menor valor. Chamaremos este valor de MMS e o a atribui\u00e7\u00e3o que o gera de divis\u00e3o 1 de n . Vejamos um exemplo: separaremos 6 objetos para 3 pessoas. Os valores dos objetos s\u00e3o {20, 11, 9, 13, 14, 37} . Uma poss\u00edvel divis\u00e3o seria {37} {20, 11} {14, 13, 9} Com esta divis\u00e3o, o menor valor seria o do segundo grupo (31). Note que v\u00e1rias divis\u00f5es s\u00e3o poss\u00edveis: {37} {20, 14} {13, 11, 9} Nesta outra divis\u00e3o o menor valor \u00e9 o do terceiro grupo (33). Portanto, entre essas duas divis\u00f5es a segunda \u00e9 melhor, j\u00e1 que a pessoa que dividiu ganharia um valor maior. Usaremos este problema na disciplina por uma raz\u00e3o bem simples: encontrar o MMS \u00e9 uma tarefa NP-dif\u00edcil . Ou seja, o melhor que podemos fazer neste caso para garantir a melhor solu\u00e7\u00e3o \u00e9, no pior caso, testar todas as aloca\u00e7\u00f5es poss\u00edveis. Claramente isso \u00e9 lento, ent\u00e3o \u00e9 uma bom exemplo de aplica\u00e7\u00e3o de SuperComputa\u00e7\u00e3o! Entrada e sa\u00edda \u00b6 As entradas e sa\u00eddas das implementa\u00e7\u00f5es ser\u00e3o padronizadas como abaixo. Entrada : N M p1 ... pN Sa\u00edda : MMS O objetos da pessoa 1 ... objetos da pessoa M Nos esquemas acima, N = n\u00famero de objetos M = n\u00famero de pessoas pi = peso do objeto i MMS = valor do grupo menos valioso objetos da pessoa i = lista dos \u00edndices dos objetos que est\u00e3o com a pessoa i. Veja os exemplos de entrada e sa\u00edda na pasta entradas do reposit\u00f3rio do projeto.","title":"Maximin Share"},{"location":"projetos/#maximin-share","text":"Dados M objetos com valor V[i], i=1..M e N pessoas, desejamos dividir estes objetos de maneira mais igualit\u00e1ria poss\u00edvel. Como n\u00e3o \u00e9 poss\u00edvel \"quebrar\" objetos, naturalmente alguns ficar\u00e3o com objetos de maior valor que os outros. Nosso objetivo neste projeto \u00e9 definir qual seria o menor valor que uma pessoa deveria aceitar nesta divis\u00e3o . Para fazer isso vamos usar o seguinte procedimento: uma pessoa do grupo ser\u00e1 respons\u00e1vel por fazer a divis\u00e3o dos objetos em N grupos. Por\u00e9m, ela dever\u00e1 permitir que todas as outras N-1 pessoas escolham primeiro qual grupo elas desejam . Ou seja, a pessoa que fez a divis\u00e3o naturalmente ficar\u00e1 com o grupo de menor valor. Portanto nosso objetivo ser\u00e1 maximizar o valor do grupo de menor valor. Chamaremos este valor de MMS e o a atribui\u00e7\u00e3o que o gera de divis\u00e3o 1 de n . Vejamos um exemplo: separaremos 6 objetos para 3 pessoas. Os valores dos objetos s\u00e3o {20, 11, 9, 13, 14, 37} . Uma poss\u00edvel divis\u00e3o seria {37} {20, 11} {14, 13, 9} Com esta divis\u00e3o, o menor valor seria o do segundo grupo (31). Note que v\u00e1rias divis\u00f5es s\u00e3o poss\u00edveis: {37} {20, 14} {13, 11, 9} Nesta outra divis\u00e3o o menor valor \u00e9 o do terceiro grupo (33). Portanto, entre essas duas divis\u00f5es a segunda \u00e9 melhor, j\u00e1 que a pessoa que dividiu ganharia um valor maior. Usaremos este problema na disciplina por uma raz\u00e3o bem simples: encontrar o MMS \u00e9 uma tarefa NP-dif\u00edcil . Ou seja, o melhor que podemos fazer neste caso para garantir a melhor solu\u00e7\u00e3o \u00e9, no pior caso, testar todas as aloca\u00e7\u00f5es poss\u00edveis. Claramente isso \u00e9 lento, ent\u00e3o \u00e9 uma bom exemplo de aplica\u00e7\u00e3o de SuperComputa\u00e7\u00e3o!","title":"Maximin Share"},{"location":"projetos/#entrada-e-saida","text":"As entradas e sa\u00eddas das implementa\u00e7\u00f5es ser\u00e3o padronizadas como abaixo. Entrada : N M p1 ... pN Sa\u00edda : MMS O objetos da pessoa 1 ... objetos da pessoa M Nos esquemas acima, N = n\u00famero de objetos M = n\u00famero de pessoas pi = peso do objeto i MMS = valor do grupo menos valioso objetos da pessoa i = lista dos \u00edndices dos objetos que est\u00e3o com a pessoa i. Veja os exemplos de entrada e sa\u00edda na pasta entradas do reposit\u00f3rio do projeto.","title":"Entrada e sa\u00edda"}]}