{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SuperComputa\u00e7\u00e3o \u00b6 Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2020/1. Professor : Igor Montagner Monitores : Leonardo Pereira Medeiros Raphael Marques da Costa Objetivos \u00b6 Ao final da disciplina o aluno ser\u00e1 capaz de: Desenvolver algoritmos usando recursos de computa\u00e7\u00e3o paralela/distribu\u00edda para ganhos de desempenho da aplica\u00e7\u00e3o final; Aplicar estrutura l\u00f3gica de computa\u00e7\u00e3o distribu\u00edda para o desenvolvimento de algoritmos multitarefas; Usar GPGPU para computa\u00e7\u00e3o num\u00e9rica e comparar com solu\u00e7\u00f5es baseadas em CPU Planejar e projetar sistemas de computa\u00e7\u00e3o de alto desempenho; Analisar a complexidade dos algoritmos paralelos e a efici\u00eancia de uma implementa\u00e7\u00e3o particular, identificando as medidas de desempenho mais adequadas para esta tarefa; Aplicar recursos espec\u00edfico de sistemas operacionais para melhorar o desempenho de algoritmos; Desenvolver aplica\u00e7\u00f5es que utilizam protocolos otimizados para paraleliza\u00e7\u00e3o. Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os projetos ter\u00e3o dura\u00e7\u00e3o de duas semanas e ser\u00e3o incrementais com os seguintes pesos para m\u00e9dia de projetos: Projeto 0 - revis\u00e3o de C++ (10%) Projeto 1 - multi core (30%) Projeto 2 - GPU (30%) Projeto 3 - MPI (30%) Atividades de acompanhamento ser\u00e3o disponibilizadas durante o semestre. Estas atividades ter\u00e3o corre\u00e7\u00e3o autom\u00e1tica e sua realiza\u00e7\u00e3o \u00e9 opcional. Entregas atrasadas n\u00e3o ser\u00e3o aceitas para nota . A m\u00e9dia final \u00e9 dada por \\max \\begin{cases}0,4 \\times MP + 0,5\\times MProj + 0,1\\times AT \\\\ 0,5 \\times MP + 0,5 \\times MProj \\end{cases} \\max \\begin{cases}0,4 \\times MP + 0,5\\times MProj + 0,1\\times AT \\\\ 0,5 \\times MP + 0,5 \\times MProj \\end{cases} Condi\u00e7\u00f5es de barreira Caso as seguintes condi\u00e7\u00f5es n\u00e3o sejam cumpridas, a nota final ser\u00e1 D (4,0): Todos os projetos foram entregues MP \\geq 4,5 MP \\geq 4,5 Se um projeto receber nota \\leq 5 \\leq 5 , ele dever\u00e1 ser reentregue at\u00e9 o fim do semestre com as corre\u00e7\u00f5es solicitadas. Se tudo estiver OK a nota deste projeto ser\u00e1 D Se um projeto for entregue atrasado sua nota final ser\u00e1 D Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Home"},{"location":"#supercomputacao","text":"Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2020/1. Professor : Igor Montagner Monitores : Leonardo Pereira Medeiros Raphael Marques da Costa","title":"SuperComputa\u00e7\u00e3o"},{"location":"#objetivos","text":"Ao final da disciplina o aluno ser\u00e1 capaz de: Desenvolver algoritmos usando recursos de computa\u00e7\u00e3o paralela/distribu\u00edda para ganhos de desempenho da aplica\u00e7\u00e3o final; Aplicar estrutura l\u00f3gica de computa\u00e7\u00e3o distribu\u00edda para o desenvolvimento de algoritmos multitarefas; Usar GPGPU para computa\u00e7\u00e3o num\u00e9rica e comparar com solu\u00e7\u00f5es baseadas em CPU Planejar e projetar sistemas de computa\u00e7\u00e3o de alto desempenho; Analisar a complexidade dos algoritmos paralelos e a efici\u00eancia de uma implementa\u00e7\u00e3o particular, identificando as medidas de desempenho mais adequadas para esta tarefa; Aplicar recursos espec\u00edfico de sistemas operacionais para melhorar o desempenho de algoritmos; Desenvolver aplica\u00e7\u00f5es que utilizam protocolos otimizados para paraleliza\u00e7\u00e3o.","title":"Objetivos"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os projetos ter\u00e3o dura\u00e7\u00e3o de duas semanas e ser\u00e3o incrementais com os seguintes pesos para m\u00e9dia de projetos: Projeto 0 - revis\u00e3o de C++ (10%) Projeto 1 - multi core (30%) Projeto 2 - GPU (30%) Projeto 3 - MPI (30%) Atividades de acompanhamento ser\u00e3o disponibilizadas durante o semestre. Estas atividades ter\u00e3o corre\u00e7\u00e3o autom\u00e1tica e sua realiza\u00e7\u00e3o \u00e9 opcional. Entregas atrasadas n\u00e3o ser\u00e3o aceitas para nota . A m\u00e9dia final \u00e9 dada por \\max \\begin{cases}0,4 \\times MP + 0,5\\times MProj + 0,1\\times AT \\\\ 0,5 \\times MP + 0,5 \\times MProj \\end{cases} \\max \\begin{cases}0,4 \\times MP + 0,5\\times MProj + 0,1\\times AT \\\\ 0,5 \\times MP + 0,5 \\times MProj \\end{cases} Condi\u00e7\u00f5es de barreira Caso as seguintes condi\u00e7\u00f5es n\u00e3o sejam cumpridas, a nota final ser\u00e1 D (4,0): Todos os projetos foram entregues MP \\geq 4,5 MP \\geq 4,5 Se um projeto receber nota \\leq 5 \\leq 5 , ele dever\u00e1 ser reentregue at\u00e9 o fim do semestre com as corre\u00e7\u00f5es solicitadas. Se tudo estiver OK a nota deste projeto ser\u00e1 D Se um projeto for entregue atrasado sua nota final ser\u00e1 D Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Avalia\u00e7\u00e3o"},{"location":"sobre/","text":"Burocracias \u00b6 Turma 1 \u00b6 TER 09:45 - 11:45 SEX 07:30 - 09:30 Atendimento: Plano de aulas \u00b6 Data Quest\u00e3o/Problema Conte\u00fado/Atividade 11/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Refer\u00eancia: Pacheco Cap 2. 14/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Orienta\u00e7\u00e3o a Objeto em C++; revis\u00e3o de ponteiros e passagem de argumentos por refer\u00eancia e valor 18/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Conteiners STL: vector, string, map 21/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Debug, profiling e compila\u00e7\u00e3o 25/02 FERIADO FERIADO 28/02 Processamento de dados vetorial Instru\u00e7\u00f5es SIMD e compila\u00e7\u00e3o; Refer\u00eancia: Cap 2 Hager, Cap 3 Dubois 03/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas CPU bound; Modelo fork-join; Exemplo com threads C++11; Leitura: Cap 5 Hager 06/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 10/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 17/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 20/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Simulado de atividade pr\u00e1tica para prova 24/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 27/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 31/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 03/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 07/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 10/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 14/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 17/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 21/04 FERIADO FERIADO 24/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 28/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Otimizando c\u00f3digo Cuda C \u2013 mem\u00f3ria compartilhada; Refer\u00eancia: Cap 4 Kirk 01/05 FERIADO FERIADO 05/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 08/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 12/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Introdu\u00e7\u00e3o a sistemas distribu\u00eddos; Passagem de mensagens; Refer\u00eancia: Parte IV Taurion; Cap 9 Hager 15/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Modelos de divis\u00e3o carga: dados vs tarefas; Refer\u00eancia: Cap 9 Hager 19/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Custos de comunica\u00e7\u00e3o e processamento; mensagens ass\u00edncronas; Refer\u00eancia: Cap 10 Hager, Leitura: \u201cA survey of high-performance computing scaling challenges\u201d 22/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Comunica\u00e7\u00e3o coletiva; Refer\u00eancia: Cap 13 Reinders, Cap 10 Hager 26/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 29/05 Simulado de atividade pr\u00e1tica para prova Simulado de atividade pr\u00e1tica para prova 02/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 05/06 Prova Final Prova Final 09/06 Prova Final Prova Final Turma 2 \u00b6 QUA 13:30 - 15:30 SEX 13:30 - 15:30 Atendimento: Plano de aulas \u00b6 Data Quest\u00e3o/Problema Conte\u00fado/Atividade 12/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Refer\u00eancia: Pacheco Cap 2. 14/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Orienta\u00e7\u00e3o a Objeto em C++; revis\u00e3o de ponteiros e passagem de argumentos por refer\u00eancia e valor 19/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Conteiners STL: vector, string, map 21/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Debug, profiling e compila\u00e7\u00e3o 26/02 FERIADO FERIADO 28/02 Processamento de dados vetorial Instru\u00e7\u00f5es SIMD e compila\u00e7\u00e3o; Refer\u00eancia: Cap 2 Hager, Cap 3 Dubois 04/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas CPU bound; Modelo fork-join; Exemplo com threads C++11; Leitura: Cap 5 Hager 06/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 11/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 18/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 20/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Simulado de atividade pr\u00e1tica para prova 25/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 27/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 01/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 03/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 08/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 10/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 15/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 17/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 22/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 24/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 29/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Otimizando c\u00f3digo Cuda C \u2013 mem\u00f3ria compartilhada; Refer\u00eancia: Cap 4 Kirk 01/05 FERIADO FERIADO 06/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 08/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Introdu\u00e7\u00e3o a sistemas distribu\u00eddos; Passagem de mensagens; Refer\u00eancia: Parte IV Taurion; Cap 9 Hager 13/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Modelos de divis\u00e3o carga: dados vs tarefas; Refer\u00eancia: Cap 9 Hager 15/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Custos de comunica\u00e7\u00e3o e processamento; mensagens ass\u00edncronas; Refer\u00eancia: Cap 10 Hager, Leitura: \u201cA survey of high-performance computing scaling challenges\u201d 20/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Comunica\u00e7\u00e3o coletiva; Refer\u00eancia: Cap 13 Reinders, Cap 10 Hager 22/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 27/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 29/05 Simulado de atividade pr\u00e1tica para prova Simulado de atividade pr\u00e1tica para prova 03/06 Prova Final Prova Final 05/06 Prova Final Prova Final 10/06 Prova Final Prova Final","title":"Sobre"},{"location":"sobre/#burocracias","text":"","title":"Burocracias"},{"location":"sobre/#turma-1","text":"TER 09:45 - 11:45 SEX 07:30 - 09:30 Atendimento:","title":"Turma 1"},{"location":"sobre/#plano-de-aulas","text":"Data Quest\u00e3o/Problema Conte\u00fado/Atividade 11/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Refer\u00eancia: Pacheco Cap 2. 14/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Orienta\u00e7\u00e3o a Objeto em C++; revis\u00e3o de ponteiros e passagem de argumentos por refer\u00eancia e valor 18/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Conteiners STL: vector, string, map 21/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Debug, profiling e compila\u00e7\u00e3o 25/02 FERIADO FERIADO 28/02 Processamento de dados vetorial Instru\u00e7\u00f5es SIMD e compila\u00e7\u00e3o; Refer\u00eancia: Cap 2 Hager, Cap 3 Dubois 03/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas CPU bound; Modelo fork-join; Exemplo com threads C++11; Leitura: Cap 5 Hager 06/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 10/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 17/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 20/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Simulado de atividade pr\u00e1tica para prova 24/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 27/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 31/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 03/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 07/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 10/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 14/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 17/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 21/04 FERIADO FERIADO 24/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 28/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Otimizando c\u00f3digo Cuda C \u2013 mem\u00f3ria compartilhada; Refer\u00eancia: Cap 4 Kirk 01/05 FERIADO FERIADO 05/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 08/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 12/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Introdu\u00e7\u00e3o a sistemas distribu\u00eddos; Passagem de mensagens; Refer\u00eancia: Parte IV Taurion; Cap 9 Hager 15/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Modelos de divis\u00e3o carga: dados vs tarefas; Refer\u00eancia: Cap 9 Hager 19/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Custos de comunica\u00e7\u00e3o e processamento; mensagens ass\u00edncronas; Refer\u00eancia: Cap 10 Hager, Leitura: \u201cA survey of high-performance computing scaling challenges\u201d 22/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Comunica\u00e7\u00e3o coletiva; Refer\u00eancia: Cap 13 Reinders, Cap 10 Hager 26/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 29/05 Simulado de atividade pr\u00e1tica para prova Simulado de atividade pr\u00e1tica para prova 02/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 05/06 Prova Final Prova Final 09/06 Prova Final Prova Final","title":"Plano de aulas"},{"location":"sobre/#turma-2","text":"QUA 13:30 - 15:30 SEX 13:30 - 15:30 Atendimento:","title":"Turma 2"},{"location":"sobre/#plano-de-aulas_1","text":"Data Quest\u00e3o/Problema Conte\u00fado/Atividade 12/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Refer\u00eancia: Pacheco Cap 2. 14/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Orienta\u00e7\u00e3o a Objeto em C++; revis\u00e3o de ponteiros e passagem de argumentos por refer\u00eancia e valor 19/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Conteiners STL: vector, string, map 21/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Debug, profiling e compila\u00e7\u00e3o 26/02 FERIADO FERIADO 28/02 Processamento de dados vetorial Instru\u00e7\u00f5es SIMD e compila\u00e7\u00e3o; Refer\u00eancia: Cap 2 Hager, Cap 3 Dubois 04/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas CPU bound; Modelo fork-join; Exemplo com threads C++11; Leitura: Cap 5 Hager 06/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 11/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 18/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 20/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Simulado de atividade pr\u00e1tica para prova 25/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 27/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 01/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 03/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 08/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 10/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 15/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 17/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 22/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 24/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 29/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Otimizando c\u00f3digo Cuda C \u2013 mem\u00f3ria compartilhada; Refer\u00eancia: Cap 4 Kirk 01/05 FERIADO FERIADO 06/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 08/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Introdu\u00e7\u00e3o a sistemas distribu\u00eddos; Passagem de mensagens; Refer\u00eancia: Parte IV Taurion; Cap 9 Hager 13/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Modelos de divis\u00e3o carga: dados vs tarefas; Refer\u00eancia: Cap 9 Hager 15/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Custos de comunica\u00e7\u00e3o e processamento; mensagens ass\u00edncronas; Refer\u00eancia: Cap 10 Hager, Leitura: \u201cA survey of high-performance computing scaling challenges\u201d 20/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Comunica\u00e7\u00e3o coletiva; Refer\u00eancia: Cap 13 Reinders, Cap 10 Hager 22/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 27/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 29/05 Simulado de atividade pr\u00e1tica para prova Simulado de atividade pr\u00e1tica para prova 03/06 Prova Final Prova Final 05/06 Prova Final Prova Final 10/06 Prova Final Prova Final","title":"Plano de aulas"},{"location":"aulas/00-organizacao/","text":"Organiza\u00e7\u00e3o do reposit\u00f3rio \u00b6 O material de SuperComputa\u00e7\u00e3o para cada aula do semestre pode ser acessado utilizando o menu no lado esquerdo desta p\u00e1gina. Todos os exemplos de c\u00f3digo est\u00e3o na pasta code na raiz do reposit\u00f3rio e ser\u00e3o tamb\u00e9m lincados em cada aula. Todos os slides est\u00e3o na pasta material/aulas e tamb\u00e9m est\u00e3o lincados na parte pr\u00e1tica de cada aula.","title":"Organiza\u00e7\u00e3o do reposit\u00f3rio"},{"location":"aulas/00-organizacao/#organizacao-do-repositorio","text":"O material de SuperComputa\u00e7\u00e3o para cada aula do semestre pode ser acessado utilizando o menu no lado esquerdo desta p\u00e1gina. Todos os exemplos de c\u00f3digo est\u00e3o na pasta code na raiz do reposit\u00f3rio e ser\u00e3o tamb\u00e9m lincados em cada aula. Todos os slides est\u00e3o na pasta material/aulas e tamb\u00e9m est\u00e3o lincados na parte pr\u00e1tica de cada aula.","title":"Organiza\u00e7\u00e3o do reposit\u00f3rio"},{"location":"aulas/01-intro-cpp/","text":"O principal objetivo deste roteiro \u00e9 retomar a pr\u00e1tica de programa\u00e7\u00e3o em C++ usando exerc\u00edcios simples e que eventualmente sejam \u00fateis para os projetos da disciplina. Os exerc\u00edcios para entrega estar\u00e3o indicados no fim do roteiro. Entrada e sa\u00edda \u00b6 Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream) Para mostrar mensagens no terminal basta \"enviar\" dados para o objeto usando o operador <<. Veja o exemplo abaixo. Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream ) Para mostrar mensagens no terminal basta \"enviar\" dados para o objeto usando o operador << . Veja o exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << a << \";\" << b << \" \\n \" ; Note que n\u00e3o precisamos mais usar a string de formata\u00e7\u00e3o cheia de %d e afins. Basta ir aplicando << aos dados que queremos mostrar. O mesmo vale para a entrada, mas desta vez \"tiramos\" os dados do objeto std::cin . O exemplo abaixo l\u00ea um inteiro e um double do terminal. int a ; double b ; std :: cin >> a >> b ; Example Crie um programa que l\u00ea um n\u00famero inteiro n e mostra em sua sa\u00edda sua divis\u00e3o fracion\u00e1ria por 2. Ou seja, antes de dividir converta n para double . Aloca\u00e7\u00e3o de mem\u00f3ria \u00b6 Em C usamos as fun\u00e7\u00f5es malloc e free para alocar mem\u00f3ria dinamicamente. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m est\u00e3o dispon\u00edveis, mas us\u00e1-las \u00e9 considerado uma m\u00e1 pr\u00e1tica. Ao inv\u00e9s, usamos os operadores new e delete para alocar mem\u00f3ria. point * p ; p = new point (); /* usar p aqui */ delete p ; Tamb\u00e9m podemos criar (e deletar) arrays de tamanho fixo usando new[] e delete[] . int n ; std :: cin >> n ; double * values = new double [ n ]; /* usar values aqui */ delete [] values ; Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Dica : procure por setprecision para configurar as casas decimais do cout . Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas? Contagem de tempo \u00b6 Durante todo o curso iremos trabalhar com medi\u00e7\u00f5es de tempo, especialmente para descobrir quais trechos do nosso c\u00f3digo tem mais impacto no tempo de execu\u00e7\u00e3o. Example Crie um script python que gere uma entrada muito grande ( n=100000 ) para o programa acima. Question Use a ferramenta time para medir o tempo de execu\u00e7\u00e3o do programa. Escreva este valor abaixo. Voc\u00ea consegue dizer quanto tempo o c\u00e1lculo da vari\u00e2ncia leva? Um dos problemas da utiliza\u00e7\u00e3o do comando time \u00e9 que ele n\u00e3o separa o tempo gasto para ler a entrada do programa e o tempo gasto no calculo de cada medida. Felizmente a biblioteca padr\u00e3o de C++ possui diversas classes para medi\u00e7\u00e3o de tempo. O cabe\u00e7alho <chrono> disponibiliza diversas classes e fun\u00e7\u00f5es para medi\u00e7\u00e3o de tempo. Leia sua documenta\u00e7\u00e3o neste link . Question Qual classe voc\u00ea usaria para obter leituras de tempo com a melhor precis\u00e3o poss\u00edvel? Quais m\u00e9todos ou fun\u00e7\u00f5es desta classe seriam \u00fateis? Para que servem as classes time_point e duration ? Example Use as classes acima para medir o tempo de execu\u00e7\u00e3o, separadamente, da m\u00e9dia e da vari\u00e2ncia no exemplo anterior. Escreva abaixo o tempo gasto em milisegundos . Projeto 0 - revis\u00e3o de C++ \u00b6 A parte inicial de nosso curso foca na compreens\u00e3o e implementa\u00e7\u00e3o de fun\u00e7\u00f5es matem\u00e1ticas. Para isso vamos iniciar uma sequ\u00eancia de atividades que far\u00e3o compara\u00e7\u00f5es de desempenho de fun\u00e7\u00f5es do cabe\u00e7alho cmath (que \u00e9 o mesmo math.h que us\u00e1vamos em C , mas agora exportado para usar em C++ ). Example Cria um arquivo chamado parte0.c contendo uma fun\u00e7\u00e3o gera_vetor que recebe um inteiro n e devolve um vetor de dados aleat\u00f3rio de tamanho n com tipo double . fun\u00e7\u00f5es log , sqrt , pow3 (usando a biblioteca math ) e pow3mult (usando o operador * duas vezes) que computam as opera\u00e7\u00f5es correspondentes em cada elemento do vetor. uma fun\u00e7\u00e3o sum que calcula a soma do vetor um main que cria vetores de tamanho incrementalmente maior e computa o tempo necess\u00e1rio para cada fun\u00e7\u00e3o rodar. Question Para cada fun\u00e7\u00e3o criada, coloque abaixo os tempos colhidos para cada tamanho de vetor. O nome da disciplina \u00e9 SuperComputa\u00e7\u00e3o. Honre esse nome ao escolher tamanhos de vetores.","title":"01 - Introdu\u00e7\u00e3o a C++"},{"location":"aulas/01-intro-cpp/#entrada-e-saida","text":"Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream) Para mostrar mensagens no terminal basta \"enviar\" dados para o objeto usando o operador <<. Veja o exemplo abaixo. Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream ) Para mostrar mensagens no terminal basta \"enviar\" dados para o objeto usando o operador << . Veja o exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << a << \";\" << b << \" \\n \" ; Note que n\u00e3o precisamos mais usar a string de formata\u00e7\u00e3o cheia de %d e afins. Basta ir aplicando << aos dados que queremos mostrar. O mesmo vale para a entrada, mas desta vez \"tiramos\" os dados do objeto std::cin . O exemplo abaixo l\u00ea um inteiro e um double do terminal. int a ; double b ; std :: cin >> a >> b ; Example Crie um programa que l\u00ea um n\u00famero inteiro n e mostra em sua sa\u00edda sua divis\u00e3o fracion\u00e1ria por 2. Ou seja, antes de dividir converta n para double .","title":"Entrada e sa\u00edda"},{"location":"aulas/01-intro-cpp/#alocacao-de-memoria","text":"Em C usamos as fun\u00e7\u00f5es malloc e free para alocar mem\u00f3ria dinamicamente. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m est\u00e3o dispon\u00edveis, mas us\u00e1-las \u00e9 considerado uma m\u00e1 pr\u00e1tica. Ao inv\u00e9s, usamos os operadores new e delete para alocar mem\u00f3ria. point * p ; p = new point (); /* usar p aqui */ delete p ; Tamb\u00e9m podemos criar (e deletar) arrays de tamanho fixo usando new[] e delete[] . int n ; std :: cin >> n ; double * values = new double [ n ]; /* usar values aqui */ delete [] values ; Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Dica : procure por setprecision para configurar as casas decimais do cout . Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas?","title":"Aloca\u00e7\u00e3o de mem\u00f3ria"},{"location":"aulas/01-intro-cpp/#contagem-de-tempo","text":"Durante todo o curso iremos trabalhar com medi\u00e7\u00f5es de tempo, especialmente para descobrir quais trechos do nosso c\u00f3digo tem mais impacto no tempo de execu\u00e7\u00e3o. Example Crie um script python que gere uma entrada muito grande ( n=100000 ) para o programa acima. Question Use a ferramenta time para medir o tempo de execu\u00e7\u00e3o do programa. Escreva este valor abaixo. Voc\u00ea consegue dizer quanto tempo o c\u00e1lculo da vari\u00e2ncia leva? Um dos problemas da utiliza\u00e7\u00e3o do comando time \u00e9 que ele n\u00e3o separa o tempo gasto para ler a entrada do programa e o tempo gasto no calculo de cada medida. Felizmente a biblioteca padr\u00e3o de C++ possui diversas classes para medi\u00e7\u00e3o de tempo. O cabe\u00e7alho <chrono> disponibiliza diversas classes e fun\u00e7\u00f5es para medi\u00e7\u00e3o de tempo. Leia sua documenta\u00e7\u00e3o neste link . Question Qual classe voc\u00ea usaria para obter leituras de tempo com a melhor precis\u00e3o poss\u00edvel? Quais m\u00e9todos ou fun\u00e7\u00f5es desta classe seriam \u00fateis? Para que servem as classes time_point e duration ? Example Use as classes acima para medir o tempo de execu\u00e7\u00e3o, separadamente, da m\u00e9dia e da vari\u00e2ncia no exemplo anterior. Escreva abaixo o tempo gasto em milisegundos .","title":"Contagem de tempo"},{"location":"aulas/01-intro-cpp/#projeto-0-revisao-de-c","text":"A parte inicial de nosso curso foca na compreens\u00e3o e implementa\u00e7\u00e3o de fun\u00e7\u00f5es matem\u00e1ticas. Para isso vamos iniciar uma sequ\u00eancia de atividades que far\u00e3o compara\u00e7\u00f5es de desempenho de fun\u00e7\u00f5es do cabe\u00e7alho cmath (que \u00e9 o mesmo math.h que us\u00e1vamos em C , mas agora exportado para usar em C++ ). Example Cria um arquivo chamado parte0.c contendo uma fun\u00e7\u00e3o gera_vetor que recebe um inteiro n e devolve um vetor de dados aleat\u00f3rio de tamanho n com tipo double . fun\u00e7\u00f5es log , sqrt , pow3 (usando a biblioteca math ) e pow3mult (usando o operador * duas vezes) que computam as opera\u00e7\u00f5es correspondentes em cada elemento do vetor. uma fun\u00e7\u00e3o sum que calcula a soma do vetor um main que cria vetores de tamanho incrementalmente maior e computa o tempo necess\u00e1rio para cada fun\u00e7\u00e3o rodar. Question Para cada fun\u00e7\u00e3o criada, coloque abaixo os tempos colhidos para cada tamanho de vetor. O nome da disciplina \u00e9 SuperComputa\u00e7\u00e3o. Honre esse nome ao escolher tamanhos de vetores.","title":"Projeto 0 - revis\u00e3o de C++"},{"location":"aulas/02-stl/","text":"02 - Templates e STL \u00b6 Esta pr\u00e1tica consiste primariamente em aprender a usar tipos de dados complexos disponibilizados pela STL e pela biblioteca padr\u00e3o de C++. A atividade principal desta pr\u00e1tica consiste em modificar o exerc\u00edcio da aula passada para usar as estruturas de dados e fun\u00e7\u00f5es da STL. Smart Pointers \u00b6 Uma das grandes dificuldades de desenvolver em C++ \u00e9 evitar vazamentos de mem\u00f3ria (memory leaks). Durante o desenvolvimento do programa \u00e9 muito usado o recurso de aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria, contudo da mesma forma que o programador tem a responsabilidade de alocar a mem\u00f3ria, ele tem de desalocar a mem\u00f3ria. Os smart pointers s\u00e3o uma estrat\u00e9gia de evitar que voc\u00ea esque\u00e7a de desalocar e crie um programa devorador de mem\u00f3ria. Os smart pointers percebem que uma mem\u00f3ria alocada n\u00e3o \u00e9 mais acess\u00edvel e desaloca a mem\u00f3ria. unique_ptr : um smart pointer para um \u00fanico objeto com um dono s\u00f3. Ou seja, este smart pointer aponta para um objeto que deve ter s\u00f3 um apontamento de cada vez. Ao realizarmos atribui\u00e7\u00f5es a vari\u00e1vel \"dono\" do objeto muda. shared_ptr : Um smart pointer para um \u00fanico objeto e pode ter v\u00e1rios donos. Ou seja, este smart pointer aponta para um objeto que pode ter v\u00e1rios apontamentos de cada vez. Ao realizarmos atribui\u00e7\u00f5es adicionamos uma nova refer\u00eancia a este dado. Quando n\u00e3o existem mais refer\u00eancias o dado \u00e9 automaticamente liberado usando delete Example Corrija o uso de mem\u00f3ria absurdo do programa abaixo (arquivo tarefa1.cpp ) usando smart pointers. #include <iostream> int main () { int * ptr = new int ( 0 ); for ( int f = 0 ; f < 1024 * 1024 * 1024 ; f ++ ) { ptr = new int ( f ); } std :: cout << \"valor final = \" << * ptr << std :: endl ; delete ptr ; } Example Corrija o uso de mem\u00f3ria absurdo do programa abaixo (arquivo tarefa2.cpp ) usando smart pointers. #include <iostream> int foo ( int x ) { int * vec1 = new int [ 8 ]; for ( int f = 0 ; f < 8 ; f ++ ) vec1 [ f ] = f * x ; int * vec2 = vec1 ; int tmp = vec1 [ 0 ] + vec1 [ 4 ] + vec1 [ 7 ] - vec1 [ 5 ]; return tmp ; } int main () { long int tmp = 0 ; for ( int f = 0 ; f < 1024 * 1024 * 512 ; f ++ ) tmp += foo ( f ); std :: cout << tmp << std :: endl ; } Strings e Vector \u00b6 Nesta se\u00e7\u00e3o iremos trabalhar com dois conteiners muito usados da STL: string e vector . O objetivo \u00e9 acostum\u00e1-los a consultar a documenta\u00e7\u00e3o de C++ e entend\u00ea-la com autonomia. A STL tem uma quantidade enorme de recursos e aprender a pesquisar como us\u00e1-los \u00e9 importante para sua profici\u00eancia. Example Fa\u00e7a um programa que l\u00ea uma linha de texto (usando std::getline ) e procure nela todas as ocorr\u00eancias da palavra \"hello\". Voc\u00ea dever\u00e1 implementar uma fun\u00e7\u00e3o std::vector<int> find_all(std::string text, std::string term); que devolve um vetor com a posi\u00e7\u00e3o de todas as ocorr\u00eancias de term em text . Sua fun\u00e7\u00e3o main dever\u00e1 mostrar os resultados da busca de maneira bem formatada. Projeto 0 - adicionando STL \u00b6 O c\u00f3digo produzido na \u00faltima aula parece muito com c\u00f3digo C e usa muito pouco dos recursos introduzidos em C++ para tornar nossos programas mais leg\u00edveis e f\u00e1ceis de escrever. Example Modifique sua fun\u00e7\u00e3o gera_vetor para usar std::vector ao inv\u00e9s de arrays puros e para usar o cabe\u00e7alho <random> . A distribui\u00e7\u00e3o usada dever\u00e1 ser uniforme real com limites 5 a 27. Example Modifique todas as fun\u00e7\u00f5es ( log , sqrt , pow3 , pow3mult e sum ) para receber std::vector . Note que voc\u00ea n\u00e3o precisa mais receber como argumento o tamanho do vetor. Question Qual dever\u00e1 ser a assinatura das fun\u00e7\u00f5es acima para evitar que ocorra c\u00f3pia do std::vector ? Example Continuando o exerc\u00edcio acima, use iteradores para percorrer seu std::vector . Para deixar o c\u00f3digo mais leg\u00edvel use auto Vamos agora trabalhar com programa\u00e7\u00e3o funcional em C++ para tornar nosso c\u00f3digo menor: armazenamento de refer\u00eancias para fun\u00e7\u00f5es em vari\u00e1veis e defini\u00e7\u00e3o de fun\u00e7\u00f5es usando lambda . Podemos definir fun\u00e7\u00f5es no meio de nosso programa usando a seguinte sintaxe: [ &|= ] ( argumentos ) -> retorno { corpo da fun\u00e7\u00e3o aqui }; Uma fun\u00e7\u00e3o definida desta maneira pode usar as vari\u00e1veis locais dispon\u00edveis no momento em que ela foi declarada (mesmo que n\u00e3o sejam passadas como argumento). A primeira parte da declara\u00e7\u00e3o define se essas vari\u00e1veis ser\u00e3o copiadas [=] ou se uma refer\u00eancia para elas ser\u00e1 utilizada na fun\u00e7\u00e3o [&] . O restante segue padr\u00f5es normalmente usados em C++ . Podemos inclusive, passar essas fun\u00e7\u00f5es como argumentos e devolv\u00ea-las como resultado de fun\u00e7\u00f5es. Para isto usamos o tipo std::function dispon\u00edvel no cabe\u00e7alho functional . Os exerc\u00edcios abaixo foram extra\u00eddos do arquivo exemplos-lambda.cpp . Fa\u00e7a-os e cheque seus resultados rodando o programa. Se houver d\u00favida chame o professor. Question Qual \u00e9 o resultado do c\u00f3digo abaixo? int c = 2 ; std :: functional < double ( int ) > by_two = [ = ]( int n ) { return double ( n ) / c ; }; std :: cout << by_two ( 5 ) << \" \\n \" ; Question Qual \u00e9 o resultado do c\u00f3digo abaixo? int c = 2 ; std :: function < double ( int ) > by_c = [ & ]( int n ) { return double ( n ) / c ; }; std :: cout << by_c ( 7 ) << \" \\n \" ; c = 3 ; std :: cout << by_c ( 7 ) << \" \\n \" ; Question Escreva abaixo o tipo de uma vari\u00e1vel que guarda refer\u00eancia para as fun\u00e7\u00f5es que testamos neste exerc\u00edcio log sqrt pow3 pow3mult sum Example Crie uma fun\u00e7\u00e3o std::vector<double> teste_incremental( tipo aqui ) que recebe as fun\u00e7\u00f5es acima e as executa. Sua fun\u00e7\u00e3o dever\u00e1 devolver os tempos (em segundos) para todas as execu\u00e7\u00f5es feitas. Ou seja, a fun\u00e7\u00e3o teste_incremental dever\u00e1 funcionar como uma \"casquinha\" que gera vetores, roda as fun\u00e7\u00f5es matem\u00e1ticas testadas e retorna seus tempos de execu\u00e7\u00e3o. Example voc\u00ea deve ter notado que a fun\u00e7\u00e3o sum n\u00e3o possui a mesma assinatura das outras. Use uma fun\u00e7\u00e3o lambda para adaptar os tipos e usar a fun\u00e7\u00e3o acima para testar a fun\u00e7\u00e3o sum tamb\u00e9m.","title":"02 - Templates e STL"},{"location":"aulas/02-stl/#02-templates-e-stl","text":"Esta pr\u00e1tica consiste primariamente em aprender a usar tipos de dados complexos disponibilizados pela STL e pela biblioteca padr\u00e3o de C++. A atividade principal desta pr\u00e1tica consiste em modificar o exerc\u00edcio da aula passada para usar as estruturas de dados e fun\u00e7\u00f5es da STL.","title":"02 - Templates e STL"},{"location":"aulas/02-stl/#smart-pointers","text":"Uma das grandes dificuldades de desenvolver em C++ \u00e9 evitar vazamentos de mem\u00f3ria (memory leaks). Durante o desenvolvimento do programa \u00e9 muito usado o recurso de aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria, contudo da mesma forma que o programador tem a responsabilidade de alocar a mem\u00f3ria, ele tem de desalocar a mem\u00f3ria. Os smart pointers s\u00e3o uma estrat\u00e9gia de evitar que voc\u00ea esque\u00e7a de desalocar e crie um programa devorador de mem\u00f3ria. Os smart pointers percebem que uma mem\u00f3ria alocada n\u00e3o \u00e9 mais acess\u00edvel e desaloca a mem\u00f3ria. unique_ptr : um smart pointer para um \u00fanico objeto com um dono s\u00f3. Ou seja, este smart pointer aponta para um objeto que deve ter s\u00f3 um apontamento de cada vez. Ao realizarmos atribui\u00e7\u00f5es a vari\u00e1vel \"dono\" do objeto muda. shared_ptr : Um smart pointer para um \u00fanico objeto e pode ter v\u00e1rios donos. Ou seja, este smart pointer aponta para um objeto que pode ter v\u00e1rios apontamentos de cada vez. Ao realizarmos atribui\u00e7\u00f5es adicionamos uma nova refer\u00eancia a este dado. Quando n\u00e3o existem mais refer\u00eancias o dado \u00e9 automaticamente liberado usando delete Example Corrija o uso de mem\u00f3ria absurdo do programa abaixo (arquivo tarefa1.cpp ) usando smart pointers. #include <iostream> int main () { int * ptr = new int ( 0 ); for ( int f = 0 ; f < 1024 * 1024 * 1024 ; f ++ ) { ptr = new int ( f ); } std :: cout << \"valor final = \" << * ptr << std :: endl ; delete ptr ; } Example Corrija o uso de mem\u00f3ria absurdo do programa abaixo (arquivo tarefa2.cpp ) usando smart pointers. #include <iostream> int foo ( int x ) { int * vec1 = new int [ 8 ]; for ( int f = 0 ; f < 8 ; f ++ ) vec1 [ f ] = f * x ; int * vec2 = vec1 ; int tmp = vec1 [ 0 ] + vec1 [ 4 ] + vec1 [ 7 ] - vec1 [ 5 ]; return tmp ; } int main () { long int tmp = 0 ; for ( int f = 0 ; f < 1024 * 1024 * 512 ; f ++ ) tmp += foo ( f ); std :: cout << tmp << std :: endl ; }","title":"Smart Pointers"},{"location":"aulas/02-stl/#strings-e-vector","text":"Nesta se\u00e7\u00e3o iremos trabalhar com dois conteiners muito usados da STL: string e vector . O objetivo \u00e9 acostum\u00e1-los a consultar a documenta\u00e7\u00e3o de C++ e entend\u00ea-la com autonomia. A STL tem uma quantidade enorme de recursos e aprender a pesquisar como us\u00e1-los \u00e9 importante para sua profici\u00eancia. Example Fa\u00e7a um programa que l\u00ea uma linha de texto (usando std::getline ) e procure nela todas as ocorr\u00eancias da palavra \"hello\". Voc\u00ea dever\u00e1 implementar uma fun\u00e7\u00e3o std::vector<int> find_all(std::string text, std::string term); que devolve um vetor com a posi\u00e7\u00e3o de todas as ocorr\u00eancias de term em text . Sua fun\u00e7\u00e3o main dever\u00e1 mostrar os resultados da busca de maneira bem formatada.","title":"Strings e Vector"},{"location":"aulas/02-stl/#projeto-0-adicionando-stl","text":"O c\u00f3digo produzido na \u00faltima aula parece muito com c\u00f3digo C e usa muito pouco dos recursos introduzidos em C++ para tornar nossos programas mais leg\u00edveis e f\u00e1ceis de escrever. Example Modifique sua fun\u00e7\u00e3o gera_vetor para usar std::vector ao inv\u00e9s de arrays puros e para usar o cabe\u00e7alho <random> . A distribui\u00e7\u00e3o usada dever\u00e1 ser uniforme real com limites 5 a 27. Example Modifique todas as fun\u00e7\u00f5es ( log , sqrt , pow3 , pow3mult e sum ) para receber std::vector . Note que voc\u00ea n\u00e3o precisa mais receber como argumento o tamanho do vetor. Question Qual dever\u00e1 ser a assinatura das fun\u00e7\u00f5es acima para evitar que ocorra c\u00f3pia do std::vector ? Example Continuando o exerc\u00edcio acima, use iteradores para percorrer seu std::vector . Para deixar o c\u00f3digo mais leg\u00edvel use auto Vamos agora trabalhar com programa\u00e7\u00e3o funcional em C++ para tornar nosso c\u00f3digo menor: armazenamento de refer\u00eancias para fun\u00e7\u00f5es em vari\u00e1veis e defini\u00e7\u00e3o de fun\u00e7\u00f5es usando lambda . Podemos definir fun\u00e7\u00f5es no meio de nosso programa usando a seguinte sintaxe: [ &|= ] ( argumentos ) -> retorno { corpo da fun\u00e7\u00e3o aqui }; Uma fun\u00e7\u00e3o definida desta maneira pode usar as vari\u00e1veis locais dispon\u00edveis no momento em que ela foi declarada (mesmo que n\u00e3o sejam passadas como argumento). A primeira parte da declara\u00e7\u00e3o define se essas vari\u00e1veis ser\u00e3o copiadas [=] ou se uma refer\u00eancia para elas ser\u00e1 utilizada na fun\u00e7\u00e3o [&] . O restante segue padr\u00f5es normalmente usados em C++ . Podemos inclusive, passar essas fun\u00e7\u00f5es como argumentos e devolv\u00ea-las como resultado de fun\u00e7\u00f5es. Para isto usamos o tipo std::function dispon\u00edvel no cabe\u00e7alho functional . Os exerc\u00edcios abaixo foram extra\u00eddos do arquivo exemplos-lambda.cpp . Fa\u00e7a-os e cheque seus resultados rodando o programa. Se houver d\u00favida chame o professor. Question Qual \u00e9 o resultado do c\u00f3digo abaixo? int c = 2 ; std :: functional < double ( int ) > by_two = [ = ]( int n ) { return double ( n ) / c ; }; std :: cout << by_two ( 5 ) << \" \\n \" ; Question Qual \u00e9 o resultado do c\u00f3digo abaixo? int c = 2 ; std :: function < double ( int ) > by_c = [ & ]( int n ) { return double ( n ) / c ; }; std :: cout << by_c ( 7 ) << \" \\n \" ; c = 3 ; std :: cout << by_c ( 7 ) << \" \\n \" ; Question Escreva abaixo o tipo de uma vari\u00e1vel que guarda refer\u00eancia para as fun\u00e7\u00f5es que testamos neste exerc\u00edcio log sqrt pow3 pow3mult sum Example Crie uma fun\u00e7\u00e3o std::vector<double> teste_incremental( tipo aqui ) que recebe as fun\u00e7\u00f5es acima e as executa. Sua fun\u00e7\u00e3o dever\u00e1 devolver os tempos (em segundos) para todas as execu\u00e7\u00f5es feitas. Ou seja, a fun\u00e7\u00e3o teste_incremental dever\u00e1 funcionar como uma \"casquinha\" que gera vetores, roda as fun\u00e7\u00f5es matem\u00e1ticas testadas e retorna seus tempos de execu\u00e7\u00e3o. Example voc\u00ea deve ter notado que a fun\u00e7\u00e3o sum n\u00e3o possui a mesma assinatura das outras. Use uma fun\u00e7\u00e3o lambda para adaptar os tipos e usar a fun\u00e7\u00e3o acima para testar a fun\u00e7\u00e3o sum tamb\u00e9m.","title":"Projeto 0 - adicionando STL"},{"location":"aulas/03-cmake/","text":"03 - CMake e Debugging no VSCode \u00b6 At\u00e9 o momento todos nossos arquivos eram compilados em uma s\u00f3 linha usando g++ . Conforme projetos ficam maiores e s\u00e3o divididos em v\u00e1rios m\u00f3dulos isto se torna invi\u00e1vel. Neste roteiro iremos usar o CMake, uma ferramenta de gerenciamento de projetos em C++. No fim, iremos configurar o VSCode para abrir projetos CMake. Aten\u00e7\u00e3o Usar ferramentas adequadas aumenta consideravelmente a produtividade e tamb\u00e9m facilita encontrar erros no c\u00f3digo. A partir desta aula ser\u00e1 obrigat\u00f3rio j\u00e1 ter debugado o programa antes de tirar d\u00favidas. Gerenciamento de projetos com CMake \u00b6 O CMake \u00e9 uma das ferramentas mais usadas para gerenciar projetos C/C++. Outras ferramentas comumente usadas s\u00e3o ninja e meson . Em CMake , um projeto \u00e9 definido por um arquivo nomeado CMakeLists.txt . Este arquivo cont\u00e9m defini\u00e7\u00f5es como nome do projeto, quais depend\u00eancias (bibliotecas externas e subprojetos) s\u00e3o usadas e o quais arquivos ser\u00e3o gerados pelo projeto. Cada arquivo gerado \u00e9 chamado de target na nomenclatura usada pelo CMake e pode ser um execut\u00e1vel ou uma biblioteca (est\u00e1tica ou din\u00e2mica). Um arquivo CMakeLists.txt b\u00e1sico pode conter apenas tr\u00eas linhas (pasta 03-cmake ): cmake_minimum_required(VERSION 3.12) project (projeto_basico) add_executable(hello hello.cpp) Este arquivo somente descreve o projeto. Para efetivamente compilarmos o programa precisamos passar pela fase de configura\u00e7\u00e3o , em que o CMake checa se todas as depend\u00eancias foram encontradas e se os compiladores necess\u00e1rios est\u00e3o instalados. Se tudo estiver em ordem podemos gerar um Makefile (para Linux) ou um projeto do Visual Studio (para Windows). Para fazer a configura\u00e7\u00e3o do projeto basta rodar o comando cmake mais o caminho para a pasta do projeto. Voc\u00ea s\u00f3 precisar\u00e1 refazer a configura\u00e7\u00e3o do projeto se modificar o arquivo CMakeLists.txt . \u00c9 boa pr\u00e1tica fazer a compila\u00e7\u00e3o do c\u00f3digo em uma pasta separada, como na sequ\u00eancia de comandos abaixo. mkdir build cd build cmake .. Estes comandos devem ter gerado uma s\u00e9rie de arquivos na pasta build , incluindo um Makefile . Para compilar o projeto basta rodar make E um execut\u00e1vel de nome hello dever\u00e1 aparecer na pasta build . Exerc\u00edcio Crie um arquivo CMakeLists.txt para o projeto 0. Voc\u00ea dever\u00e1 adicionar um target chamado vector_ops . Exerc\u00edcio Separe as fun\u00e7\u00f5es matem\u00e1ticas testadas em arquivos .cpp/h e use-os no seu projeto. A diretiva add_executable aceita v\u00e1rios arquivos .cpp para criar um execut\u00e1vel. Op\u00e7\u00f5es de compila\u00e7\u00e3o \u00b6 Al\u00e9m da cria\u00e7\u00e3o de execut\u00e1veis o CMake tamb\u00e9m permite adicionar op\u00e7\u00f5es de compila\u00e7\u00e3o espec\u00edficas para cada target com a diretiva target_compile_options . No contexto desta mat\u00e9ria isto ser\u00e1 especialmente interessante pois o g++ oferece flags para ativar otimiza\u00e7\u00f5es que podem melhorar significativamente o desempenho de nosso programa. Portanto, podemos facilmente compilar o mesmo programa com e sem otimiza\u00e7\u00f5es no mesmo projeto! O exemplo abaixo ativa a flag O3 no target hello criado no exemplo anterior. target_compile_options(hello O3) Podemos tamb\u00e9m usar #define para fazer compila\u00e7\u00e3o condicional do nosso c\u00f3digo. Usar a diretiva abaixo equivale e colocar um #define OPT no topo de cada arquivo do target hello . target_compile_definitions(hello OPT) Exerc\u00edcio Modifique seu target vector_ops para que ele use a op\u00e7\u00e3o de compila\u00e7\u00e3o O2 . Exerc\u00edcio Crie um novo target vector_ops_no_opt que compile os mesmos arquivos de vector_ops mas use a op\u00e7\u00e3o de compila\u00e7\u00e3o O0 . Projeto 0 - Benchmarking e compara\u00e7\u00f5es de desempenho \u00b6 Vamos agora fazer um pequeno resumo dos resultados dos experimentos. Este resumo dever\u00e1 conter os seguintes itens e dever\u00e1 ser entregue em formato PDF . uma breve descri\u00e7\u00e3o do programa testado (um par\u00e1grafo); os nomes dos execut\u00e1veis testados e qual a diferen\u00e7a entre eles os tamanhos de entrada usados e a m\u00e1quina usada para seus testes gr\u00e1ficos ilustrando a diferen\u00e7a de desempenho para cada fun\u00e7\u00e3o testada coment\u00e1rios sobre os resultados mostrados nos gr\u00e1ficos Dicas \u00b6 Ferramentas como PWeave ou Jupyter Notebook ajudam muito a criar textos que misturam c\u00f3digo para criar gr\u00e1ficos, rodar programas automaticamente e interpretar sua sa\u00edda. Tente automatizar o m\u00e1ximo poss\u00edvel a gera\u00e7\u00e3o de gr\u00e1ficos de desempenho. Isso facilitar\u00e1 muito sua vida em projetos posteriores. Extra 01 - Debugando seu projeto \u00b6 Agora iremos abrir nosso projeto um ambiente de desenvolvimento em vez de continuar trabalhando na linha de comando. Adotaremos o VSCode como ambiente padr\u00e3o. O VSCode n\u00e3o vem com suporte por padr\u00e3o a projetos CMake, mas a extens\u00e3o Cmake Tools possui um bom suporte. Instale-a e carregue o projeto. A extens\u00e3o possui uma documenta\u00e7\u00e3o tanto para a etapa de configura\u00e7\u00e3o e compila\u00e7\u00e3o quanto para execu\u00e7\u00e3o dos programas e debugging . Para executar os programas voc\u00ea pode usar a op\u00e7\u00e3o \"Run in terminal\" dispon\u00edvel no menu do bot\u00e3o direito de cada target . Supondo que a etapa anterior funcionou, vamos agora rodar o nosso programa usando um debugger. Isto permite parar a execu\u00e7\u00e3o no meio do programa e examinar o valor das vari\u00e1veis. coloque um ou mais breakpoints no c\u00f3digo. Basta clicar ao lado do n\u00famero da linha. Um c\u00edrculo vermelho indica que a execu\u00e7\u00e3o ser\u00e1 interrompida quando chegar nesta linha. bot\u00e3o direito no target -> \"Run with debugger\". quando o programa parar teremos as seguintes op\u00e7\u00f5es: Continue : roda at\u00e9 o pr\u00f3ximo breakpoint Step Over : roda a linha atual e passa para a pr\u00f3xima. Step Into : se a linha atual tem uma chamada de fun\u00e7\u00e3o, continua o debug dentro da fun\u00e7\u00e3o chamada. Step Out : executa at\u00e9 o fim da fun\u00e7\u00e3o atual e para logo ap\u00f3s o retorno. Tamb\u00e9m podemos colocar o mouse em cima de cada vari\u00e1vel para ver seu valor. O explorador de vari\u00e1veis (que mostra todas as v\u00e1lidas na fun\u00e7\u00e3o atual) aparece no painel esquerdo, dentro da view debug . Exerc\u00edcio Abra sua atividade e rode-a com o debugger. Pause a execu\u00e7\u00e3o no meio e verifique os tempos de execu\u00e7\u00e3o.","title":"03 - CMake e Debugging no VSCode"},{"location":"aulas/03-cmake/#03-cmake-e-debugging-no-vscode","text":"At\u00e9 o momento todos nossos arquivos eram compilados em uma s\u00f3 linha usando g++ . Conforme projetos ficam maiores e s\u00e3o divididos em v\u00e1rios m\u00f3dulos isto se torna invi\u00e1vel. Neste roteiro iremos usar o CMake, uma ferramenta de gerenciamento de projetos em C++. No fim, iremos configurar o VSCode para abrir projetos CMake. Aten\u00e7\u00e3o Usar ferramentas adequadas aumenta consideravelmente a produtividade e tamb\u00e9m facilita encontrar erros no c\u00f3digo. A partir desta aula ser\u00e1 obrigat\u00f3rio j\u00e1 ter debugado o programa antes de tirar d\u00favidas.","title":"03 - CMake e Debugging no VSCode"},{"location":"aulas/03-cmake/#gerenciamento-de-projetos-com-cmake","text":"O CMake \u00e9 uma das ferramentas mais usadas para gerenciar projetos C/C++. Outras ferramentas comumente usadas s\u00e3o ninja e meson . Em CMake , um projeto \u00e9 definido por um arquivo nomeado CMakeLists.txt . Este arquivo cont\u00e9m defini\u00e7\u00f5es como nome do projeto, quais depend\u00eancias (bibliotecas externas e subprojetos) s\u00e3o usadas e o quais arquivos ser\u00e3o gerados pelo projeto. Cada arquivo gerado \u00e9 chamado de target na nomenclatura usada pelo CMake e pode ser um execut\u00e1vel ou uma biblioteca (est\u00e1tica ou din\u00e2mica). Um arquivo CMakeLists.txt b\u00e1sico pode conter apenas tr\u00eas linhas (pasta 03-cmake ): cmake_minimum_required(VERSION 3.12) project (projeto_basico) add_executable(hello hello.cpp) Este arquivo somente descreve o projeto. Para efetivamente compilarmos o programa precisamos passar pela fase de configura\u00e7\u00e3o , em que o CMake checa se todas as depend\u00eancias foram encontradas e se os compiladores necess\u00e1rios est\u00e3o instalados. Se tudo estiver em ordem podemos gerar um Makefile (para Linux) ou um projeto do Visual Studio (para Windows). Para fazer a configura\u00e7\u00e3o do projeto basta rodar o comando cmake mais o caminho para a pasta do projeto. Voc\u00ea s\u00f3 precisar\u00e1 refazer a configura\u00e7\u00e3o do projeto se modificar o arquivo CMakeLists.txt . \u00c9 boa pr\u00e1tica fazer a compila\u00e7\u00e3o do c\u00f3digo em uma pasta separada, como na sequ\u00eancia de comandos abaixo. mkdir build cd build cmake .. Estes comandos devem ter gerado uma s\u00e9rie de arquivos na pasta build , incluindo um Makefile . Para compilar o projeto basta rodar make E um execut\u00e1vel de nome hello dever\u00e1 aparecer na pasta build . Exerc\u00edcio Crie um arquivo CMakeLists.txt para o projeto 0. Voc\u00ea dever\u00e1 adicionar um target chamado vector_ops . Exerc\u00edcio Separe as fun\u00e7\u00f5es matem\u00e1ticas testadas em arquivos .cpp/h e use-os no seu projeto. A diretiva add_executable aceita v\u00e1rios arquivos .cpp para criar um execut\u00e1vel.","title":"Gerenciamento de projetos com CMake"},{"location":"aulas/03-cmake/#opcoes-de-compilacao","text":"Al\u00e9m da cria\u00e7\u00e3o de execut\u00e1veis o CMake tamb\u00e9m permite adicionar op\u00e7\u00f5es de compila\u00e7\u00e3o espec\u00edficas para cada target com a diretiva target_compile_options . No contexto desta mat\u00e9ria isto ser\u00e1 especialmente interessante pois o g++ oferece flags para ativar otimiza\u00e7\u00f5es que podem melhorar significativamente o desempenho de nosso programa. Portanto, podemos facilmente compilar o mesmo programa com e sem otimiza\u00e7\u00f5es no mesmo projeto! O exemplo abaixo ativa a flag O3 no target hello criado no exemplo anterior. target_compile_options(hello O3) Podemos tamb\u00e9m usar #define para fazer compila\u00e7\u00e3o condicional do nosso c\u00f3digo. Usar a diretiva abaixo equivale e colocar um #define OPT no topo de cada arquivo do target hello . target_compile_definitions(hello OPT) Exerc\u00edcio Modifique seu target vector_ops para que ele use a op\u00e7\u00e3o de compila\u00e7\u00e3o O2 . Exerc\u00edcio Crie um novo target vector_ops_no_opt que compile os mesmos arquivos de vector_ops mas use a op\u00e7\u00e3o de compila\u00e7\u00e3o O0 .","title":"Op\u00e7\u00f5es de compila\u00e7\u00e3o"},{"location":"aulas/03-cmake/#projeto-0-benchmarking-e-comparacoes-de-desempenho","text":"Vamos agora fazer um pequeno resumo dos resultados dos experimentos. Este resumo dever\u00e1 conter os seguintes itens e dever\u00e1 ser entregue em formato PDF . uma breve descri\u00e7\u00e3o do programa testado (um par\u00e1grafo); os nomes dos execut\u00e1veis testados e qual a diferen\u00e7a entre eles os tamanhos de entrada usados e a m\u00e1quina usada para seus testes gr\u00e1ficos ilustrando a diferen\u00e7a de desempenho para cada fun\u00e7\u00e3o testada coment\u00e1rios sobre os resultados mostrados nos gr\u00e1ficos","title":"Projeto 0 - Benchmarking e compara\u00e7\u00f5es de desempenho"},{"location":"aulas/03-cmake/#dicas","text":"Ferramentas como PWeave ou Jupyter Notebook ajudam muito a criar textos que misturam c\u00f3digo para criar gr\u00e1ficos, rodar programas automaticamente e interpretar sua sa\u00edda. Tente automatizar o m\u00e1ximo poss\u00edvel a gera\u00e7\u00e3o de gr\u00e1ficos de desempenho. Isso facilitar\u00e1 muito sua vida em projetos posteriores.","title":"Dicas"},{"location":"aulas/03-cmake/#extra-01-debugando-seu-projeto","text":"Agora iremos abrir nosso projeto um ambiente de desenvolvimento em vez de continuar trabalhando na linha de comando. Adotaremos o VSCode como ambiente padr\u00e3o. O VSCode n\u00e3o vem com suporte por padr\u00e3o a projetos CMake, mas a extens\u00e3o Cmake Tools possui um bom suporte. Instale-a e carregue o projeto. A extens\u00e3o possui uma documenta\u00e7\u00e3o tanto para a etapa de configura\u00e7\u00e3o e compila\u00e7\u00e3o quanto para execu\u00e7\u00e3o dos programas e debugging . Para executar os programas voc\u00ea pode usar a op\u00e7\u00e3o \"Run in terminal\" dispon\u00edvel no menu do bot\u00e3o direito de cada target . Supondo que a etapa anterior funcionou, vamos agora rodar o nosso programa usando um debugger. Isto permite parar a execu\u00e7\u00e3o no meio do programa e examinar o valor das vari\u00e1veis. coloque um ou mais breakpoints no c\u00f3digo. Basta clicar ao lado do n\u00famero da linha. Um c\u00edrculo vermelho indica que a execu\u00e7\u00e3o ser\u00e1 interrompida quando chegar nesta linha. bot\u00e3o direito no target -> \"Run with debugger\". quando o programa parar teremos as seguintes op\u00e7\u00f5es: Continue : roda at\u00e9 o pr\u00f3ximo breakpoint Step Over : roda a linha atual e passa para a pr\u00f3xima. Step Into : se a linha atual tem uma chamada de fun\u00e7\u00e3o, continua o debug dentro da fun\u00e7\u00e3o chamada. Step Out : executa at\u00e9 o fim da fun\u00e7\u00e3o atual e para logo ap\u00f3s o retorno. Tamb\u00e9m podemos colocar o mouse em cima de cada vari\u00e1vel para ver seu valor. O explorador de vari\u00e1veis (que mostra todas as v\u00e1lidas na fun\u00e7\u00e3o atual) aparece no painel esquerdo, dentro da view debug . Exerc\u00edcio Abra sua atividade e rode-a com o debugger. Pause a execu\u00e7\u00e3o no meio e verifique os tempos de execu\u00e7\u00e3o.","title":"Extra 01 - Debugando seu projeto"},{"location":"aulas/04-autovec/","text":"04 - SIMD: Autovetoriza\u00e7\u00e3o \u00b6 Programas de fazer c\u00e1lculos podem ser acelerados significativamente por instru\u00e7\u00f5es SIMD ( Single Instruction Multiple Data ). Neste contexto, a utiliza\u00e7\u00e3o de compiladores com op\u00e7\u00e3o de autovetoriza\u00e7\u00e3o \u00e9 muito conveniente: se o c\u00f3digo compilado tiver algumas caracter\u00edsticas o compilador \u00e9 capaz utilizar estas instru\u00e7\u00f5es automaticamente e melhorar muito o desempenho sem que um programador precise modificar c\u00f3digo. Um guia para autovetoriza\u00e7\u00e3o usando gcc pode ser encontrado em sua documenta\u00e7\u00e3o . Info Os exerc\u00edcios de aula podem ser feitos em dupla. Capacidade dos registradores \u00b6 Question Levando em conta que a arquitetura AVX armazena dados em registradores de 128 bits , podemos armazenar em um \u00fanico registrador at\u00e9: ____ chars; ____ shorts; ____ ints; ____ longs; ____ floats; ____ doubles; Question A arquitetura AVX2 suporta registradores de 256 bits . Isto significa que c\u00f3digo autovetorizado com instru\u00e7\u00f5es AVX2 pode ser at\u00e9 ____ vezes mais r\u00e1pido do que c\u00f3digo vetorizado com AVX Question Toda instru\u00e7\u00e3o SIMD opera sobre todos os elementos guardados ao mesmo tempo. Ou seja, ao executar uma instru\u00e7\u00e3o SIMD de soma de vari\u00e1veis int no registrador %xmm0 estarei somando ____ vari\u00e1veis em uma s\u00f3 instru\u00e7\u00e3o. Instru\u00e7\u00f5es vetoriais \u00b6 Vamos agora compilar alguns c\u00f3digos em C++ para Assembly usando as op\u00e7\u00f5es -ffast-math -ftree-vectorize -mavx do gcc . Estas op\u00e7\u00f5es habilitam a autovetoriza\u00e7\u00e3o de c\u00f3digo. Ou sejam elas analisam o c\u00f3digo e procuram substituir loops e acessos sequenciais a vetores por instru\u00e7\u00f5es SIMD que fa\u00e7am o mesmo trabalho. A flag -mavx indica que o c\u00f3digo de m\u00e1quina gerado pode utilizar instru\u00e7\u00f5es SIMD da arquitetura AVX (e de sua predecessora, SSE), que usa registradores de 128 bits nomeados %xmm0 at\u00e9 %xmm7 e de 256 bits nomeados %ymm0 at\u00e9 %ymm15 . Vamos agora analisar o c\u00f3digo Assembly de uma fun\u00e7\u00e3o simples que soma todos elementos de um vetor. // Original: Nicolas Brailovsky #define SIZE (400) long sum ( long v [ SIZE ]) { long * d = new long [ SIZE ]; long s = 0 ; // este exemplo eh didatico. soma de ints deveria ser long ;) for ( long i = 0 ; i < SIZE ; i ++ ) s += v [ i ]; return s ; } Example Compile este c\u00f3digo com otimiza\u00e7\u00f5es b\u00e1sicas ( -O2 ) $ g++ -S -c -O2 tarefa1.cpp -o /dev/stdout | c++filt Agora adicione autovetoriza\u00e7\u00e3o (com as flags listadas acima) $ g++ -S -c -O2 -ffast-math -ftree-vectorize -mavx tarefa1.cpp -o /dev/stdout | c++filt Question Compare as instru\u00e7\u00f5es Assembly geradas acima e escreva abaixo as diferen\u00e7as percebidas. Voc\u00ea consegue explicar seu funcionamento? Aplicando autovetoriza\u00e7\u00e3o \u00b6 Nesta tarefa iremos trabalhar com as op\u00e7\u00f5es de autovetoriza\u00e7\u00e3o do gcc para entender como escrever c\u00f3digo que possa ser otimizado automaticamente. Example Escreva uma fun\u00e7\u00e3o main que gera um vetor de tamanho 10.000.000 contendo n\u00fameros aleat\u00f3rios uniformemente distribu\u00eddos entre -10 e 10 . Use as fun\u00e7\u00f5es do cabe\u00e7alho <random> . Example Escreva uma fun\u00e7\u00e3o double soma_positivos1(double *a, int n) que soma todos os n\u00fameros positivos do vetor a . Adicione uma chamada a esta fun\u00e7\u00e3o no seu main e use as fun\u00e7\u00f5es do cabe\u00e7alho <chrono> para medir o tempo de execu\u00e7\u00e3o da sua fun\u00e7\u00e3o. Neste exerc\u00edcio voc\u00ea dever\u00e1 usar um if para checar se os n\u00fameros s\u00e3o positivos. Question Compile com e sem as otimiza\u00e7\u00f5es SIMD e escreva abaixo os tempos de execu\u00e7\u00e3o. O auto vetorizador suporta uma s\u00e9rie de padr\u00f5es de codifica\u00e7\u00e3o relativamente abrangente ( lista completa ). Por\u00e9m, c\u00f3digos que s\u00e3o vetorizados de maneira id\u00eantica podem possuir desempenho bastante diferente quanto a vetoriza\u00e7\u00e3o n\u00e3o est\u00e1 habilitada. Example Fa\u00e7a uma fun\u00e7\u00e3o double soma_positivos2(double *a, int n) que faz o mesmo que a fun\u00e7\u00e3o anterior, mas usando agora o operador tern\u00e1rio (cond)?expr_true:expr_false ao inv\u00e9s de um if . (Se voc\u00ea fez com o operador tern\u00e1rio acima fa\u00e7a com if ). Houve diferen\u00e7a de desempenho na vers\u00e3o SIMD? E na vers\u00e3o sem SIMD? Question Complete a tabela abaixo com os tempos obtidos - SIMD sem SIMD if-else tern\u00e1rio Exerc\u00edcio Qual vers\u00e3o da fun\u00e7\u00e3o anterior voc\u00ea usaria se seu c\u00f3digo fosse executado em processadores de baixo custo (Intel Celeron) ou muito antigos (mais de 5 anos)? E se o plano for executar em processadores novos? Projeto 0 - aplicando autovetoriza\u00e7\u00e3o \u00b6 Warning Os exerc\u00edcios do Projeto 0 s\u00e3o individuais. Nas \u00faltimas duas tarefas vimos como usar as op\u00e7\u00f5es do compilador para gerar instru\u00e7\u00f5es SIMD, tornando nossos programas mais eficientes. Agora vamos aplic\u00e1-las ao nosso exemplo dos experimentos. Voc\u00ea dever\u00e1 criar um novo target vector_ops_simd com as op\u00e7\u00f5es de compila\u00e7\u00e3o SIMD e a flag de otimiza\u00e7\u00e3o O3 atualizar seus gr\u00e1ficos de desempenho com o novo experimento comentar os novos resultados, respondendo \u00e0s seguintes perguntas: A partir de qual tamanho de array o c\u00f3digo vetorizado mostra ganhos de desempenho expressivos? Qual \u00e9 o ganho de desempenho esperado? Leve em conta a arquitetura usada e o tipo de dados usado. Os ganhos de desempenho s\u00e3o consistentes com o esperado?","title":"04 - SIMD: Autovetoriza\u00e7\u00e3o"},{"location":"aulas/04-autovec/#04-simd-autovetorizacao","text":"Programas de fazer c\u00e1lculos podem ser acelerados significativamente por instru\u00e7\u00f5es SIMD ( Single Instruction Multiple Data ). Neste contexto, a utiliza\u00e7\u00e3o de compiladores com op\u00e7\u00e3o de autovetoriza\u00e7\u00e3o \u00e9 muito conveniente: se o c\u00f3digo compilado tiver algumas caracter\u00edsticas o compilador \u00e9 capaz utilizar estas instru\u00e7\u00f5es automaticamente e melhorar muito o desempenho sem que um programador precise modificar c\u00f3digo. Um guia para autovetoriza\u00e7\u00e3o usando gcc pode ser encontrado em sua documenta\u00e7\u00e3o . Info Os exerc\u00edcios de aula podem ser feitos em dupla.","title":"04 - SIMD: Autovetoriza\u00e7\u00e3o"},{"location":"aulas/04-autovec/#capacidade-dos-registradores","text":"Question Levando em conta que a arquitetura AVX armazena dados em registradores de 128 bits , podemos armazenar em um \u00fanico registrador at\u00e9: ____ chars; ____ shorts; ____ ints; ____ longs; ____ floats; ____ doubles; Question A arquitetura AVX2 suporta registradores de 256 bits . Isto significa que c\u00f3digo autovetorizado com instru\u00e7\u00f5es AVX2 pode ser at\u00e9 ____ vezes mais r\u00e1pido do que c\u00f3digo vetorizado com AVX Question Toda instru\u00e7\u00e3o SIMD opera sobre todos os elementos guardados ao mesmo tempo. Ou seja, ao executar uma instru\u00e7\u00e3o SIMD de soma de vari\u00e1veis int no registrador %xmm0 estarei somando ____ vari\u00e1veis em uma s\u00f3 instru\u00e7\u00e3o.","title":"Capacidade dos registradores"},{"location":"aulas/04-autovec/#instrucoes-vetoriais","text":"Vamos agora compilar alguns c\u00f3digos em C++ para Assembly usando as op\u00e7\u00f5es -ffast-math -ftree-vectorize -mavx do gcc . Estas op\u00e7\u00f5es habilitam a autovetoriza\u00e7\u00e3o de c\u00f3digo. Ou sejam elas analisam o c\u00f3digo e procuram substituir loops e acessos sequenciais a vetores por instru\u00e7\u00f5es SIMD que fa\u00e7am o mesmo trabalho. A flag -mavx indica que o c\u00f3digo de m\u00e1quina gerado pode utilizar instru\u00e7\u00f5es SIMD da arquitetura AVX (e de sua predecessora, SSE), que usa registradores de 128 bits nomeados %xmm0 at\u00e9 %xmm7 e de 256 bits nomeados %ymm0 at\u00e9 %ymm15 . Vamos agora analisar o c\u00f3digo Assembly de uma fun\u00e7\u00e3o simples que soma todos elementos de um vetor. // Original: Nicolas Brailovsky #define SIZE (400) long sum ( long v [ SIZE ]) { long * d = new long [ SIZE ]; long s = 0 ; // este exemplo eh didatico. soma de ints deveria ser long ;) for ( long i = 0 ; i < SIZE ; i ++ ) s += v [ i ]; return s ; } Example Compile este c\u00f3digo com otimiza\u00e7\u00f5es b\u00e1sicas ( -O2 ) $ g++ -S -c -O2 tarefa1.cpp -o /dev/stdout | c++filt Agora adicione autovetoriza\u00e7\u00e3o (com as flags listadas acima) $ g++ -S -c -O2 -ffast-math -ftree-vectorize -mavx tarefa1.cpp -o /dev/stdout | c++filt Question Compare as instru\u00e7\u00f5es Assembly geradas acima e escreva abaixo as diferen\u00e7as percebidas. Voc\u00ea consegue explicar seu funcionamento?","title":"Instru\u00e7\u00f5es vetoriais"},{"location":"aulas/04-autovec/#aplicando-autovetorizacao","text":"Nesta tarefa iremos trabalhar com as op\u00e7\u00f5es de autovetoriza\u00e7\u00e3o do gcc para entender como escrever c\u00f3digo que possa ser otimizado automaticamente. Example Escreva uma fun\u00e7\u00e3o main que gera um vetor de tamanho 10.000.000 contendo n\u00fameros aleat\u00f3rios uniformemente distribu\u00eddos entre -10 e 10 . Use as fun\u00e7\u00f5es do cabe\u00e7alho <random> . Example Escreva uma fun\u00e7\u00e3o double soma_positivos1(double *a, int n) que soma todos os n\u00fameros positivos do vetor a . Adicione uma chamada a esta fun\u00e7\u00e3o no seu main e use as fun\u00e7\u00f5es do cabe\u00e7alho <chrono> para medir o tempo de execu\u00e7\u00e3o da sua fun\u00e7\u00e3o. Neste exerc\u00edcio voc\u00ea dever\u00e1 usar um if para checar se os n\u00fameros s\u00e3o positivos. Question Compile com e sem as otimiza\u00e7\u00f5es SIMD e escreva abaixo os tempos de execu\u00e7\u00e3o. O auto vetorizador suporta uma s\u00e9rie de padr\u00f5es de codifica\u00e7\u00e3o relativamente abrangente ( lista completa ). Por\u00e9m, c\u00f3digos que s\u00e3o vetorizados de maneira id\u00eantica podem possuir desempenho bastante diferente quanto a vetoriza\u00e7\u00e3o n\u00e3o est\u00e1 habilitada. Example Fa\u00e7a uma fun\u00e7\u00e3o double soma_positivos2(double *a, int n) que faz o mesmo que a fun\u00e7\u00e3o anterior, mas usando agora o operador tern\u00e1rio (cond)?expr_true:expr_false ao inv\u00e9s de um if . (Se voc\u00ea fez com o operador tern\u00e1rio acima fa\u00e7a com if ). Houve diferen\u00e7a de desempenho na vers\u00e3o SIMD? E na vers\u00e3o sem SIMD? Question Complete a tabela abaixo com os tempos obtidos - SIMD sem SIMD if-else tern\u00e1rio Exerc\u00edcio Qual vers\u00e3o da fun\u00e7\u00e3o anterior voc\u00ea usaria se seu c\u00f3digo fosse executado em processadores de baixo custo (Intel Celeron) ou muito antigos (mais de 5 anos)? E se o plano for executar em processadores novos?","title":"Aplicando autovetoriza\u00e7\u00e3o"},{"location":"aulas/04-autovec/#projeto-0-aplicando-autovetorizacao","text":"Warning Os exerc\u00edcios do Projeto 0 s\u00e3o individuais. Nas \u00faltimas duas tarefas vimos como usar as op\u00e7\u00f5es do compilador para gerar instru\u00e7\u00f5es SIMD, tornando nossos programas mais eficientes. Agora vamos aplic\u00e1-las ao nosso exemplo dos experimentos. Voc\u00ea dever\u00e1 criar um novo target vector_ops_simd com as op\u00e7\u00f5es de compila\u00e7\u00e3o SIMD e a flag de otimiza\u00e7\u00e3o O3 atualizar seus gr\u00e1ficos de desempenho com o novo experimento comentar os novos resultados, respondendo \u00e0s seguintes perguntas: A partir de qual tamanho de array o c\u00f3digo vetorizado mostra ganhos de desempenho expressivos? Qual \u00e9 o ganho de desempenho esperado? Leve em conta a arquitetura usada e o tipo de dados usado. Os ganhos de desempenho s\u00e3o consistentes com o esperado?","title":"Projeto 0 - aplicando autovetoriza\u00e7\u00e3o"},{"location":"aulas/05-simd-intrinsics/","text":"05 - SIMD: Fun\u00e7\u00f5es Intr\u00ednsecas \u00b6 Como voc\u00ea j\u00e1 sabe, programar em Assembly n\u00e3o \u00e9 nada f\u00e1cil e os recursos de auto vetoriza\u00e7\u00e3o nem sempre funcionam da forma esperada. Podemos, por\u00e9m, chamar um conjunto especial de fun\u00e7\u00f5es que s\u00e3o compiladas diretamente para instru\u00e7\u00f5es vetoriais. Estas fun\u00e7\u00f5es s\u00e3o chamadas intr\u00ednsecas e nos permitem vetorizar c\u00f3digo que o autovetorizador n\u00e3o consegue acelerar. Um guia com todas as fun\u00e7\u00f5es intr\u00ednsecas dispon\u00edveis est\u00e1 dispon\u00edvel no site da Intel Exerc\u00edcio \u00b6 Leia o c\u00f3digo abaixo (arquivo avx-sub.c ), compile-o e rode. Ele apresenta o resultado esperado? #include <x86intrin.h> #include <stdio.h> int main () { /* Initialize the two argument vectors */ __m256 evens = _mm256_set_ps ( 2.0 , 4.0 , 6.0 , 8.0 , 10.0 , 12.0 , 14.0 , 16.0 ); __m256 odds = _mm256_set_ps ( 1.0 , 3.0 , 5.0 , 7.0 , 9.0 , 11.0 , 13.0 , 15.0 ); /* Compute the difference between the two vectors */ __m256 result = _mm256_sub_ps ( evens , odds ); /* Display the elements of the result vector */ float * f = ( float * ) & result ; printf ( \"%f %f %f %f %f %f %f %f \\n \" , f [ 0 ], f [ 1 ], f [ 2 ], f [ 3 ], f [ 4 ], f [ 5 ], f [ 6 ], f [ 7 ]); return 0 ; } Exerc\u00edcio \u00b6 Compile e execute o c\u00f3digo abaixo (arquivo avx-mask.c ). Voc\u00ea consegue explicar seu funcionamento? Mexa com os valores da m\u00e1scara e confirme suas hip\u00f3teses. #include <x86intrin.h> #include <stdio.h> int main () { float int_array [ 8 ] = { 100 , 200 , 300 , 400 , 500 , 600 , 700 , 800 }; /* Initialize the mask vector */ __m256i mask = _mm256_setr_epi32 ( - 20 , - 72 , - 48 , - 9 , - 100 , 3 , 5 , 8 ); /* Selectively load data into the vector */ __m256 result = _mm256_maskload_ps ( int_array , mask ); /* Display the elements of the result vector */ float * res = ( float * ) & result ; printf ( \"%f %f %f %f %f %f %f %f \\n \" , res [ 0 ], res [ 1 ], res [ 2 ], res [ 3 ], res [ 4 ], res [ 5 ], res [ 6 ], res [ 7 ]); return 0 ; } Exerc\u00edcio \u00b6 Complete o c\u00f3digo do arquivo avx-sqrt.cpp , criando uma vers\u00e3o vetorizada da fun\u00e7\u00e3o que calcula a raiz quadrada de forma linear. Anote abaixo os comando usados para habilitar, desabilitar e alinhar mem\u00f3ria para uso com as fun\u00e7\u00f5es intr\u00ednsecas. Exerc\u00edcio para entrega \u00b6 O exerc\u00edcio final desta atividade consiste em implementar a fun\u00e7\u00e3o soma_positivos usando fun\u00e7\u00f5es intr\u00ednsicas. Adicione esta implementa\u00e7\u00e3o aos seus experimentos e compare-a com a fun\u00e7\u00e3o soma_positivos compilada sem vetoriza\u00e7\u00e3o .","title":"05 - SIMD: Fun\u00e7\u00f5es Intr\u00ednsecas"},{"location":"aulas/05-simd-intrinsics/#05-simd-funcoes-intrinsecas","text":"Como voc\u00ea j\u00e1 sabe, programar em Assembly n\u00e3o \u00e9 nada f\u00e1cil e os recursos de auto vetoriza\u00e7\u00e3o nem sempre funcionam da forma esperada. Podemos, por\u00e9m, chamar um conjunto especial de fun\u00e7\u00f5es que s\u00e3o compiladas diretamente para instru\u00e7\u00f5es vetoriais. Estas fun\u00e7\u00f5es s\u00e3o chamadas intr\u00ednsecas e nos permitem vetorizar c\u00f3digo que o autovetorizador n\u00e3o consegue acelerar. Um guia com todas as fun\u00e7\u00f5es intr\u00ednsecas dispon\u00edveis est\u00e1 dispon\u00edvel no site da Intel","title":"05 - SIMD: Fun\u00e7\u00f5es Intr\u00ednsecas"},{"location":"aulas/05-simd-intrinsics/#exercicio","text":"Leia o c\u00f3digo abaixo (arquivo avx-sub.c ), compile-o e rode. Ele apresenta o resultado esperado? #include <x86intrin.h> #include <stdio.h> int main () { /* Initialize the two argument vectors */ __m256 evens = _mm256_set_ps ( 2.0 , 4.0 , 6.0 , 8.0 , 10.0 , 12.0 , 14.0 , 16.0 ); __m256 odds = _mm256_set_ps ( 1.0 , 3.0 , 5.0 , 7.0 , 9.0 , 11.0 , 13.0 , 15.0 ); /* Compute the difference between the two vectors */ __m256 result = _mm256_sub_ps ( evens , odds ); /* Display the elements of the result vector */ float * f = ( float * ) & result ; printf ( \"%f %f %f %f %f %f %f %f \\n \" , f [ 0 ], f [ 1 ], f [ 2 ], f [ 3 ], f [ 4 ], f [ 5 ], f [ 6 ], f [ 7 ]); return 0 ; }","title":"Exerc\u00edcio"},{"location":"aulas/05-simd-intrinsics/#exercicio_1","text":"Compile e execute o c\u00f3digo abaixo (arquivo avx-mask.c ). Voc\u00ea consegue explicar seu funcionamento? Mexa com os valores da m\u00e1scara e confirme suas hip\u00f3teses. #include <x86intrin.h> #include <stdio.h> int main () { float int_array [ 8 ] = { 100 , 200 , 300 , 400 , 500 , 600 , 700 , 800 }; /* Initialize the mask vector */ __m256i mask = _mm256_setr_epi32 ( - 20 , - 72 , - 48 , - 9 , - 100 , 3 , 5 , 8 ); /* Selectively load data into the vector */ __m256 result = _mm256_maskload_ps ( int_array , mask ); /* Display the elements of the result vector */ float * res = ( float * ) & result ; printf ( \"%f %f %f %f %f %f %f %f \\n \" , res [ 0 ], res [ 1 ], res [ 2 ], res [ 3 ], res [ 4 ], res [ 5 ], res [ 6 ], res [ 7 ]); return 0 ; }","title":"Exerc\u00edcio"},{"location":"aulas/05-simd-intrinsics/#exercicio_2","text":"Complete o c\u00f3digo do arquivo avx-sqrt.cpp , criando uma vers\u00e3o vetorizada da fun\u00e7\u00e3o que calcula a raiz quadrada de forma linear. Anote abaixo os comando usados para habilitar, desabilitar e alinhar mem\u00f3ria para uso com as fun\u00e7\u00f5es intr\u00ednsecas.","title":"Exerc\u00edcio"},{"location":"aulas/05-simd-intrinsics/#exercicio-para-entrega","text":"O exerc\u00edcio final desta atividade consiste em implementar a fun\u00e7\u00e3o soma_positivos usando fun\u00e7\u00f5es intr\u00ednsicas. Adicione esta implementa\u00e7\u00e3o aos seus experimentos e compare-a com a fun\u00e7\u00e3o soma_positivos compilada sem vetoriza\u00e7\u00e3o .","title":"Exerc\u00edcio para entrega"},{"location":"projetos/","text":"\u00cdndice de projetos \u00b6 A disciplina \u00e9 baseada em 4 projetos organizados em 5 entregas. Projeto 1 \u00b6 O projeto 0 consiste em atividades incrementais feitas em sala nas aula 01-05. Seu objetivo \u00e9 escrever programas b\u00e1sicos em C++; praticar o uso de conteiners da STL; cria\u00e7\u00e3o de projetos CMake; introduzir o processo de benchmarking. As atividades est\u00e3o descritas nas aulas 1-5 e o projeto deve ser entregue at\u00e9 28/02 . Projetos 2 a 4 \u00b6 Nestes tr\u00eas projetos resolveremos o mesmo problema usando diferentes t\u00e9cnicas de computa\u00e7\u00e3o paralela. Projeto 2 Parte 1: implementa\u00e7\u00e3o sequencial Parte 2: multi-core Projeto 3: GPGPU Projeto 4: computa\u00e7\u00e3o distribu\u00edda","title":"\u00cdndice"},{"location":"projetos/#indice-de-projetos","text":"A disciplina \u00e9 baseada em 4 projetos organizados em 5 entregas.","title":"\u00cdndice de projetos"},{"location":"projetos/#projeto-1","text":"O projeto 0 consiste em atividades incrementais feitas em sala nas aula 01-05. Seu objetivo \u00e9 escrever programas b\u00e1sicos em C++; praticar o uso de conteiners da STL; cria\u00e7\u00e3o de projetos CMake; introduzir o processo de benchmarking. As atividades est\u00e3o descritas nas aulas 1-5 e o projeto deve ser entregue at\u00e9 28/02 .","title":"Projeto 1"},{"location":"projetos/#projetos-2-a-4","text":"Nestes tr\u00eas projetos resolveremos o mesmo problema usando diferentes t\u00e9cnicas de computa\u00e7\u00e3o paralela. Projeto 2 Parte 1: implementa\u00e7\u00e3o sequencial Parte 2: multi-core Projeto 3: GPGPU Projeto 4: computa\u00e7\u00e3o distribu\u00edda","title":"Projetos 2 a 4"},{"location":"projetos/projeto-multi-core/","text":"Multi-core \u00b6 Neste semeste trabalharemos com um problema bastante familiar para os alunos do 8/9 semestre: a atribui\u00e7\u00e3o de alunos a projetos no Projeto Final de Engenharia. Cada aluno escolhe cinco op\u00e7\u00f5es de projetos de acordo com sua prefer\u00eancia. Cada projeto receber\u00e1 exatamente tr\u00eas alunos. Uma solu\u00e7\u00e3o para este problema \u00e9 uma atribui\u00e7\u00e3o de tr\u00eas alunos para cada projeto. Claramente algumas solu\u00e7\u00f5es s\u00e3o melhores pois maior quantidade de alunos est\u00e1 alocada em projetos que tem maior prefer\u00eancia. Para quantificar esta qualidade de cada solu\u00e7\u00e3o vamos adotar a seguinte estrat\u00e9gia: a satisfa\u00e7\u00e3o individual de um aluno, dada sua atribui\u00e7\u00e3o a um projeto \u00e9 5^2 = 25 5^2 = 25 se foi colocado em sua primeira op\u00e7\u00e3o .... 2^2 = 4 2^2 = 4 se foi colocado em sua quarta op\u00e7\u00e3o 1 1 se foi colocado em sua \u00faltima op\u00e7\u00e3o 0 0 se n\u00e3o foi poss\u00edvel coloc\u00e1-lo em nenhuma de suas op\u00e7\u00f5es. a satisfa\u00e7\u00e3o \"global\" de uma solu\u00e7\u00e3o \u00e9 a soma da satisfa\u00e7\u00e3o individual de todos alunos. Desta maneira, gostar\u00edamos de encontrar a melhor solu\u00e7\u00e3o (a que possui maior satisfa\u00e7\u00e3o global) dados o n\u00famero de alunos, o n\u00famero de projetos e at\u00e9 5 op\u00e7\u00f5es de projetos em ordem de prefer\u00eancia para cada aluno. Justificativa \u00b6 Apesar de parecer simples, este problema \u00e9 NP-completo : n\u00e3o existe um m\u00e9todo que encontra a solu\u00e7\u00e3o com maior satisfa\u00e7\u00e3o global em tempo polinomial. Al\u00e9m disso, n\u00e3o existe uma maneira que verifique se uma solu\u00e7\u00e3o \u00e9 a melhor poss\u00edvel em tempo polinomial. Ou seja, trabalhar com este problema invariavelmente envolver\u00e1 enumerar todas as possibilidades. Claramente este \u00e9 um problema em que SuperComputa\u00e7\u00e3o \u00e9 necess\u00e1ria! Veremos que t\u00e9cnicas de computa\u00e7\u00e3o paralela podem diminuir consideravelmente o tempo de execu\u00e7\u00e3o de nosso programa. Outra fonte de ideias para acelerar a resolu\u00e7\u00e3o deste problema \u00e9 a utiliza\u00e7\u00e3o de t\u00e9cnicas de otimiza\u00e7\u00e3o discreta, que s\u00e3o nada mais do que explorar alguma caracter\u00edstica do problema que estamos tratando para melhorar nossas solu\u00e7\u00f5es. Podemos us\u00e1-las para encontrar boas solu\u00e7\u00f5es sem enumerar todas ou para evitar enumerar solu\u00e7\u00f5es que com certeza n\u00e3o s\u00e3o as \u00f3timas. Por\u00e9m, nem sempre \u00e9 f\u00e1cil paralelizar estas t\u00e9cnicas e este ser\u00e1 um dos desafios dos conceitos mais avan\u00e7ados neste projeto. Em resumo, este projeto tem como objetivo encontrar as seguintes situa\u00e7\u00f5es: paralelizar um programa que use uma t\u00e9cnica de resolu\u00e7\u00e3o ruim n\u00e3o resultar\u00e1 em grandes ganhos de tempo paralelizar um programa que use uma t\u00e9cnica de resolu\u00e7\u00e3o inteligente pode ser dif\u00edcil, mas retorna ganhos muito mais significativos \u00c9 prov\u00e1vel vermos um programa single-core inteligente sendo mais r\u00e1pido que um programa multi-core simpl\u00f3rio. Entrada e sa\u00edda \u00b6 O formato de entrada do programa estar\u00e1 no formato abaixo. n_alunos n_projetos p1 p2 p3 p4 p5 ..... # repetido n_alunos vezes n_alunos \u00e9 o n\u00famero de alunos n_projetos \u00e9 o n\u00famero de projetos existentes cada linha seguinte representa as cinco prioridades de um aluno. p1, ..., p5 \u00e9 um n\u00famero entre 0 e n_projetos-1 , sem repeti\u00e7\u00f5es A sa\u00edda do programa dever\u00e1 estar no formato abaixo. satisfacao opt pa1 pa2 pa3 ... pa(n_alunos) satisfacao opt \u00e9 1 se a solu\u00e7\u00e3o encontrada \u00e9 a melhor poss\u00edvel, 0 caso contr\u00e1rio pa(i) cont\u00e9m a qual projeto o aluno i foi atribu\u00eddo A pasta code/projeto cont\u00e9m exemplos de entradas e sa\u00edda esperadas. Seu programa dever\u00e1 funcionar com estas entradas e produzir sa\u00eddas exatamente neste formato. Avisos Se existirem duas solu\u00e7\u00f5es com mesma satisfa\u00e7\u00e3o qualquer uma pode ser retornada. Informa\u00e7\u00f5es de debug devem ser enviadas para a sa\u00edda de erros. Simplifica\u00e7\u00f5es: \u00b6 Seu programa pode assumir o seguinte: n_alunos \u00e9 divis\u00edvel por 3 n_projetos \u00e9 exatamente n_alunos/3 Isto facilita muito o problema, pois nunca conseguimos montar uma solu\u00e7\u00e3o inv\u00e1lida nem precisamos levar em conta a distribui\u00e7\u00e3o de alunos ao criar solu\u00e7\u00f5es. Entregas \u00b6 Para facilitar a realiza\u00e7\u00e3o deste projeto ele ser\u00e1 dividido em duas partes. A primeira parte focar\u00e1 em criar uma solu\u00e7\u00e3o que resolve este problema este C++ e compar\u00e1-la com uma solu\u00e7\u00e3o inocente em Python. Isto inclui estudar m\u00e9todos de resolu\u00e7\u00e3o do problema e implement\u00e1-los em C++. A segunda parte tratar\u00e1 da paraleliza\u00e7\u00e3o destes m\u00e9todos usando as t\u00e9cnicas mostradas em sala de aula. Parte 1: estrat\u00e9gias de resolu\u00e7\u00e3o \u00b6 O arquivo solucao-ingenua.py cont\u00e9m uma solu\u00e7\u00e3o simplista escrita em Python. Este programa sempre encontra a melhor solu\u00e7\u00e3o, mas \u00e9 extremamente ing\u00eanuo . Por isso, ele tamb\u00e9m \u00e9 extremamente lento . Implementa\u00e7\u00e3o em C++ : Nosso primeiro passo ser\u00e1 implementar esse mesmo programa em C++. O objetivo desta parte ser\u00e1 Busca local : A estrat\u00e9gia de busca local visa encontrar boas solu\u00e7\u00f5es em um processo de melhora iterativa. A partir de uma solu\u00e7\u00e3o inicial (que pode ser aleat\u00f3ria), tentamos aplicar uma heur\u00edstica (truque) que pode melhorar a solu\u00e7\u00e3o (mas nunca piorar). Note que isto somente garante que a solu\u00e7\u00e3o ir\u00e1 melhorar iterativamente, por\u00e9m n\u00e3o garante que eventualmente chegaremos na melhor solu\u00e7\u00e3o poss\u00edvel. Al\u00e9m dissto, a solu\u00e7\u00e3o encontrada muda conforme a solu\u00e7\u00e3o inicial nem todas as solu\u00e7\u00f5es s\u00e3o poss\u00edveis de serem encontradas. Uma boa heur\u00edstica geralmente \u00e9 baseada em alguma caracter\u00edstica da solu\u00e7\u00e3o \u00f3tima. Para este problema usaremos a seguinte propriedade n\u00e3o existe nenhuma dupla de alunos que, se for trocada de projeto, melhora a satisfa\u00e7\u00e3o global. Claramente se a solu\u00e7\u00e3o \u00e9 a melhor poss\u00edvel ent\u00e3o isto n\u00e3o pode acontecer. Nosso algoritmo ser\u00e1 escolha uma atribui\u00e7\u00e3o aluno-projeto v\u00e1lida aleatoriamente verifique se existe um par de alunos cuja troca de projeto melhore a satisfa\u00e7\u00e3o global se existir fa\u00e7a a troca e repita o teste acima se n\u00e3o existir retorne a solu\u00e7\u00e3o atual A implementa\u00e7\u00e3o deste algoritmo resulta em um programa que encontra solu\u00e7\u00f5es razo\u00e1veis muito rapidamente. Branch and Bound : lkasdjaslkjkl Heur\u00edsticas de busca : Parte 2: Paralelismo \u00b6 A parte 2 ser\u00e1 liberada ap\u00f3s a entega da parte 1. Avalia\u00e7\u00e3o \u00b6","title":"Multi-core"},{"location":"projetos/projeto-multi-core/#multi-core","text":"Neste semeste trabalharemos com um problema bastante familiar para os alunos do 8/9 semestre: a atribui\u00e7\u00e3o de alunos a projetos no Projeto Final de Engenharia. Cada aluno escolhe cinco op\u00e7\u00f5es de projetos de acordo com sua prefer\u00eancia. Cada projeto receber\u00e1 exatamente tr\u00eas alunos. Uma solu\u00e7\u00e3o para este problema \u00e9 uma atribui\u00e7\u00e3o de tr\u00eas alunos para cada projeto. Claramente algumas solu\u00e7\u00f5es s\u00e3o melhores pois maior quantidade de alunos est\u00e1 alocada em projetos que tem maior prefer\u00eancia. Para quantificar esta qualidade de cada solu\u00e7\u00e3o vamos adotar a seguinte estrat\u00e9gia: a satisfa\u00e7\u00e3o individual de um aluno, dada sua atribui\u00e7\u00e3o a um projeto \u00e9 5^2 = 25 5^2 = 25 se foi colocado em sua primeira op\u00e7\u00e3o .... 2^2 = 4 2^2 = 4 se foi colocado em sua quarta op\u00e7\u00e3o 1 1 se foi colocado em sua \u00faltima op\u00e7\u00e3o 0 0 se n\u00e3o foi poss\u00edvel coloc\u00e1-lo em nenhuma de suas op\u00e7\u00f5es. a satisfa\u00e7\u00e3o \"global\" de uma solu\u00e7\u00e3o \u00e9 a soma da satisfa\u00e7\u00e3o individual de todos alunos. Desta maneira, gostar\u00edamos de encontrar a melhor solu\u00e7\u00e3o (a que possui maior satisfa\u00e7\u00e3o global) dados o n\u00famero de alunos, o n\u00famero de projetos e at\u00e9 5 op\u00e7\u00f5es de projetos em ordem de prefer\u00eancia para cada aluno.","title":"Multi-core"},{"location":"projetos/projeto-multi-core/#justificativa","text":"Apesar de parecer simples, este problema \u00e9 NP-completo : n\u00e3o existe um m\u00e9todo que encontra a solu\u00e7\u00e3o com maior satisfa\u00e7\u00e3o global em tempo polinomial. Al\u00e9m disso, n\u00e3o existe uma maneira que verifique se uma solu\u00e7\u00e3o \u00e9 a melhor poss\u00edvel em tempo polinomial. Ou seja, trabalhar com este problema invariavelmente envolver\u00e1 enumerar todas as possibilidades. Claramente este \u00e9 um problema em que SuperComputa\u00e7\u00e3o \u00e9 necess\u00e1ria! Veremos que t\u00e9cnicas de computa\u00e7\u00e3o paralela podem diminuir consideravelmente o tempo de execu\u00e7\u00e3o de nosso programa. Outra fonte de ideias para acelerar a resolu\u00e7\u00e3o deste problema \u00e9 a utiliza\u00e7\u00e3o de t\u00e9cnicas de otimiza\u00e7\u00e3o discreta, que s\u00e3o nada mais do que explorar alguma caracter\u00edstica do problema que estamos tratando para melhorar nossas solu\u00e7\u00f5es. Podemos us\u00e1-las para encontrar boas solu\u00e7\u00f5es sem enumerar todas ou para evitar enumerar solu\u00e7\u00f5es que com certeza n\u00e3o s\u00e3o as \u00f3timas. Por\u00e9m, nem sempre \u00e9 f\u00e1cil paralelizar estas t\u00e9cnicas e este ser\u00e1 um dos desafios dos conceitos mais avan\u00e7ados neste projeto. Em resumo, este projeto tem como objetivo encontrar as seguintes situa\u00e7\u00f5es: paralelizar um programa que use uma t\u00e9cnica de resolu\u00e7\u00e3o ruim n\u00e3o resultar\u00e1 em grandes ganhos de tempo paralelizar um programa que use uma t\u00e9cnica de resolu\u00e7\u00e3o inteligente pode ser dif\u00edcil, mas retorna ganhos muito mais significativos \u00c9 prov\u00e1vel vermos um programa single-core inteligente sendo mais r\u00e1pido que um programa multi-core simpl\u00f3rio.","title":"Justificativa"},{"location":"projetos/projeto-multi-core/#entrada-e-saida","text":"O formato de entrada do programa estar\u00e1 no formato abaixo. n_alunos n_projetos p1 p2 p3 p4 p5 ..... # repetido n_alunos vezes n_alunos \u00e9 o n\u00famero de alunos n_projetos \u00e9 o n\u00famero de projetos existentes cada linha seguinte representa as cinco prioridades de um aluno. p1, ..., p5 \u00e9 um n\u00famero entre 0 e n_projetos-1 , sem repeti\u00e7\u00f5es A sa\u00edda do programa dever\u00e1 estar no formato abaixo. satisfacao opt pa1 pa2 pa3 ... pa(n_alunos) satisfacao opt \u00e9 1 se a solu\u00e7\u00e3o encontrada \u00e9 a melhor poss\u00edvel, 0 caso contr\u00e1rio pa(i) cont\u00e9m a qual projeto o aluno i foi atribu\u00eddo A pasta code/projeto cont\u00e9m exemplos de entradas e sa\u00edda esperadas. Seu programa dever\u00e1 funcionar com estas entradas e produzir sa\u00eddas exatamente neste formato. Avisos Se existirem duas solu\u00e7\u00f5es com mesma satisfa\u00e7\u00e3o qualquer uma pode ser retornada. Informa\u00e7\u00f5es de debug devem ser enviadas para a sa\u00edda de erros.","title":"Entrada e sa\u00edda"},{"location":"projetos/projeto-multi-core/#simplificacoes","text":"Seu programa pode assumir o seguinte: n_alunos \u00e9 divis\u00edvel por 3 n_projetos \u00e9 exatamente n_alunos/3 Isto facilita muito o problema, pois nunca conseguimos montar uma solu\u00e7\u00e3o inv\u00e1lida nem precisamos levar em conta a distribui\u00e7\u00e3o de alunos ao criar solu\u00e7\u00f5es.","title":"Simplifica\u00e7\u00f5es:"},{"location":"projetos/projeto-multi-core/#entregas","text":"Para facilitar a realiza\u00e7\u00e3o deste projeto ele ser\u00e1 dividido em duas partes. A primeira parte focar\u00e1 em criar uma solu\u00e7\u00e3o que resolve este problema este C++ e compar\u00e1-la com uma solu\u00e7\u00e3o inocente em Python. Isto inclui estudar m\u00e9todos de resolu\u00e7\u00e3o do problema e implement\u00e1-los em C++. A segunda parte tratar\u00e1 da paraleliza\u00e7\u00e3o destes m\u00e9todos usando as t\u00e9cnicas mostradas em sala de aula.","title":"Entregas"},{"location":"projetos/projeto-multi-core/#parte-1-estrategias-de-resolucao","text":"O arquivo solucao-ingenua.py cont\u00e9m uma solu\u00e7\u00e3o simplista escrita em Python. Este programa sempre encontra a melhor solu\u00e7\u00e3o, mas \u00e9 extremamente ing\u00eanuo . Por isso, ele tamb\u00e9m \u00e9 extremamente lento . Implementa\u00e7\u00e3o em C++ : Nosso primeiro passo ser\u00e1 implementar esse mesmo programa em C++. O objetivo desta parte ser\u00e1 Busca local : A estrat\u00e9gia de busca local visa encontrar boas solu\u00e7\u00f5es em um processo de melhora iterativa. A partir de uma solu\u00e7\u00e3o inicial (que pode ser aleat\u00f3ria), tentamos aplicar uma heur\u00edstica (truque) que pode melhorar a solu\u00e7\u00e3o (mas nunca piorar). Note que isto somente garante que a solu\u00e7\u00e3o ir\u00e1 melhorar iterativamente, por\u00e9m n\u00e3o garante que eventualmente chegaremos na melhor solu\u00e7\u00e3o poss\u00edvel. Al\u00e9m dissto, a solu\u00e7\u00e3o encontrada muda conforme a solu\u00e7\u00e3o inicial nem todas as solu\u00e7\u00f5es s\u00e3o poss\u00edveis de serem encontradas. Uma boa heur\u00edstica geralmente \u00e9 baseada em alguma caracter\u00edstica da solu\u00e7\u00e3o \u00f3tima. Para este problema usaremos a seguinte propriedade n\u00e3o existe nenhuma dupla de alunos que, se for trocada de projeto, melhora a satisfa\u00e7\u00e3o global. Claramente se a solu\u00e7\u00e3o \u00e9 a melhor poss\u00edvel ent\u00e3o isto n\u00e3o pode acontecer. Nosso algoritmo ser\u00e1 escolha uma atribui\u00e7\u00e3o aluno-projeto v\u00e1lida aleatoriamente verifique se existe um par de alunos cuja troca de projeto melhore a satisfa\u00e7\u00e3o global se existir fa\u00e7a a troca e repita o teste acima se n\u00e3o existir retorne a solu\u00e7\u00e3o atual A implementa\u00e7\u00e3o deste algoritmo resulta em um programa que encontra solu\u00e7\u00f5es razo\u00e1veis muito rapidamente. Branch and Bound : lkasdjaslkjkl Heur\u00edsticas de busca :","title":"Parte 1: estrat\u00e9gias de resolu\u00e7\u00e3o"},{"location":"projetos/projeto-multi-core/#parte-2-paralelismo","text":"A parte 2 ser\u00e1 liberada ap\u00f3s a entega da parte 1.","title":"Parte 2: Paralelismo"},{"location":"projetos/projeto-multi-core/#avaliacao","text":"","title":"Avalia\u00e7\u00e3o"}]}