{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SuperComputa\u00e7\u00e3o \u00b6 Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2021/2. Professor : Andr\u00e9 Filipe M. Batista Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; O projeto da disciplina ser\u00e1 composto por m\u00faltiplas partes. Mais detalhes na p\u00e1gina de projetos A m\u00e9dia final \u00e9 dada por 55% Projeto 45% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Projeto >= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados) Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Home"},{"location":"#supercomputacao","text":"Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2021/2. Professor : Andr\u00e9 Filipe M. Batista","title":"SuperComputa\u00e7\u00e3o"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; O projeto da disciplina ser\u00e1 composto por m\u00faltiplas partes. Mais detalhes na p\u00e1gina de projetos A m\u00e9dia final \u00e9 dada por 55% Projeto 45% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Projeto >= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados) Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Avalia\u00e7\u00e3o"},{"location":"sobre/","text":"Burocracias \u00b6 Hor\u00e1rios: QUA - 13:30 SEX - 07:30 Atendimento SEX - 09:30 Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 18/08/21 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++ 20/08/21 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Implementa\u00e7\u00e3o de algoritmos simples; Passagem de argumentos por refer\u00eancia e valor; Recursos de C++ 25/08/21 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho C++, Vectors 27/08/21 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa 01/09/21 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dif\u00edceis Apresenta\u00e7\u00e3o do projeto da disciplina; Heur\u00edstica, busca local e global 03/09/21 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades da solu\u00e7\u00e3o \u00f3tima; vizinhan\u00e7a de solu\u00e7\u00f5es 08/09/21 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 10/09/21 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 15/09/21 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho 17/09/21 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa 22/09/21 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edvies al\u00e9m do branch-and-bound 24/09/21 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 29/09/21 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 01/10/21 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 06/10/21 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 13/10/21 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP 15/10/21 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safe e reentr\u00e2ncia 20/10/21 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 22/10/21 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 27/10/21 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 29/10/21 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 03/11/21 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 05/11/21 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 10/11/21 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 12/11/21 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 17/11/21 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 19/11/21 Quiz para a PF Quiz para a PF 24/11/21 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 26/11/21 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 01/12/21 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 03/12/21 Prova Final Prova Final 08/12/21 Prova Final Prova Final","title":"Burocracias"},{"location":"sobre/#burocracias","text":"Hor\u00e1rios: QUA - 13:30 SEX - 07:30 Atendimento SEX - 09:30 Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 18/08/21 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++ 20/08/21 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Implementa\u00e7\u00e3o de algoritmos simples; Passagem de argumentos por refer\u00eancia e valor; Recursos de C++ 25/08/21 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho C++, Vectors 27/08/21 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa 01/09/21 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dif\u00edceis Apresenta\u00e7\u00e3o do projeto da disciplina; Heur\u00edstica, busca local e global 03/09/21 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades da solu\u00e7\u00e3o \u00f3tima; vizinhan\u00e7a de solu\u00e7\u00f5es 08/09/21 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 10/09/21 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 15/09/21 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho 17/09/21 Acelerando a busca local Estimando a qualidade de uma solu\u00e7\u00e3o parcial; Medindo a efetividade de uma estimativa 22/09/21 Indo al\u00e9m: best-first search, simetrias, competi\u00e7\u00e3o de desempenho Aula expositiva sobre melhorias poss\u00edvies al\u00e9m do branch-and-bound 24/09/21 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 29/09/21 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 01/10/21 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 06/10/21 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 13/10/21 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP 15/10/21 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safe e reentr\u00e2ncia 20/10/21 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 22/10/21 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 27/10/21 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 29/10/21 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 03/11/21 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 05/11/21 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 10/11/21 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 12/11/21 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 17/11/21 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 19/11/21 Quiz para a PF Quiz para a PF 24/11/21 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 26/11/21 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 01/12/21 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 03/12/21 Prova Final Prova Final 08/12/21 Prova Final Prova Final","title":"Burocracias"},{"location":"aulas/01-introducao/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); 01 - Introdu\u00e7\u00e3o a SuperComputa\u00e7\u00e3o \u00b6 Como vimos na expositiva, uma solu\u00e7\u00e3o de alto desempenho depende de tr\u00eas partes: algoritmos eficientes implementa\u00e7\u00f5es eficientes paralelismo Na atividade de hoje vamos estudar o primeiro ponto e quantificar o efeito de algoritmos eficientes na resolu\u00e7\u00e3o de um problema complexo. Problemas estudados em SuperComputa\u00e7\u00e3o \u00b6 Em Desafios de Programa\u00e7\u00e3o conhecemos a classe dos problemas NP-completo, que s\u00e3o aqueles que acreditamos n\u00e3o existir nenhum algoritmo determin\u00edstico que os resolvem em tempo polinomial. Ou seja, s\u00e3o problemas importantes cuja solu\u00e7\u00e3o \u00e9 dif\u00edcil. Em geral temos classes de algoritmos para resolv\u00ea-los: \u00f3timos globais: algoritmo que encontra a solu\u00e7\u00e3o \"correta\" do problema. \u00f3timos locais: algoritmo que encontra uma solu\u00e7\u00e3o \"boa\" e que n\u00e3o pode ser melhorada por pequenas modifica\u00e7\u00f5es. aproxima\u00e7\u00e3o: algoritmos que garantem estar \"perto o suficiente\" da solu\u00e7\u00e3o \u00f3tima. Este tipo de algoritmo n\u00e3o nos interessa em SuperComputa\u00e7\u00e3o. Iremos analisar hoje 4 execut\u00e1veis que resolvem o problema do Caixeiro Viajante . busca-local-1 - implementa\u00e7\u00e3o de um m\u00e9todo de busca r\u00e1pida, por\u00e9m n\u00e3o \u00f3tima. busca-local-1-par - implementa\u00e7\u00e3o paralela do programa acima. busca-local-2 - implementa\u00e7\u00e3o alternativa do mesmo m\u00e9todo acima. Os resultados de ambos s\u00e3o id\u00eanticos. busca-local-2-par - implementa\u00e7\u00e3o paralela do programa acima. Important N\u00e3o estamos interessados no Caixeiro Viajante em si hoje. Queremos \u00e9 comparar diferentes maneiras de resolv\u00ea-lo para entendermos o papel de t\u00e9cnicas de SuperComputa\u00e7\u00e3o na velocidade de processamento e nos resultados obtidos. Ferramental \u00b6 Realizar testes de maneira automatizada \u00e9 muito importante para quantificar os efeitos de diferentes algoritmos e t\u00e9cnicas de paralelismo. O snippet abaixo executa import subprocess import time with open ( 'entradas-busca-local/in-0.txt' ) as f : start = time . perf_counter () proc = subprocess . run ([ './busca-local-1' ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () print ( 'Sa\u00edda:' , proc . stdout ) print ( 'Stderr:' , proc . stderr ) print ( 'Tempo total(s):' , end - start ) Vamos agora praticar usar este snippet para executar nossos testes automaticamente. Example Crie uma fun\u00e7\u00e3o roda_com_entrada(executavel, arquivo_in) que roda o primeiro argumento usando como entrada o conte\u00fado do segundo argumento. Teste seu c\u00f3digo com o execut\u00e1vel busca-local-1 e com o arquivo de entrada in-0.txt usado no exemplo acima. Sua fun\u00e7\u00e3o dever\u00e1 devolver uma tupla (stdout,time) com stdout sendo a sa\u00edda do programa e time seu tempo de execu\u00e7\u00e3o em segundos. # TODO: exerc\u00edcio aqui Algoritmos sequenciais \u00b6 Com esse c\u00f3digo, vamos criar um relat\u00f3rio interativo que roda nossos testes automaticamente e j\u00e1 plota informa\u00e7\u00f5es prontas para nossas an\u00e1lises. Vamos come\u00e7ar examinando o desempenho do execut\u00e1vel busca-local-1 . Example Rode o busca-local com os arquivos de entrada na pasta entradas-busca-local . Guarde os tempos em uma lista. Example Leia o tamanho das entradas dos arquivos na pasta entradas-busca-local e guarde em uma segunda lista. Example Plote o tempo de execu\u00e7\u00e3o pelo tamanho da entrada usando matplotlib # TODO: exerc\u00edcio aqui Example Repita os tr\u00eas passos acima para o execut\u00e1vel busca-local-2 . Finalize plotando os tempos de execu\u00e7\u00e3o de ambos os execut\u00e1veis no mesmo gr\u00e1fico. #TODO: seu c\u00f3digo aqui Example Segundo uma coleta de dados informal e altamente confi\u00e1vel, 93,17% dos alunos n\u00e3o colocam legendas nem t\u00edtulos nos gr\u00e1ficos gerados. Fa\u00e7a isso agora. Question Interprete o gr\u00e1fico que voc\u00ea gerou na linha de cima. Question Compare manualmente a sa\u00edda dos programas. Existe diferen\u00e7a em seus resultados? Question Resgate seus conhecimentos de Desafios de Programa\u00e7\u00e3o e explique a diferen\u00e7a entre os algoritmos. Algoritmos paralelos \u00b6 Na discuss\u00e3o inicial da expositiva chegamos \u00e0 conclus\u00e3o de que se conseguimos realizar N opera\u00e7\u00f5es em paralelo teremos um ganho de no m\u00e1ximo N vezes no desempenho de nosso programa. Nesta parte iremos estudar esta afirma\u00e7\u00e3o usando implementa\u00e7\u00f5es paralelas dos algoritmos da se\u00e7\u00e3o anterior. Example Execute os algoritmos paralelos com as mesmas entradas e compare com suas vers\u00f5es paralelas. Use um gr\u00e1fico para facilitar as compara\u00e7\u00f5es Question Compare os tempos obtidos. Qual foi o ganho m\u00e9dio? Quantos n\u00facleos a m\u00e1quina que voc\u00ea est\u00e1 usando possui? Responda comparando cada algoritmo sequencial com sua vers\u00e3o paralela. J\u00e1 estabelecemos que busca-local-2 \u00e9 melhor que busca-local-1 por ser utilizar um algoritmo mais eficiente e vimos na pr\u00e1tica a diferen\u00e7a entre um algoritmo O(n^3) O(n^3) e um algoritmo O(n^2) O(n^2) . Vamos agora examinar a seguinte quest\u00e3o. \u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2 ? Example Compare o desempenho de busca-local-1-par com busca-local-2 . Fa\u00e7a um gr\u00e1fico Question Com base em seu gr\u00e1fico acima, responda a pergunta: \"\u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2?\" Vamos agora generalizar a pergunta: Question Dados dois algoritmos com complexidades computacionais diferentes, sendo que o primeiro \u00e9 inferior ao segundo. \u00c9 poss\u00edvel usar paralelismo para tornar o primeiro mais r\u00e1pido que o segundo para todos tamanhos de entrada? Assuma que voc\u00ea possui um n\u00famero fixo de n\u00facleos .","title":"01 - Introdu\u00e7\u00e3o"},{"location":"aulas/01-introducao/#01-introducao-a-supercomputacao","text":"Como vimos na expositiva, uma solu\u00e7\u00e3o de alto desempenho depende de tr\u00eas partes: algoritmos eficientes implementa\u00e7\u00f5es eficientes paralelismo Na atividade de hoje vamos estudar o primeiro ponto e quantificar o efeito de algoritmos eficientes na resolu\u00e7\u00e3o de um problema complexo.","title":"01 - Introdu\u00e7\u00e3o a SuperComputa\u00e7\u00e3o"},{"location":"aulas/01-introducao/#problemas-estudados-em-supercomputacao","text":"Em Desafios de Programa\u00e7\u00e3o conhecemos a classe dos problemas NP-completo, que s\u00e3o aqueles que acreditamos n\u00e3o existir nenhum algoritmo determin\u00edstico que os resolvem em tempo polinomial. Ou seja, s\u00e3o problemas importantes cuja solu\u00e7\u00e3o \u00e9 dif\u00edcil. Em geral temos classes de algoritmos para resolv\u00ea-los: \u00f3timos globais: algoritmo que encontra a solu\u00e7\u00e3o \"correta\" do problema. \u00f3timos locais: algoritmo que encontra uma solu\u00e7\u00e3o \"boa\" e que n\u00e3o pode ser melhorada por pequenas modifica\u00e7\u00f5es. aproxima\u00e7\u00e3o: algoritmos que garantem estar \"perto o suficiente\" da solu\u00e7\u00e3o \u00f3tima. Este tipo de algoritmo n\u00e3o nos interessa em SuperComputa\u00e7\u00e3o. Iremos analisar hoje 4 execut\u00e1veis que resolvem o problema do Caixeiro Viajante . busca-local-1 - implementa\u00e7\u00e3o de um m\u00e9todo de busca r\u00e1pida, por\u00e9m n\u00e3o \u00f3tima. busca-local-1-par - implementa\u00e7\u00e3o paralela do programa acima. busca-local-2 - implementa\u00e7\u00e3o alternativa do mesmo m\u00e9todo acima. Os resultados de ambos s\u00e3o id\u00eanticos. busca-local-2-par - implementa\u00e7\u00e3o paralela do programa acima. Important N\u00e3o estamos interessados no Caixeiro Viajante em si hoje. Queremos \u00e9 comparar diferentes maneiras de resolv\u00ea-lo para entendermos o papel de t\u00e9cnicas de SuperComputa\u00e7\u00e3o na velocidade de processamento e nos resultados obtidos.","title":"Problemas estudados em SuperComputa\u00e7\u00e3o"},{"location":"aulas/01-introducao/#ferramental","text":"Realizar testes de maneira automatizada \u00e9 muito importante para quantificar os efeitos de diferentes algoritmos e t\u00e9cnicas de paralelismo. O snippet abaixo executa import subprocess import time with open ( 'entradas-busca-local/in-0.txt' ) as f : start = time . perf_counter () proc = subprocess . run ([ './busca-local-1' ], input = f . read (), text = True , capture_output = True ) end = time . perf_counter () print ( 'Sa\u00edda:' , proc . stdout ) print ( 'Stderr:' , proc . stderr ) print ( 'Tempo total(s):' , end - start ) Vamos agora praticar usar este snippet para executar nossos testes automaticamente. Example Crie uma fun\u00e7\u00e3o roda_com_entrada(executavel, arquivo_in) que roda o primeiro argumento usando como entrada o conte\u00fado do segundo argumento. Teste seu c\u00f3digo com o execut\u00e1vel busca-local-1 e com o arquivo de entrada in-0.txt usado no exemplo acima. Sua fun\u00e7\u00e3o dever\u00e1 devolver uma tupla (stdout,time) com stdout sendo a sa\u00edda do programa e time seu tempo de execu\u00e7\u00e3o em segundos. # TODO: exerc\u00edcio aqui","title":"Ferramental"},{"location":"aulas/01-introducao/#algoritmos-sequenciais","text":"Com esse c\u00f3digo, vamos criar um relat\u00f3rio interativo que roda nossos testes automaticamente e j\u00e1 plota informa\u00e7\u00f5es prontas para nossas an\u00e1lises. Vamos come\u00e7ar examinando o desempenho do execut\u00e1vel busca-local-1 . Example Rode o busca-local com os arquivos de entrada na pasta entradas-busca-local . Guarde os tempos em uma lista. Example Leia o tamanho das entradas dos arquivos na pasta entradas-busca-local e guarde em uma segunda lista. Example Plote o tempo de execu\u00e7\u00e3o pelo tamanho da entrada usando matplotlib # TODO: exerc\u00edcio aqui Example Repita os tr\u00eas passos acima para o execut\u00e1vel busca-local-2 . Finalize plotando os tempos de execu\u00e7\u00e3o de ambos os execut\u00e1veis no mesmo gr\u00e1fico. #TODO: seu c\u00f3digo aqui Example Segundo uma coleta de dados informal e altamente confi\u00e1vel, 93,17% dos alunos n\u00e3o colocam legendas nem t\u00edtulos nos gr\u00e1ficos gerados. Fa\u00e7a isso agora. Question Interprete o gr\u00e1fico que voc\u00ea gerou na linha de cima. Question Compare manualmente a sa\u00edda dos programas. Existe diferen\u00e7a em seus resultados? Question Resgate seus conhecimentos de Desafios de Programa\u00e7\u00e3o e explique a diferen\u00e7a entre os algoritmos.","title":"Algoritmos sequenciais"},{"location":"aulas/01-introducao/#algoritmos-paralelos","text":"Na discuss\u00e3o inicial da expositiva chegamos \u00e0 conclus\u00e3o de que se conseguimos realizar N opera\u00e7\u00f5es em paralelo teremos um ganho de no m\u00e1ximo N vezes no desempenho de nosso programa. Nesta parte iremos estudar esta afirma\u00e7\u00e3o usando implementa\u00e7\u00f5es paralelas dos algoritmos da se\u00e7\u00e3o anterior. Example Execute os algoritmos paralelos com as mesmas entradas e compare com suas vers\u00f5es paralelas. Use um gr\u00e1fico para facilitar as compara\u00e7\u00f5es Question Compare os tempos obtidos. Qual foi o ganho m\u00e9dio? Quantos n\u00facleos a m\u00e1quina que voc\u00ea est\u00e1 usando possui? Responda comparando cada algoritmo sequencial com sua vers\u00e3o paralela. J\u00e1 estabelecemos que busca-local-2 \u00e9 melhor que busca-local-1 por ser utilizar um algoritmo mais eficiente e vimos na pr\u00e1tica a diferen\u00e7a entre um algoritmo O(n^3) O(n^3) e um algoritmo O(n^2) O(n^2) . Vamos agora examinar a seguinte quest\u00e3o. \u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2 ? Example Compare o desempenho de busca-local-1-par com busca-local-2 . Fa\u00e7a um gr\u00e1fico Question Com base em seu gr\u00e1fico acima, responda a pergunta: \"\u00c9 poss\u00edvel usar paralelismo para tornar busca-local-1-par melhor que busca-local-2?\" Vamos agora generalizar a pergunta: Question Dados dois algoritmos com complexidades computacionais diferentes, sendo que o primeiro \u00e9 inferior ao segundo. \u00c9 poss\u00edvel usar paralelismo para tornar o primeiro mais r\u00e1pido que o segundo para todos tamanhos de entrada? Assuma que voc\u00ea possui um n\u00famero fixo de n\u00facleos .","title":"Algoritmos paralelos"},{"location":"projetos/","text":"Min-set-cover \u00b6 O problema min-set-cover \u00e9 um dos mais cl\u00e1ssicos problemas de otimiza\u00e7\u00e3o combinat\u00f3ria. Uma inst\u00e2ncia do min-set-cover consiste em um universo U de objetos e uma cole\u00e7\u00e3o F de subconjuntos de U . O desafio \u00e9 identificar uma menor sub-cole\u00e7\u00e3o S de F sujeita \u00e0 restri\u00e7\u00e3o de que a uni\u00e3o dos conjuntos em S deve cobrir o universo U . Por exemplo, suponha que uma cidade deseje selecionar um conjunto de espa\u00e7os f\u00edsicos para implantar uma rede de corpos de bombeiros de forma que cada casa esteja a menos de 5 km de pelo menos um corpo de bombeiros, e de forma que o n\u00famero de corpos de bombeiros necess\u00e1rios seja minimizado. Nesse cen\u00e1rio, o conjunto de casas forma o universo U de itens que devem ser cobertos por qualquer solu\u00e7\u00e3o; e a i-\u00e9sima localiza\u00e7\u00e3o poss\u00edvel para um corpo de bombeiros d\u00e1 origem a um conjunto Si de resid\u00eancias que est\u00e3o a 5 km dele. Supondo tamb\u00e9m que o conjunto total de locais poss\u00edveis seja suficientemente numeroso para que cada casa esteja a 5 km de um ou mais dos locais em considera\u00e7\u00e3o. A solu\u00e7\u00e3o min-set-cover necess\u00e1ria \u00e9 o menor conjunto de locais S de modo que a uni\u00e3o desses sub-conjuntos cubra todas as resid\u00eancias do munic\u00edpio. Ou seja, o que \u00e9 necess\u00e1rio \u00e9 um menor subconjunto S tal que cada casa em U apare\u00e7a em pelo menos um elemento em S . O problema min-set-cover, \u00e9 NP-hard e, portanto, devemos fazer uso de t\u00e9cnicas aproximadas eficientes que possam encontrar uma boa solu\u00e7\u00e3o. Seu programa tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros n e m. Onde n \u00e9 |U| e m \u00e9 o n\u00famero de subconjuntos. Assuma n \u2264 200 e m \u2264 2^n 10 5 5 7 8 9 10 5 7 1 3 6 10 4 6 7 9 10 1 2 8 10 A sa\u00edda deve ser uma linha de inteiros [1...m] , contendo o n\u00famero dos subconjuntos que formam a solu\u00e7\u00e3o: 1 2 4 5 Verifica\u00e7\u00e3o autom\u00e1tica : Conforme o n\u00famero de entrada aumenta, ficar\u00e1 cada vez mais custoso verificar se a sua solu\u00e7\u00e3o resolve o problema do min-set-cover. Fa\u00e7a um programa que recebe como entrada o arquivo de input original adicionado Exemplo: ./verify < solucao1.txt onde solucao1.txt cont\u00e9m: 10 5 5 7 8 9 10 5 7 1 3 6 10 4 6 7 9 10 1 2 8 10 1 2 8 10 1 3 4 5 E tem como sa\u00edda: Cobertura atendida . Gerador de inst\u00e2ncias Neste link voc\u00ea encontra um c\u00f3digo Python que pode ser utilizado para gerar inst\u00e2ncias para seus programa. Observe que n\u00e3o h\u00e1 garantia de que as inst\u00e2ncias geradas possuem solu\u00e7\u00e3o. T\u00e9cnicas estudadas e corre\u00e7\u00e3o autom\u00e1tica \u00b6 Para cada t\u00e9cnica estudada em aula implementaremos vers\u00f5es b\u00e1sicas e avan\u00e7adas. Tamb\u00e9m ser\u00e1 necess\u00e1rio implementar vers\u00f5es paralelas em CPU e GPU. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada t\u00e9cnica implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica Busca Local Busca Exaustiva Relat\u00f3rio Preliminar Paralelismo Multicore Avalia\u00e7\u00e3o \u00b6 O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega. Conceito D \u00b6 Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C \u00b6 Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final Conceito C+ \u00b6 Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio. Conceitos avan\u00e7ados \u00b6 A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Min-set-cover"},{"location":"projetos/#min-set-cover","text":"O problema min-set-cover \u00e9 um dos mais cl\u00e1ssicos problemas de otimiza\u00e7\u00e3o combinat\u00f3ria. Uma inst\u00e2ncia do min-set-cover consiste em um universo U de objetos e uma cole\u00e7\u00e3o F de subconjuntos de U . O desafio \u00e9 identificar uma menor sub-cole\u00e7\u00e3o S de F sujeita \u00e0 restri\u00e7\u00e3o de que a uni\u00e3o dos conjuntos em S deve cobrir o universo U . Por exemplo, suponha que uma cidade deseje selecionar um conjunto de espa\u00e7os f\u00edsicos para implantar uma rede de corpos de bombeiros de forma que cada casa esteja a menos de 5 km de pelo menos um corpo de bombeiros, e de forma que o n\u00famero de corpos de bombeiros necess\u00e1rios seja minimizado. Nesse cen\u00e1rio, o conjunto de casas forma o universo U de itens que devem ser cobertos por qualquer solu\u00e7\u00e3o; e a i-\u00e9sima localiza\u00e7\u00e3o poss\u00edvel para um corpo de bombeiros d\u00e1 origem a um conjunto Si de resid\u00eancias que est\u00e3o a 5 km dele. Supondo tamb\u00e9m que o conjunto total de locais poss\u00edveis seja suficientemente numeroso para que cada casa esteja a 5 km de um ou mais dos locais em considera\u00e7\u00e3o. A solu\u00e7\u00e3o min-set-cover necess\u00e1ria \u00e9 o menor conjunto de locais S de modo que a uni\u00e3o desses sub-conjuntos cubra todas as resid\u00eancias do munic\u00edpio. Ou seja, o que \u00e9 necess\u00e1rio \u00e9 um menor subconjunto S tal que cada casa em U apare\u00e7a em pelo menos um elemento em S . O problema min-set-cover, \u00e9 NP-hard e, portanto, devemos fazer uso de t\u00e9cnicas aproximadas eficientes que possam encontrar uma boa solu\u00e7\u00e3o. Seu programa tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros n e m. Onde n \u00e9 |U| e m \u00e9 o n\u00famero de subconjuntos. Assuma n \u2264 200 e m \u2264 2^n 10 5 5 7 8 9 10 5 7 1 3 6 10 4 6 7 9 10 1 2 8 10 A sa\u00edda deve ser uma linha de inteiros [1...m] , contendo o n\u00famero dos subconjuntos que formam a solu\u00e7\u00e3o: 1 2 4 5 Verifica\u00e7\u00e3o autom\u00e1tica : Conforme o n\u00famero de entrada aumenta, ficar\u00e1 cada vez mais custoso verificar se a sua solu\u00e7\u00e3o resolve o problema do min-set-cover. Fa\u00e7a um programa que recebe como entrada o arquivo de input original adicionado Exemplo: ./verify < solucao1.txt onde solucao1.txt cont\u00e9m: 10 5 5 7 8 9 10 5 7 1 3 6 10 4 6 7 9 10 1 2 8 10 1 2 8 10 1 3 4 5 E tem como sa\u00edda: Cobertura atendida . Gerador de inst\u00e2ncias Neste link voc\u00ea encontra um c\u00f3digo Python que pode ser utilizado para gerar inst\u00e2ncias para seus programa. Observe que n\u00e3o h\u00e1 garantia de que as inst\u00e2ncias geradas possuem solu\u00e7\u00e3o.","title":"Min-set-cover"},{"location":"projetos/#tecnicas-estudadas-e-correcao-automatica","text":"Para cada t\u00e9cnica estudada em aula implementaremos vers\u00f5es b\u00e1sicas e avan\u00e7adas. Tamb\u00e9m ser\u00e1 necess\u00e1rio implementar vers\u00f5es paralelas em CPU e GPU. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada t\u00e9cnica implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior. Solu\u00e7\u00e3o Heur\u00edstica Busca Local Busca Exaustiva Relat\u00f3rio Preliminar Paralelismo Multicore","title":"T\u00e9cnicas estudadas e corre\u00e7\u00e3o autom\u00e1tica"},{"location":"projetos/#avaliacao","text":"O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega.","title":"Avalia\u00e7\u00e3o"},{"location":"projetos/#conceito-d","text":"Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final). Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito D"},{"location":"projetos/#conceito-c","text":"Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida. Solu\u00e7\u00e3o heur\u00edstica Busca local Busca exaustiva Busca local paralela (CPU) Busca local paralela (GPU) Relat\u00f3rio preliminar Relat\u00f3rio final","title":"Conceito C"},{"location":"projetos/#conceito-c_1","text":"Al\u00e9m do j\u00e1 validado no conceito C , os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio.","title":"Conceito C+"},{"location":"projetos/#conceitos-avancados","text":"A partir do conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.","title":"Conceitos avan\u00e7ados"},{"location":"projetos/busca-exaustiva/","text":"Solu\u00e7\u00e3o Busca exaustiva - Branch and Bound \u00b6 Fa\u00e7a agora uma implementa\u00e7\u00e3o de busca exaustiva para o problema do min-set-cover. Assuma inicialmente que todos os subconjuntos s\u00e3o necess\u00e1rios. Para cada subconjunto da solu\u00e7\u00e3o, remova ele a solu\u00e7\u00e3o em quest\u00e3o e verifique se a propriedade de cobertura \u00e9 mantida. Fa\u00e7a isso para todos os elementos na ordem do vetor de solu\u00e7\u00f5es, enquanto a propriedade for v\u00e1lida. Se a propriedade ficar inv\u00e1lida, voc\u00ea deve interromper essa linha de processamento, executando ent\u00e3o uma nova estrutura de possibilidades em que considera esse conjunto vital para a continuidade do problema. Para auxiliar na sua implementa\u00e7\u00e3o, voc\u00ea pode se basear no pseudoc\u00f3digo abaixo. Assuma que custos \u00e9 um vetor unit\u00e1rio de cardinalidade igual ao vetor que armazena os subconjuntos. H\u00e1 um programa Python disponibilizado neste link para que voc\u00ea possa simular a implementa\u00e7\u00e3o desse pseudoc\u00f3digo. Avalie: H\u00e1 garantia de que o resultado \u00f3timo \u00e9 obtido? Justifique.","title":"Solu\u00e7\u00e3o Busca exaustiva - Branch and Bound"},{"location":"projetos/busca-exaustiva/#solucao-busca-exaustiva-branch-and-bound","text":"Fa\u00e7a agora uma implementa\u00e7\u00e3o de busca exaustiva para o problema do min-set-cover. Assuma inicialmente que todos os subconjuntos s\u00e3o necess\u00e1rios. Para cada subconjunto da solu\u00e7\u00e3o, remova ele a solu\u00e7\u00e3o em quest\u00e3o e verifique se a propriedade de cobertura \u00e9 mantida. Fa\u00e7a isso para todos os elementos na ordem do vetor de solu\u00e7\u00f5es, enquanto a propriedade for v\u00e1lida. Se a propriedade ficar inv\u00e1lida, voc\u00ea deve interromper essa linha de processamento, executando ent\u00e3o uma nova estrutura de possibilidades em que considera esse conjunto vital para a continuidade do problema. Para auxiliar na sua implementa\u00e7\u00e3o, voc\u00ea pode se basear no pseudoc\u00f3digo abaixo. Assuma que custos \u00e9 um vetor unit\u00e1rio de cardinalidade igual ao vetor que armazena os subconjuntos. H\u00e1 um programa Python disponibilizado neste link para que voc\u00ea possa simular a implementa\u00e7\u00e3o desse pseudoc\u00f3digo. Avalie: H\u00e1 garantia de que o resultado \u00f3timo \u00e9 obtido? Justifique.","title":"Solu\u00e7\u00e3o Busca exaustiva - Branch and Bound"},{"location":"projetos/busca-local/","text":"Solu\u00e7\u00e3o Busca local \u00b6 A busca local consiste em uma metaheur\u00edstica usada para resolver problemas de otimiza\u00e7\u00e3o computacionalmente dif\u00edceis. Esse tipo de algoritmo percorre o espa\u00e7o de busca movendo-se iterativamente de uma solu\u00e7\u00e3o candidata para outra, seguindo um caminho atrav\u00e9s da rela\u00e7\u00e3o de vizinhan\u00e7a, at\u00e9 que uma solu\u00e7\u00e3o considerada boa o suficiente seja encontrada ou um limite de tempo decorrido. Normalmente todo candidato possui mais de uma solu\u00e7\u00e3o de vizinho e a escolha entre elas \u00e9 feita com o aux\u00edlio de informa\u00e7\u00f5es locais e experi\u00eancia anterior. A solu\u00e7\u00e3o por busca local tenta maximizar o n\u00famero de elementos com o m\u00ednimo de subconjuntos poss\u00edvel. Precisamos capturar esse crit\u00e9rio por meio de uma fun\u00e7\u00e3o de fitness . Uma maneira poss\u00edvel de fazer isso \u00e9 construir uma fun\u00e7\u00e3o de fitness calculando o n\u00famero de elementos capturados pelos subconjuntos de uma solu\u00e7\u00e3o candidata e, em seguida, dividindo-o pelo n\u00famero de subconjuntos que cont\u00e9m. Essa fun\u00e7\u00e3o de pontua\u00e7\u00e3o favorecer\u00e1 as solu\u00e7\u00f5es que acumulam a maioria dos elementos do universo U com o m\u00ednimo de subconjuntos. Para isso, implemente as seguintes altera\u00e7\u00f5es em seu projeto: Gerar uma solu\u00e7\u00e3o aleat\u00f3ria para o problema do min-set-cover; Percorra novamente os conjuntos os elementos da sua solu\u00e7\u00e3o e, de maneira rand\u00f4mica, troque at\u00e9 r (r entre 1 e 3) elementos da sua solu\u00e7\u00e3o por subconjuntos que ficaram de fora da solu\u00e7\u00e3o. Se a solu\u00e7\u00e3o tiver melhor escore, mantenha ela. Para verificar o desempenho, construa um cen\u00e1rio com ao menos 200 elementos e 80 subconjuntos, de at\u00e9 40 elementos cada. Fa\u00e7a tr\u00eas varia\u00e7\u00f5es desse cen\u00e1rio (elementos, subconjuntos, n\u00famero de elementos em subconjuntos) e avalie o desempenho e a efetividade em encontrar uma solu\u00e7\u00e3o \u00f3tima.","title":"Solu\u00e7\u00e3o Busca local"},{"location":"projetos/busca-local/#solucao-busca-local","text":"A busca local consiste em uma metaheur\u00edstica usada para resolver problemas de otimiza\u00e7\u00e3o computacionalmente dif\u00edceis. Esse tipo de algoritmo percorre o espa\u00e7o de busca movendo-se iterativamente de uma solu\u00e7\u00e3o candidata para outra, seguindo um caminho atrav\u00e9s da rela\u00e7\u00e3o de vizinhan\u00e7a, at\u00e9 que uma solu\u00e7\u00e3o considerada boa o suficiente seja encontrada ou um limite de tempo decorrido. Normalmente todo candidato possui mais de uma solu\u00e7\u00e3o de vizinho e a escolha entre elas \u00e9 feita com o aux\u00edlio de informa\u00e7\u00f5es locais e experi\u00eancia anterior. A solu\u00e7\u00e3o por busca local tenta maximizar o n\u00famero de elementos com o m\u00ednimo de subconjuntos poss\u00edvel. Precisamos capturar esse crit\u00e9rio por meio de uma fun\u00e7\u00e3o de fitness . Uma maneira poss\u00edvel de fazer isso \u00e9 construir uma fun\u00e7\u00e3o de fitness calculando o n\u00famero de elementos capturados pelos subconjuntos de uma solu\u00e7\u00e3o candidata e, em seguida, dividindo-o pelo n\u00famero de subconjuntos que cont\u00e9m. Essa fun\u00e7\u00e3o de pontua\u00e7\u00e3o favorecer\u00e1 as solu\u00e7\u00f5es que acumulam a maioria dos elementos do universo U com o m\u00ednimo de subconjuntos. Para isso, implemente as seguintes altera\u00e7\u00f5es em seu projeto: Gerar uma solu\u00e7\u00e3o aleat\u00f3ria para o problema do min-set-cover; Percorra novamente os conjuntos os elementos da sua solu\u00e7\u00e3o e, de maneira rand\u00f4mica, troque at\u00e9 r (r entre 1 e 3) elementos da sua solu\u00e7\u00e3o por subconjuntos que ficaram de fora da solu\u00e7\u00e3o. Se a solu\u00e7\u00e3o tiver melhor escore, mantenha ela. Para verificar o desempenho, construa um cen\u00e1rio com ao menos 200 elementos e 80 subconjuntos, de at\u00e9 40 elementos cada. Fa\u00e7a tr\u00eas varia\u00e7\u00f5es desse cen\u00e1rio (elementos, subconjuntos, n\u00famero de elementos em subconjuntos) e avalie o desempenho e a efetividade em encontrar uma solu\u00e7\u00e3o \u00f3tima.","title":"Solu\u00e7\u00e3o Busca local"},{"location":"projetos/heuristico/","text":"Solu\u00e7\u00e3o heur\u00edstica \u00b6 Um dos melhores estrat\u00e9gias para resolu\u00e7\u00e3o do problema min-set-cover \u00e9 a estrat\u00e9gia gulosa. O algoritmo guloso encontra uma solu\u00e7\u00e3o para o problema de cobertura de conjunto escolhendo iterativamente um conjunto que cobre o maior n\u00famero poss\u00edvel de vari\u00e1veis descobertas restantes. Sua tarefa: implemente a estrat\u00e9gia gulosa para o problema do min-set-cover. A cada itera\u00e7\u00e3o, o algoritmo deve selecionar o subconjunto de F que ir\u00e1 cobrir o maior n\u00famero de elementos de U que estavam descobertos. Fa\u00e7a testes para diversos tipos de entradas, e foque principalmente em uma grande quantidade de elementos e subconjuntos (n > 250)","title":"Solu\u00e7\u00e3o heur\u00edstica"},{"location":"projetos/heuristico/#solucao-heuristica","text":"Um dos melhores estrat\u00e9gias para resolu\u00e7\u00e3o do problema min-set-cover \u00e9 a estrat\u00e9gia gulosa. O algoritmo guloso encontra uma solu\u00e7\u00e3o para o problema de cobertura de conjunto escolhendo iterativamente um conjunto que cobre o maior n\u00famero poss\u00edvel de vari\u00e1veis descobertas restantes. Sua tarefa: implemente a estrat\u00e9gia gulosa para o problema do min-set-cover. A cada itera\u00e7\u00e3o, o algoritmo deve selecionar o subconjunto de F que ir\u00e1 cobrir o maior n\u00famero de elementos de U que estavam descobertos. Fa\u00e7a testes para diversos tipos de entradas, e foque principalmente em uma grande quantidade de elementos e subconjuntos (n > 250)","title":"Solu\u00e7\u00e3o heur\u00edstica"},{"location":"projetos/paralelismo-gpu/","text":"Paralelismo em GPU \u00b6 Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela em GPU do algoritmo de busca local. Compila\u00e7\u00e3o do programa \u00b6 Voc\u00ea dever\u00e1 colocar o c\u00f3digo de seu programa em um arquivo com extens\u00e3o .cu na pasta da busca local. Este programa ser\u00e1 compilado com nvcc -O3 . Corre\u00e7\u00e3o autom\u00e1tica \u00b6 Seu programa dever\u00e1 ter comportamento id\u00eantico a busca local sequencial. Ou seja, dever\u00e1 suportar as mesmas op\u00e7\u00f5es com DEBUG e ITER . Execute o corretor com o argumento local-gpu para rodar somente estes testes.","title":"Paralelismo em GPU"},{"location":"projetos/paralelismo-gpu/#paralelismo-em-gpu","text":"Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela em GPU do algoritmo de busca local.","title":"Paralelismo em GPU"},{"location":"projetos/paralelismo-gpu/#compilacao-do-programa","text":"Voc\u00ea dever\u00e1 colocar o c\u00f3digo de seu programa em um arquivo com extens\u00e3o .cu na pasta da busca local. Este programa ser\u00e1 compilado com nvcc -O3 .","title":"Compila\u00e7\u00e3o do programa"},{"location":"projetos/paralelismo-gpu/#correcao-automatica","text":"Seu programa dever\u00e1 ter comportamento id\u00eantico a busca local sequencial. Ou seja, dever\u00e1 suportar as mesmas op\u00e7\u00f5es com DEBUG e ITER . Execute o corretor com o argumento local-gpu para rodar somente estes testes.","title":"Corre\u00e7\u00e3o autom\u00e1tica"},{"location":"projetos/paralelismo-multicore/","text":"Paralelismo multi-core \u00b6 Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela do algoritmo de busca local. Compila\u00e7\u00e3o do programa \u00b6 Seu programa multi-core dever\u00e1 ser gerado a partir do mesmo c\u00f3digo fonte do sequencial. Ou seja, compilar com -fopenmp habilita o programa paralelo. Compilar sem essa flag obtem os resultados sequenciais. Caso seu programa use as chamadas do OpenMP para c\u00f3digos auxiliares (aloca\u00e7\u00e3o de mem\u00f3ria, etc), voc\u00ea pode checar se seu programa foi compilado com esta flag seguindo o exemplo abaixo. #ifdef _OPENMP // c\u00f3digo espec\u00edfico para multi-core aqui #else // c\u00f3digo espec\u00edfico para sequencia aqui #endif Corre\u00e7\u00e3o autom\u00e1tica \u00b6 Se seu programa for compilado com -fopenmp ele dever\u00e1 rodar usando todas as CPUs pelo m\u00e1ximo de tempo poss\u00edvel. O corretor autom\u00e1tico checar\u00e1 as seguintes condi\u00e7\u00f5es: o consumo m\u00e9dio de CPU durante a execu\u00e7\u00e3o do programa \u00e9 maior que 75% para cada core. as mesmas checagens do algoritmo sequencial ser\u00e3o feitas. Ou seja, seu programa dever\u00e1 funcionar de maneira id\u00eantica ao algoritmo sequencial. Os resultados n\u00e3o precisam ser exatamente os mesmos, mas o programa dever\u00e1 gerar solu\u00e7\u00f5es com as mesmas propriedades. Execute o corretor com o argumento multi-core para rodar somente estes testes.","title":"Paralelismo multi-core"},{"location":"projetos/paralelismo-multicore/#paralelismo-multi-core","text":"Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela do algoritmo de busca local.","title":"Paralelismo multi-core"},{"location":"projetos/paralelismo-multicore/#compilacao-do-programa","text":"Seu programa multi-core dever\u00e1 ser gerado a partir do mesmo c\u00f3digo fonte do sequencial. Ou seja, compilar com -fopenmp habilita o programa paralelo. Compilar sem essa flag obtem os resultados sequenciais. Caso seu programa use as chamadas do OpenMP para c\u00f3digos auxiliares (aloca\u00e7\u00e3o de mem\u00f3ria, etc), voc\u00ea pode checar se seu programa foi compilado com esta flag seguindo o exemplo abaixo. #ifdef _OPENMP // c\u00f3digo espec\u00edfico para multi-core aqui #else // c\u00f3digo espec\u00edfico para sequencia aqui #endif","title":"Compila\u00e7\u00e3o do programa"},{"location":"projetos/paralelismo-multicore/#correcao-automatica","text":"Se seu programa for compilado com -fopenmp ele dever\u00e1 rodar usando todas as CPUs pelo m\u00e1ximo de tempo poss\u00edvel. O corretor autom\u00e1tico checar\u00e1 as seguintes condi\u00e7\u00f5es: o consumo m\u00e9dio de CPU durante a execu\u00e7\u00e3o do programa \u00e9 maior que 75% para cada core. as mesmas checagens do algoritmo sequencial ser\u00e3o feitas. Ou seja, seu programa dever\u00e1 funcionar de maneira id\u00eantica ao algoritmo sequencial. Os resultados n\u00e3o precisam ser exatamente os mesmos, mas o programa dever\u00e1 gerar solu\u00e7\u00f5es com as mesmas propriedades. Execute o corretor com o argumento multi-core para rodar somente estes testes.","title":"Corre\u00e7\u00e3o autom\u00e1tica"},{"location":"projetos/relatorio-1/","text":"Relat\u00f3rio - v1 \u00b6 Nesta primeira parte do relat\u00f3rio iremos analisar as implementa\u00e7\u00f5es j\u00e1 criadas com rela\u00e7\u00e3o a sua velocidade e qualidade da solu\u00e7\u00e3o. Os objetivos deste relat\u00f3rio s\u00e3o criar entradas de tamanho adequado para os prop\u00f3sitos dos testes estudar o efeito do n\u00famero de pessoas e do n\u00famero de objetos nas medidas de interesse (tempo e qualidade da solu\u00e7\u00e3o) comparar o desempenho dos algoritmos implementados at\u00e9 o momento em rela\u00e7\u00e3o a essas duas medidas. Seu trabalhou dever\u00e1 ser entregue como um arquivo PDF chamado relatorio-intermediario.pdf na pasta relatorios do reposit\u00f3rio. Ele poder\u00e1 ser gerado a partir de um Jupyter notebook (como feito na aula 01 ) ou usando a ferramenta pweave ( recomendado ). A rubrica de avalia\u00e7\u00e3o est\u00e1 dispon\u00edvel abaixo e tamb\u00e9m neste link .","title":"Relat\u00f3rio - v1"},{"location":"projetos/relatorio-1/#relatorio-v1","text":"Nesta primeira parte do relat\u00f3rio iremos analisar as implementa\u00e7\u00f5es j\u00e1 criadas com rela\u00e7\u00e3o a sua velocidade e qualidade da solu\u00e7\u00e3o. Os objetivos deste relat\u00f3rio s\u00e3o criar entradas de tamanho adequado para os prop\u00f3sitos dos testes estudar o efeito do n\u00famero de pessoas e do n\u00famero de objetos nas medidas de interesse (tempo e qualidade da solu\u00e7\u00e3o) comparar o desempenho dos algoritmos implementados at\u00e9 o momento em rela\u00e7\u00e3o a essas duas medidas. Seu trabalhou dever\u00e1 ser entregue como um arquivo PDF chamado relatorio-intermediario.pdf na pasta relatorios do reposit\u00f3rio. Ele poder\u00e1 ser gerado a partir de um Jupyter notebook (como feito na aula 01 ) ou usando a ferramenta pweave ( recomendado ). A rubrica de avalia\u00e7\u00e3o est\u00e1 dispon\u00edvel abaixo e tamb\u00e9m neste link .","title":"Relat\u00f3rio - v1"},{"location":"projetos/relatorio-2/","text":"Relat\u00f3rio Final \u00b6 No relat\u00f3rio final iremos comparar nossas implementa\u00e7\u00f5es sequenciais da busca local com as implementa\u00e7\u00f5es paralelas em CPU e GPU. Os objetivos deste relat\u00f3rio s\u00e3o: criar entradas de tamanho adequado para os prop\u00f3sitos dos testes estudar o efeito do n\u00famero de pessoas e do n\u00famero de objetos nas medidas de interesse (tempo e qualidade da solu\u00e7\u00e3o) comparar o desempenho dos algoritmos implementados at\u00e9 o momento em rela\u00e7\u00e3o a essas duas medidas. comparar as estrat\u00e9gias paralelas com a implementa\u00e7\u00e3o sequencial Em adi\u00e7\u00e3o ao que ja foi feito no relat\u00f3rio intermedi\u00e1rio, agora voc\u00eas dever\u00e3o comparar o desempenho das implementa\u00e7\u00f5es sequenciais e paralelas da busca local. Procure mostrar em quais situa\u00e7\u00f5es cada implementa\u00e7\u00e3o \u00e9 melhor, adicionando um coment\u00e1rio na sua conclus\u00e3o sobre suas descobertas. Seu trabalhou dever\u00e1 ser entregue como um arquivo PDF chamado relatorio-final.pdf na pasta relatorios do reposit\u00f3rio. Ele poder\u00e1 ser gerado a partir de um Jupyter notebook (como feito na aula 01 ) ou usando a ferramenta pweave ( recomendado ). A rubrica de avalia\u00e7\u00e3o est\u00e1 dispon\u00edvel abaixo e tamb\u00e9m neste link . A nota final de relat\u00f3rio ser\u00e1: D se o relat\u00f3rio receber D em mais de um conceito. m\u00e9dia dos conceitos obtidos caso contr\u00e1rio.","title":"Relat\u00f3rio Final"},{"location":"projetos/relatorio-2/#relatorio-final","text":"No relat\u00f3rio final iremos comparar nossas implementa\u00e7\u00f5es sequenciais da busca local com as implementa\u00e7\u00f5es paralelas em CPU e GPU. Os objetivos deste relat\u00f3rio s\u00e3o: criar entradas de tamanho adequado para os prop\u00f3sitos dos testes estudar o efeito do n\u00famero de pessoas e do n\u00famero de objetos nas medidas de interesse (tempo e qualidade da solu\u00e7\u00e3o) comparar o desempenho dos algoritmos implementados at\u00e9 o momento em rela\u00e7\u00e3o a essas duas medidas. comparar as estrat\u00e9gias paralelas com a implementa\u00e7\u00e3o sequencial Em adi\u00e7\u00e3o ao que ja foi feito no relat\u00f3rio intermedi\u00e1rio, agora voc\u00eas dever\u00e3o comparar o desempenho das implementa\u00e7\u00f5es sequenciais e paralelas da busca local. Procure mostrar em quais situa\u00e7\u00f5es cada implementa\u00e7\u00e3o \u00e9 melhor, adicionando um coment\u00e1rio na sua conclus\u00e3o sobre suas descobertas. Seu trabalhou dever\u00e1 ser entregue como um arquivo PDF chamado relatorio-final.pdf na pasta relatorios do reposit\u00f3rio. Ele poder\u00e1 ser gerado a partir de um Jupyter notebook (como feito na aula 01 ) ou usando a ferramenta pweave ( recomendado ). A rubrica de avalia\u00e7\u00e3o est\u00e1 dispon\u00edvel abaixo e tamb\u00e9m neste link . A nota final de relat\u00f3rio ser\u00e1: D se o relat\u00f3rio receber D em mais de um conceito. m\u00e9dia dos conceitos obtidos caso contr\u00e1rio.","title":"Relat\u00f3rio Final"}]}