{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SuperComputa\u00e7\u00e3o \u00b6 Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2020/1. Professor : Igor Montagner Monitores : Leonardo Pereira Medeiros Raphael Marques da Costa Objetivos \u00b6 Ao final da disciplina o aluno ser\u00e1 capaz de: Desenvolver algoritmos usando recursos de computa\u00e7\u00e3o paralela/distribu\u00edda para ganhos de desempenho da aplica\u00e7\u00e3o final; Aplicar estrutura l\u00f3gica de computa\u00e7\u00e3o distribu\u00edda para o desenvolvimento de algoritmos multitarefas; Usar GPGPU para computa\u00e7\u00e3o num\u00e9rica e comparar com solu\u00e7\u00f5es baseadas em CPU Planejar e projetar sistemas de computa\u00e7\u00e3o de alto desempenho; Analisar a complexidade dos algoritmos paralelos e a efici\u00eancia de uma implementa\u00e7\u00e3o particular, identificando as medidas de desempenho mais adequadas para esta tarefa; Aplicar recursos espec\u00edfico de sistemas operacionais para melhorar o desempenho de algoritmos; Desenvolver aplica\u00e7\u00f5es que utilizam protocolos otimizados para paraleliza\u00e7\u00e3o. Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os projetos ter\u00e3o dura\u00e7\u00e3o de duas semanas e ser\u00e3o incrementais com os seguintes pesos para m\u00e9dia de projetos: Projeto 0 - revis\u00e3o de C++ (10%) Projeto 1 - multi core (30%) Projeto 2 - GPU (30%) Projeto 3 - MPI (30%) Atividades de acompanhamento ser\u00e3o disponibilizadas durante o semestre. Estas atividades ter\u00e3o corre\u00e7\u00e3o autom\u00e1tica e sua realiza\u00e7\u00e3o \u00e9 opcional. Entregas atrasadas n\u00e3o ser\u00e3o aceitas para nota . A m\u00e9dia final \u00e9 dada por \\max \\begin{cases}0,4 \\times MP + 0,5\\times MProj + 0,1\\times AT \\\\ 0,5 \\times MP + 0,5 \\times MProj \\end{cases} \\max \\begin{cases}0,4 \\times MP + 0,5\\times MProj + 0,1\\times AT \\\\ 0,5 \\times MP + 0,5 \\times MProj \\end{cases} Condi\u00e7\u00f5es de barreira Caso as seguintes condi\u00e7\u00f5es n\u00e3o sejam cumpridas, a nota final ser\u00e1 D (4,0): Todos os projetos foram entregues MP \\geq 4,5 MP \\geq 4,5 Se um projeto receber nota \\leq 5 \\leq 5 , ele dever\u00e1 ser reentregue at\u00e9 o fim do semestre com as corre\u00e7\u00f5es solicitadas. Se tudo estiver OK a nota deste projeto ser\u00e1 D Se um projeto for entregue atrasado sua nota final ser\u00e1 D Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Home"},{"location":"#supercomputacao","text":"Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2020/1. Professor : Igor Montagner Monitores : Leonardo Pereira Medeiros Raphael Marques da Costa","title":"SuperComputa\u00e7\u00e3o"},{"location":"#objetivos","text":"Ao final da disciplina o aluno ser\u00e1 capaz de: Desenvolver algoritmos usando recursos de computa\u00e7\u00e3o paralela/distribu\u00edda para ganhos de desempenho da aplica\u00e7\u00e3o final; Aplicar estrutura l\u00f3gica de computa\u00e7\u00e3o distribu\u00edda para o desenvolvimento de algoritmos multitarefas; Usar GPGPU para computa\u00e7\u00e3o num\u00e9rica e comparar com solu\u00e7\u00f5es baseadas em CPU Planejar e projetar sistemas de computa\u00e7\u00e3o de alto desempenho; Analisar a complexidade dos algoritmos paralelos e a efici\u00eancia de uma implementa\u00e7\u00e3o particular, identificando as medidas de desempenho mais adequadas para esta tarefa; Aplicar recursos espec\u00edfico de sistemas operacionais para melhorar o desempenho de algoritmos; Desenvolver aplica\u00e7\u00f5es que utilizam protocolos otimizados para paraleliza\u00e7\u00e3o.","title":"Objetivos"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os projetos ter\u00e3o dura\u00e7\u00e3o de duas semanas e ser\u00e3o incrementais com os seguintes pesos para m\u00e9dia de projetos: Projeto 0 - revis\u00e3o de C++ (10%) Projeto 1 - multi core (30%) Projeto 2 - GPU (30%) Projeto 3 - MPI (30%) Atividades de acompanhamento ser\u00e3o disponibilizadas durante o semestre. Estas atividades ter\u00e3o corre\u00e7\u00e3o autom\u00e1tica e sua realiza\u00e7\u00e3o \u00e9 opcional. Entregas atrasadas n\u00e3o ser\u00e3o aceitas para nota . A m\u00e9dia final \u00e9 dada por \\max \\begin{cases}0,4 \\times MP + 0,5\\times MProj + 0,1\\times AT \\\\ 0,5 \\times MP + 0,5 \\times MProj \\end{cases} \\max \\begin{cases}0,4 \\times MP + 0,5\\times MProj + 0,1\\times AT \\\\ 0,5 \\times MP + 0,5 \\times MProj \\end{cases} Condi\u00e7\u00f5es de barreira Caso as seguintes condi\u00e7\u00f5es n\u00e3o sejam cumpridas, a nota final ser\u00e1 D (4,0): Todos os projetos foram entregues MP \\geq 4,5 MP \\geq 4,5 Se um projeto receber nota \\leq 5 \\leq 5 , ele dever\u00e1 ser reentregue at\u00e9 o fim do semestre com as corre\u00e7\u00f5es solicitadas. Se tudo estiver OK a nota deste projeto ser\u00e1 D Se um projeto for entregue atrasado sua nota final ser\u00e1 D Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Avalia\u00e7\u00e3o"},{"location":"sobre/","text":"Burocracias \u00b6 Turma 1 \u00b6 TER 09:45 - 11:45 SEX 07:30 - 09:30 Atendimento: Plano de aulas \u00b6 Data Quest\u00e3o/Problema Conte\u00fado/Atividade 11/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Refer\u00eancia: Pacheco Cap 2. 14/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Orienta\u00e7\u00e3o a Objeto em C++; revis\u00e3o de ponteiros e passagem de argumentos por refer\u00eancia e valor 18/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Conteiners STL: vector, string, map 21/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Debug, profiling e compila\u00e7\u00e3o 25/02 FERIADO FERIADO 28/02 Processamento de dados vetorial Instru\u00e7\u00f5es SIMD e compila\u00e7\u00e3o; Refer\u00eancia: Cap 2 Hager, Cap 3 Dubois 03/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas CPU bound; Modelo fork-join; Exemplo com threads C++11; Leitura: Cap 5 Hager 06/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 10/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/03 Cancelamento COVID-19 Cancelamento COVID-19 17/03 Cancelamento COVID-19 Cancelamento COVID-19 20/03 Cancelamento COVID-19 Cancelamento COVID-19 24/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 27/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 31/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Simulado de atividade pr\u00e1tica para prova 03/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 07/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 10/04 FERIADO FERIADO 14/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 17/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 21/04 FERIADO FERIADO 24/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 28/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 01/05 FERIADO FERIADO 05/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 08/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 12/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Otimizando c\u00f3digo Cuda C \u2013 mem\u00f3ria compartilhada; Refer\u00eancia: Cap 4 Kirk 15/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 19/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 22/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Introdu\u00e7\u00e3o a sistemas distribu\u00eddos; Passagem de mensagens; Refer\u00eancia: Parte IV Taurion; Cap 9 Hager 26/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Modelos de divis\u00e3o carga: dados vs tarefas; Refer\u00eancia: Cap 9 Hager 29/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Custos de comunica\u00e7\u00e3o e processamento; mensagens ass\u00edncronas; Refer\u00eancia: Cap 10 Hager, Leitura: \u201cA survey of high-performance computing scaling challenges\u201d 02/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Comunica\u00e7\u00e3o coletiva; Refer\u00eancia: Cap 13 Reinders, Cap 10 Hager 05/06 Simulado de atividade pr\u00e1tica para prova Simulado de atividade pr\u00e1tica para prova 09/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 12/06 FERIADO FERIADO 16/06 Prova Final Prova Final 19/06 Prova Final Prova Final Turma 2 \u00b6 QUA 13:30 - 15:30 SEX 13:30 - 15:30 Atendimento: Plano de aulas \u00b6 Data Quest\u00e3o/Problema Conte\u00fado/Atividade 12/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Refer\u00eancia: Pacheco Cap 2. 14/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Orienta\u00e7\u00e3o a Objeto em C++; revis\u00e3o de ponteiros e passagem de argumentos por refer\u00eancia e valor 19/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Conteiners STL: vector, string, map 21/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Debug, profiling e compila\u00e7\u00e3o 26/02 FERIADO FERIADO 28/02 Processamento de dados vetorial Instru\u00e7\u00f5es SIMD e compila\u00e7\u00e3o; Refer\u00eancia: Cap 2 Hager, Cap 3 Dubois 04/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas CPU bound; Modelo fork-join; Exemplo com threads C++11; Leitura: Cap 5 Hager 06/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 11/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/03 Cancelamento COVID-19 Cancelamento COVID-19 18/03 Cancelamento COVID-19 Cancelamento COVID-19 20/03 Cancelamento COVID-19 Cancelamento COVID-19 25/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 27/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 01/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Simulado de atividade pr\u00e1tica para prova 03/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 08/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 10/04 FERIADO FERIADO 15/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 17/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 22/04 FERIADO FERIADO 24/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 29/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 01/05 FERIADO FERIADO 06/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 08/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 13/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Otimizando c\u00f3digo Cuda C \u2013 mem\u00f3ria compartilhada; Refer\u00eancia: Cap 4 Kirk 15/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 20/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 22/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Introdu\u00e7\u00e3o a sistemas distribu\u00eddos; Passagem de mensagens; Refer\u00eancia: Parte IV Taurion; Cap 9 Hager 27/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Modelos de divis\u00e3o carga: dados vs tarefas; Refer\u00eancia: Cap 9 Hager 29/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Custos de comunica\u00e7\u00e3o e processamento; mensagens ass\u00edncronas; Refer\u00eancia: Cap 10 Hager, Leitura: \u201cA survey of high-performance computing scaling challenges\u201d 03/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Comunica\u00e7\u00e3o coletiva; Refer\u00eancia: Cap 13 Reinders, Cap 10 Hager 05/06 Simulado de atividade pr\u00e1tica para prova Simulado de atividade pr\u00e1tica para prova 10/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 12/06 FERIADO FERIADO 17/06 Prova Final Prova Final 19/06 Prova Final Prova Final","title":"Sobre"},{"location":"sobre/#burocracias","text":"","title":"Burocracias"},{"location":"sobre/#turma-1","text":"TER 09:45 - 11:45 SEX 07:30 - 09:30 Atendimento:","title":"Turma 1"},{"location":"sobre/#plano-de-aulas","text":"Data Quest\u00e3o/Problema Conte\u00fado/Atividade 11/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Refer\u00eancia: Pacheco Cap 2. 14/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Orienta\u00e7\u00e3o a Objeto em C++; revis\u00e3o de ponteiros e passagem de argumentos por refer\u00eancia e valor 18/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Conteiners STL: vector, string, map 21/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Debug, profiling e compila\u00e7\u00e3o 25/02 FERIADO FERIADO 28/02 Processamento de dados vetorial Instru\u00e7\u00f5es SIMD e compila\u00e7\u00e3o; Refer\u00eancia: Cap 2 Hager, Cap 3 Dubois 03/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas CPU bound; Modelo fork-join; Exemplo com threads C++11; Leitura: Cap 5 Hager 06/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 10/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/03 Cancelamento COVID-19 Cancelamento COVID-19 17/03 Cancelamento COVID-19 Cancelamento COVID-19 20/03 Cancelamento COVID-19 Cancelamento COVID-19 24/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 27/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 31/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Simulado de atividade pr\u00e1tica para prova 03/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 07/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 10/04 FERIADO FERIADO 14/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 17/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 21/04 FERIADO FERIADO 24/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 28/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 01/05 FERIADO FERIADO 05/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 08/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 12/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Otimizando c\u00f3digo Cuda C \u2013 mem\u00f3ria compartilhada; Refer\u00eancia: Cap 4 Kirk 15/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 19/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 22/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Introdu\u00e7\u00e3o a sistemas distribu\u00eddos; Passagem de mensagens; Refer\u00eancia: Parte IV Taurion; Cap 9 Hager 26/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Modelos de divis\u00e3o carga: dados vs tarefas; Refer\u00eancia: Cap 9 Hager 29/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Custos de comunica\u00e7\u00e3o e processamento; mensagens ass\u00edncronas; Refer\u00eancia: Cap 10 Hager, Leitura: \u201cA survey of high-performance computing scaling challenges\u201d 02/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Comunica\u00e7\u00e3o coletiva; Refer\u00eancia: Cap 13 Reinders, Cap 10 Hager 05/06 Simulado de atividade pr\u00e1tica para prova Simulado de atividade pr\u00e1tica para prova 09/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 12/06 FERIADO FERIADO 16/06 Prova Final Prova Final 19/06 Prova Final Prova Final","title":"Plano de aulas"},{"location":"sobre/#turma-2","text":"QUA 13:30 - 15:30 SEX 13:30 - 15:30 Atendimento:","title":"Turma 2"},{"location":"sobre/#plano-de-aulas_1","text":"Data Quest\u00e3o/Problema Conte\u00fado/Atividade 12/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Refer\u00eancia: Pacheco Cap 2. 14/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Orienta\u00e7\u00e3o a Objeto em C++; revis\u00e3o de ponteiros e passagem de argumentos por refer\u00eancia e valor 19/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Conteiners STL: vector, string, map 21/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Debug, profiling e compila\u00e7\u00e3o 26/02 FERIADO FERIADO 28/02 Processamento de dados vetorial Instru\u00e7\u00f5es SIMD e compila\u00e7\u00e3o; Refer\u00eancia: Cap 2 Hager, Cap 3 Dubois 04/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas CPU bound; Modelo fork-join; Exemplo com threads C++11; Leitura: Cap 5 Hager 06/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 11/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/03 Cancelamento COVID-19 Cancelamento COVID-19 18/03 Cancelamento COVID-19 Cancelamento COVID-19 20/03 Cancelamento COVID-19 Cancelamento COVID-19 25/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 27/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 01/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Simulado de atividade pr\u00e1tica para prova 03/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 08/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 10/04 FERIADO FERIADO 15/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 17/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 22/04 FERIADO FERIADO 24/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 29/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 01/05 FERIADO FERIADO 06/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 08/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 13/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Otimizando c\u00f3digo Cuda C \u2013 mem\u00f3ria compartilhada; Refer\u00eancia: Cap 4 Kirk 15/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 20/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 22/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Introdu\u00e7\u00e3o a sistemas distribu\u00eddos; Passagem de mensagens; Refer\u00eancia: Parte IV Taurion; Cap 9 Hager 27/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Modelos de divis\u00e3o carga: dados vs tarefas; Refer\u00eancia: Cap 9 Hager 29/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Custos de comunica\u00e7\u00e3o e processamento; mensagens ass\u00edncronas; Refer\u00eancia: Cap 10 Hager, Leitura: \u201cA survey of high-performance computing scaling challenges\u201d 03/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Comunica\u00e7\u00e3o coletiva; Refer\u00eancia: Cap 13 Reinders, Cap 10 Hager 05/06 Simulado de atividade pr\u00e1tica para prova Simulado de atividade pr\u00e1tica para prova 10/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 12/06 FERIADO FERIADO 17/06 Prova Final Prova Final 19/06 Prova Final Prova Final","title":"Plano de aulas"},{"location":"aulas/00-organizacao/","text":"Organiza\u00e7\u00e3o do reposit\u00f3rio \u00b6 O material de SuperComputa\u00e7\u00e3o para cada aula do semestre pode ser acessado utilizando o menu no lado esquerdo desta p\u00e1gina. Todos os exemplos de c\u00f3digo est\u00e3o na pasta code na raiz do reposit\u00f3rio e ser\u00e3o tamb\u00e9m lincados em cada aula. Todos os slides est\u00e3o na pasta material/aulas e tamb\u00e9m est\u00e3o lincados na parte pr\u00e1tica de cada aula.","title":"Organiza\u00e7\u00e3o do reposit\u00f3rio"},{"location":"aulas/00-organizacao/#organizacao-do-repositorio","text":"O material de SuperComputa\u00e7\u00e3o para cada aula do semestre pode ser acessado utilizando o menu no lado esquerdo desta p\u00e1gina. Todos os exemplos de c\u00f3digo est\u00e3o na pasta code na raiz do reposit\u00f3rio e ser\u00e3o tamb\u00e9m lincados em cada aula. Todos os slides est\u00e3o na pasta material/aulas e tamb\u00e9m est\u00e3o lincados na parte pr\u00e1tica de cada aula.","title":"Organiza\u00e7\u00e3o do reposit\u00f3rio"},{"location":"aulas/01-intro-cpp/","text":"O principal objetivo deste roteiro \u00e9 retomar a pr\u00e1tica de programa\u00e7\u00e3o em C++ usando exerc\u00edcios simples e que eventualmente sejam \u00fateis para os projetos da disciplina. Os exerc\u00edcios para entrega estar\u00e3o indicados no fim do roteiro. Entrada e sa\u00edda \u00b6 Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream) Para mostrar mensagens no terminal basta \"enviar\" dados para o objeto usando o operador <<. Veja o exemplo abaixo. Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream ) Para mostrar mensagens no terminal basta \"enviar\" dados para o objeto usando o operador << . Veja o exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << a << \";\" << b << \" \\n \" ; Note que n\u00e3o precisamos mais usar a string de formata\u00e7\u00e3o cheia de %d e afins. Basta ir aplicando << aos dados que queremos mostrar. O mesmo vale para a entrada, mas desta vez \"tiramos\" os dados do objeto std::cin . O exemplo abaixo l\u00ea um inteiro e um double do terminal. int a ; double b ; std :: cin >> a >> b ; Example Crie um programa que l\u00ea um n\u00famero inteiro n e mostra em sua sa\u00edda sua divis\u00e3o fracion\u00e1ria por 2. Ou seja, antes de dividir converta n para double . Aloca\u00e7\u00e3o de mem\u00f3ria \u00b6 Em C usamos as fun\u00e7\u00f5es malloc e free para alocar mem\u00f3ria dinamicamente. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m est\u00e3o dispon\u00edveis, mas us\u00e1-las \u00e9 considerado uma m\u00e1 pr\u00e1tica. Ao inv\u00e9s, usamos os operadores new e delete para alocar mem\u00f3ria. point * p ; p = new point (); /* usar p aqui */ delete p ; Tamb\u00e9m podemos criar (e deletar) arrays de tamanho fixo usando new[] e delete[] . int n ; std :: cin >> n ; double * values = new double [ n ]; /* usar values aqui */ delete [] values ; Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Dica : procure por setprecision para configurar as casas decimais do cout . Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas? Contagem de tempo \u00b6 Durante todo o curso iremos trabalhar com medi\u00e7\u00f5es de tempo, especialmente para descobrir quais trechos do nosso c\u00f3digo tem mais impacto no tempo de execu\u00e7\u00e3o. Example Crie um script python que gere uma entrada muito grande ( n=100000 ) para o programa acima. Question Use a ferramenta time para medir o tempo de execu\u00e7\u00e3o do programa. Escreva este valor abaixo. Voc\u00ea consegue dizer quanto tempo o c\u00e1lculo da vari\u00e2ncia leva? Um dos problemas da utiliza\u00e7\u00e3o do comando time \u00e9 que ele n\u00e3o separa o tempo gasto para ler a entrada do programa e o tempo gasto no calculo de cada medida. Felizmente a biblioteca padr\u00e3o de C++ possui diversas classes para medi\u00e7\u00e3o de tempo. O cabe\u00e7alho <chrono> disponibiliza diversas classes e fun\u00e7\u00f5es para medi\u00e7\u00e3o de tempo. Leia sua documenta\u00e7\u00e3o neste link . Question Qual classe voc\u00ea usaria para obter leituras de tempo com a melhor precis\u00e3o poss\u00edvel? Quais m\u00e9todos ou fun\u00e7\u00f5es desta classe seriam \u00fateis? Para que servem as classes time_point e duration ? Example Use as classes acima para medir o tempo de execu\u00e7\u00e3o, separadamente, da m\u00e9dia e da vari\u00e2ncia no exemplo anterior. Escreva abaixo o tempo gasto em milisegundos . Projeto 0 - revis\u00e3o de C++ \u00b6 A parte inicial de nosso curso foca na compreens\u00e3o e implementa\u00e7\u00e3o de fun\u00e7\u00f5es matem\u00e1ticas. Para isso vamos iniciar uma sequ\u00eancia de atividades que far\u00e3o compara\u00e7\u00f5es de desempenho de fun\u00e7\u00f5es do cabe\u00e7alho cmath (que \u00e9 o mesmo math.h que us\u00e1vamos em C , mas agora exportado para usar em C++ ). Warning O projeto 0 \u00e9 individual e dever\u00e1 ser entregue via blackboard. Este projeto n\u00e3o dever\u00e1 estar hospedado no github. Example Cria um arquivo chamado parte0.c contendo uma fun\u00e7\u00e3o gera_vetor que recebe um inteiro n e devolve um vetor de dados aleat\u00f3rio de tamanho n com tipo double . fun\u00e7\u00f5es log , sqrt , pow3 (usando a biblioteca math ) e pow3mult (usando o operador * duas vezes) que computam as opera\u00e7\u00f5es correspondentes em cada elemento do vetor. uma fun\u00e7\u00e3o sum que calcula a soma do vetor um main que cria vetores de tamanho incrementalmente maior e computa o tempo necess\u00e1rio para cada fun\u00e7\u00e3o rodar. Question Para cada fun\u00e7\u00e3o criada, coloque abaixo os tempos colhidos para cada tamanho de vetor. O nome da disciplina \u00e9 SuperComputa\u00e7\u00e3o. Honre esse nome ao escolher tamanhos de vetores.","title":"01 - Introdu\u00e7\u00e3o a C++"},{"location":"aulas/01-intro-cpp/#entrada-e-saida","text":"Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream) Para mostrar mensagens no terminal basta \"enviar\" dados para o objeto usando o operador <<. Veja o exemplo abaixo. Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream ) Para mostrar mensagens no terminal basta \"enviar\" dados para o objeto usando o operador << . Veja o exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << a << \";\" << b << \" \\n \" ; Note que n\u00e3o precisamos mais usar a string de formata\u00e7\u00e3o cheia de %d e afins. Basta ir aplicando << aos dados que queremos mostrar. O mesmo vale para a entrada, mas desta vez \"tiramos\" os dados do objeto std::cin . O exemplo abaixo l\u00ea um inteiro e um double do terminal. int a ; double b ; std :: cin >> a >> b ; Example Crie um programa que l\u00ea um n\u00famero inteiro n e mostra em sua sa\u00edda sua divis\u00e3o fracion\u00e1ria por 2. Ou seja, antes de dividir converta n para double .","title":"Entrada e sa\u00edda"},{"location":"aulas/01-intro-cpp/#alocacao-de-memoria","text":"Em C usamos as fun\u00e7\u00f5es malloc e free para alocar mem\u00f3ria dinamicamente. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m est\u00e3o dispon\u00edveis, mas us\u00e1-las \u00e9 considerado uma m\u00e1 pr\u00e1tica. Ao inv\u00e9s, usamos os operadores new e delete para alocar mem\u00f3ria. point * p ; p = new point (); /* usar p aqui */ delete p ; Tamb\u00e9m podemos criar (e deletar) arrays de tamanho fixo usando new[] e delete[] . int n ; std :: cin >> n ; double * values = new double [ n ]; /* usar values aqui */ delete [] values ; Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Dica : procure por setprecision para configurar as casas decimais do cout . Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas?","title":"Aloca\u00e7\u00e3o de mem\u00f3ria"},{"location":"aulas/01-intro-cpp/#contagem-de-tempo","text":"Durante todo o curso iremos trabalhar com medi\u00e7\u00f5es de tempo, especialmente para descobrir quais trechos do nosso c\u00f3digo tem mais impacto no tempo de execu\u00e7\u00e3o. Example Crie um script python que gere uma entrada muito grande ( n=100000 ) para o programa acima. Question Use a ferramenta time para medir o tempo de execu\u00e7\u00e3o do programa. Escreva este valor abaixo. Voc\u00ea consegue dizer quanto tempo o c\u00e1lculo da vari\u00e2ncia leva? Um dos problemas da utiliza\u00e7\u00e3o do comando time \u00e9 que ele n\u00e3o separa o tempo gasto para ler a entrada do programa e o tempo gasto no calculo de cada medida. Felizmente a biblioteca padr\u00e3o de C++ possui diversas classes para medi\u00e7\u00e3o de tempo. O cabe\u00e7alho <chrono> disponibiliza diversas classes e fun\u00e7\u00f5es para medi\u00e7\u00e3o de tempo. Leia sua documenta\u00e7\u00e3o neste link . Question Qual classe voc\u00ea usaria para obter leituras de tempo com a melhor precis\u00e3o poss\u00edvel? Quais m\u00e9todos ou fun\u00e7\u00f5es desta classe seriam \u00fateis? Para que servem as classes time_point e duration ? Example Use as classes acima para medir o tempo de execu\u00e7\u00e3o, separadamente, da m\u00e9dia e da vari\u00e2ncia no exemplo anterior. Escreva abaixo o tempo gasto em milisegundos .","title":"Contagem de tempo"},{"location":"aulas/01-intro-cpp/#projeto-0-revisao-de-c","text":"A parte inicial de nosso curso foca na compreens\u00e3o e implementa\u00e7\u00e3o de fun\u00e7\u00f5es matem\u00e1ticas. Para isso vamos iniciar uma sequ\u00eancia de atividades que far\u00e3o compara\u00e7\u00f5es de desempenho de fun\u00e7\u00f5es do cabe\u00e7alho cmath (que \u00e9 o mesmo math.h que us\u00e1vamos em C , mas agora exportado para usar em C++ ). Warning O projeto 0 \u00e9 individual e dever\u00e1 ser entregue via blackboard. Este projeto n\u00e3o dever\u00e1 estar hospedado no github. Example Cria um arquivo chamado parte0.c contendo uma fun\u00e7\u00e3o gera_vetor que recebe um inteiro n e devolve um vetor de dados aleat\u00f3rio de tamanho n com tipo double . fun\u00e7\u00f5es log , sqrt , pow3 (usando a biblioteca math ) e pow3mult (usando o operador * duas vezes) que computam as opera\u00e7\u00f5es correspondentes em cada elemento do vetor. uma fun\u00e7\u00e3o sum que calcula a soma do vetor um main que cria vetores de tamanho incrementalmente maior e computa o tempo necess\u00e1rio para cada fun\u00e7\u00e3o rodar. Question Para cada fun\u00e7\u00e3o criada, coloque abaixo os tempos colhidos para cada tamanho de vetor. O nome da disciplina \u00e9 SuperComputa\u00e7\u00e3o. Honre esse nome ao escolher tamanhos de vetores.","title":"Projeto 0 - revis\u00e3o de C++"},{"location":"aulas/02-stl/","text":"02 - Templates e STL \u00b6 Esta pr\u00e1tica consiste primariamente em aprender a usar tipos de dados complexos disponibilizados pela STL e pela biblioteca padr\u00e3o de C++. A atividade principal desta pr\u00e1tica consiste em modificar o exerc\u00edcio da aula passada para usar as estruturas de dados e fun\u00e7\u00f5es da STL. Smart Pointers \u00b6 Uma das grandes dificuldades de desenvolver em C++ \u00e9 evitar vazamentos de mem\u00f3ria (memory leaks). Durante o desenvolvimento do programa \u00e9 muito usado o recurso de aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria, contudo da mesma forma que o programador tem a responsabilidade de alocar a mem\u00f3ria, ele tem de desalocar a mem\u00f3ria. Os smart pointers s\u00e3o uma estrat\u00e9gia de evitar que voc\u00ea esque\u00e7a de desalocar e crie um programa devorador de mem\u00f3ria. Os smart pointers percebem que uma mem\u00f3ria alocada n\u00e3o \u00e9 mais acess\u00edvel e desaloca a mem\u00f3ria. unique_ptr : um smart pointer para um \u00fanico objeto com um dono s\u00f3. Ou seja, este smart pointer aponta para um objeto que deve ter s\u00f3 um apontamento de cada vez. Ao realizarmos atribui\u00e7\u00f5es a vari\u00e1vel \"dono\" do objeto muda. shared_ptr : Um smart pointer para um \u00fanico objeto e pode ter v\u00e1rios donos. Ou seja, este smart pointer aponta para um objeto que pode ter v\u00e1rios apontamentos de cada vez. Ao realizarmos atribui\u00e7\u00f5es adicionamos uma nova refer\u00eancia a este dado. Quando n\u00e3o existem mais refer\u00eancias o dado \u00e9 automaticamente liberado usando delete Example O programa abaixo ( tarefa1.cpp ) tem problemas de mem\u00f3ria devido a aloca\u00e7\u00e3o feita na fun\u00e7\u00e3o cria_vetor e n\u00e3o liberada a cada itera\u00e7\u00e3o do for. Conserte o programa usando shared_ptr para que a mem\u00f3ria alocada por cria_vetor seja liberada automaticamente. #include <iostream> #include <memory> #include <vector> double * cria_vetor ( int n ) { double * ptr = new double [ n ]; for ( int i = 0 ; i < n ; i ++ ) { prt [ i ] = 0.0 ; } return ptr ; } void processa ( double * ptr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { ptr [ i ] *= 2 ; } } int main () { std :: cout << \"Hello! \\n \" ; for ( int i = 0 ; i < 10 ; i ++ ) { double * vec = cria_vetor ( 1000 ); processa ( vec , 1000 ); // vetor n\u00e3o \u00e9 deletado no fim do main! } return 0 ; } Strings e Vector \u00b6 Nesta se\u00e7\u00e3o iremos trabalhar com dois conteiners muito usados da STL: string e vector . O objetivo \u00e9 acostum\u00e1-los a consultar a documenta\u00e7\u00e3o de C++ e entend\u00ea-la com autonomia. A STL tem uma quantidade enorme de recursos e aprender a pesquisar como us\u00e1-los \u00e9 importante para sua profici\u00eancia. Example Fa\u00e7a um programa que l\u00ea uma linha de texto (usando std::getline ) e procure nela todas as ocorr\u00eancias da palavra \"hello\". Voc\u00ea dever\u00e1 implementar uma fun\u00e7\u00e3o std::vector<int> find_all(std::string text, std::string term); que devolve um vetor com a posi\u00e7\u00e3o de todas as ocorr\u00eancias de term em text . Sua fun\u00e7\u00e3o main dever\u00e1 mostrar os resultados da busca de maneira bem formatada. Projeto 0 - adicionando STL \u00b6 O c\u00f3digo produzido na \u00faltima aula parece muito com c\u00f3digo C e usa muito pouco dos recursos introduzidos em C++ para tornar nossos programas mais leg\u00edveis e f\u00e1ceis de escrever. Example Modifique sua fun\u00e7\u00e3o gera_vetor para usar std::vector ao inv\u00e9s de arrays puros e para usar o cabe\u00e7alho <random> . A distribui\u00e7\u00e3o usada dever\u00e1 ser uniforme real com limites 5 a 27. Example Modifique todas as fun\u00e7\u00f5es ( log , sqrt , pow3 , pow3mult e sum ) para receber std::vector . Note que voc\u00ea n\u00e3o precisa mais receber como argumento o tamanho do vetor. Question Qual dever\u00e1 ser a assinatura das fun\u00e7\u00f5es acima para evitar que ocorra c\u00f3pia do std::vector ? Example Continuando o exerc\u00edcio acima, use iteradores para percorrer seu std::vector . Para deixar o c\u00f3digo mais leg\u00edvel use auto Vamos agora trabalhar com programa\u00e7\u00e3o funcional em C++ para tornar nosso c\u00f3digo menor: armazenamento de refer\u00eancias para fun\u00e7\u00f5es em vari\u00e1veis e defini\u00e7\u00e3o de fun\u00e7\u00f5es usando lambda . Podemos definir fun\u00e7\u00f5es no meio de nosso programa usando a seguinte sintaxe: [ &|= ] ( argumentos ) -> retorno { corpo da fun\u00e7\u00e3o aqui }; Uma fun\u00e7\u00e3o definida desta maneira pode usar as vari\u00e1veis locais dispon\u00edveis no momento em que ela foi declarada (mesmo que n\u00e3o sejam passadas como argumento). A primeira parte da declara\u00e7\u00e3o define se essas vari\u00e1veis ser\u00e3o copiadas [=] ou se uma refer\u00eancia para elas ser\u00e1 utilizada na fun\u00e7\u00e3o [&] . O restante segue padr\u00f5es normalmente usados em C++ . Podemos inclusive, passar essas fun\u00e7\u00f5es como argumentos e devolv\u00ea-las como resultado de fun\u00e7\u00f5es. Para isto usamos o tipo std::function dispon\u00edvel no cabe\u00e7alho functional . Os exerc\u00edcios abaixo foram extra\u00eddos do arquivo exemplos-lambda.cpp . Fa\u00e7a-os e cheque seus resultados rodando o programa. Se houver d\u00favida chame o professor. Question Qual \u00e9 o resultado do c\u00f3digo abaixo? int c = 2 ; std :: function < double ( int ) > by_two = [ = ]( int n ) { return double ( n ) / c ; }; std :: cout << by_two ( 5 ) << \" \\n \" ; Question Qual \u00e9 o resultado do c\u00f3digo abaixo? int c = 2 ; std :: function < double ( int ) > by_c = [ & ]( int n ) { return double ( n ) / c ; }; std :: cout << by_c ( 7 ) << \" \\n \" ; c = 3 ; std :: cout << by_c ( 7 ) << \" \\n \" ; Question Escreva abaixo o tipo de uma vari\u00e1vel que guarda refer\u00eancia para as fun\u00e7\u00f5es que testamos neste exerc\u00edcio log sqrt pow3 pow3mult sum Example Crie uma fun\u00e7\u00e3o std::vector<double> teste_incremental( tipo aqui ) que recebe um ponteiro para o tipo das fun\u00e7\u00f5es acima e executa a fun\u00e7\u00e3o recebida com tamanhos de vetores incrementalmente maiores. Sua fun\u00e7\u00e3o dever\u00e1 devolver os tempos (em segundos) para todas as execu\u00e7\u00f5es feitas. Ou seja, a fun\u00e7\u00e3o teste_incremental dever\u00e1 funcionar como uma \"casquinha\" que gera vetores, roda as fun\u00e7\u00f5es matem\u00e1ticas testadas e retorna seus tempos de execu\u00e7\u00e3o. Example voc\u00ea deve ter notado que a fun\u00e7\u00e3o sum n\u00e3o possui a mesma assinatura das outras. Use uma fun\u00e7\u00e3o lambda para adaptar os tipos e usar a fun\u00e7\u00e3o acima para testar a fun\u00e7\u00e3o sum tamb\u00e9m.","title":"02 - Templates e STL"},{"location":"aulas/02-stl/#02-templates-e-stl","text":"Esta pr\u00e1tica consiste primariamente em aprender a usar tipos de dados complexos disponibilizados pela STL e pela biblioteca padr\u00e3o de C++. A atividade principal desta pr\u00e1tica consiste em modificar o exerc\u00edcio da aula passada para usar as estruturas de dados e fun\u00e7\u00f5es da STL.","title":"02 - Templates e STL"},{"location":"aulas/02-stl/#smart-pointers","text":"Uma das grandes dificuldades de desenvolver em C++ \u00e9 evitar vazamentos de mem\u00f3ria (memory leaks). Durante o desenvolvimento do programa \u00e9 muito usado o recurso de aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria, contudo da mesma forma que o programador tem a responsabilidade de alocar a mem\u00f3ria, ele tem de desalocar a mem\u00f3ria. Os smart pointers s\u00e3o uma estrat\u00e9gia de evitar que voc\u00ea esque\u00e7a de desalocar e crie um programa devorador de mem\u00f3ria. Os smart pointers percebem que uma mem\u00f3ria alocada n\u00e3o \u00e9 mais acess\u00edvel e desaloca a mem\u00f3ria. unique_ptr : um smart pointer para um \u00fanico objeto com um dono s\u00f3. Ou seja, este smart pointer aponta para um objeto que deve ter s\u00f3 um apontamento de cada vez. Ao realizarmos atribui\u00e7\u00f5es a vari\u00e1vel \"dono\" do objeto muda. shared_ptr : Um smart pointer para um \u00fanico objeto e pode ter v\u00e1rios donos. Ou seja, este smart pointer aponta para um objeto que pode ter v\u00e1rios apontamentos de cada vez. Ao realizarmos atribui\u00e7\u00f5es adicionamos uma nova refer\u00eancia a este dado. Quando n\u00e3o existem mais refer\u00eancias o dado \u00e9 automaticamente liberado usando delete Example O programa abaixo ( tarefa1.cpp ) tem problemas de mem\u00f3ria devido a aloca\u00e7\u00e3o feita na fun\u00e7\u00e3o cria_vetor e n\u00e3o liberada a cada itera\u00e7\u00e3o do for. Conserte o programa usando shared_ptr para que a mem\u00f3ria alocada por cria_vetor seja liberada automaticamente. #include <iostream> #include <memory> #include <vector> double * cria_vetor ( int n ) { double * ptr = new double [ n ]; for ( int i = 0 ; i < n ; i ++ ) { prt [ i ] = 0.0 ; } return ptr ; } void processa ( double * ptr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { ptr [ i ] *= 2 ; } } int main () { std :: cout << \"Hello! \\n \" ; for ( int i = 0 ; i < 10 ; i ++ ) { double * vec = cria_vetor ( 1000 ); processa ( vec , 1000 ); // vetor n\u00e3o \u00e9 deletado no fim do main! } return 0 ; }","title":"Smart Pointers"},{"location":"aulas/02-stl/#strings-e-vector","text":"Nesta se\u00e7\u00e3o iremos trabalhar com dois conteiners muito usados da STL: string e vector . O objetivo \u00e9 acostum\u00e1-los a consultar a documenta\u00e7\u00e3o de C++ e entend\u00ea-la com autonomia. A STL tem uma quantidade enorme de recursos e aprender a pesquisar como us\u00e1-los \u00e9 importante para sua profici\u00eancia. Example Fa\u00e7a um programa que l\u00ea uma linha de texto (usando std::getline ) e procure nela todas as ocorr\u00eancias da palavra \"hello\". Voc\u00ea dever\u00e1 implementar uma fun\u00e7\u00e3o std::vector<int> find_all(std::string text, std::string term); que devolve um vetor com a posi\u00e7\u00e3o de todas as ocorr\u00eancias de term em text . Sua fun\u00e7\u00e3o main dever\u00e1 mostrar os resultados da busca de maneira bem formatada.","title":"Strings e Vector"},{"location":"aulas/02-stl/#projeto-0-adicionando-stl","text":"O c\u00f3digo produzido na \u00faltima aula parece muito com c\u00f3digo C e usa muito pouco dos recursos introduzidos em C++ para tornar nossos programas mais leg\u00edveis e f\u00e1ceis de escrever. Example Modifique sua fun\u00e7\u00e3o gera_vetor para usar std::vector ao inv\u00e9s de arrays puros e para usar o cabe\u00e7alho <random> . A distribui\u00e7\u00e3o usada dever\u00e1 ser uniforme real com limites 5 a 27. Example Modifique todas as fun\u00e7\u00f5es ( log , sqrt , pow3 , pow3mult e sum ) para receber std::vector . Note que voc\u00ea n\u00e3o precisa mais receber como argumento o tamanho do vetor. Question Qual dever\u00e1 ser a assinatura das fun\u00e7\u00f5es acima para evitar que ocorra c\u00f3pia do std::vector ? Example Continuando o exerc\u00edcio acima, use iteradores para percorrer seu std::vector . Para deixar o c\u00f3digo mais leg\u00edvel use auto Vamos agora trabalhar com programa\u00e7\u00e3o funcional em C++ para tornar nosso c\u00f3digo menor: armazenamento de refer\u00eancias para fun\u00e7\u00f5es em vari\u00e1veis e defini\u00e7\u00e3o de fun\u00e7\u00f5es usando lambda . Podemos definir fun\u00e7\u00f5es no meio de nosso programa usando a seguinte sintaxe: [ &|= ] ( argumentos ) -> retorno { corpo da fun\u00e7\u00e3o aqui }; Uma fun\u00e7\u00e3o definida desta maneira pode usar as vari\u00e1veis locais dispon\u00edveis no momento em que ela foi declarada (mesmo que n\u00e3o sejam passadas como argumento). A primeira parte da declara\u00e7\u00e3o define se essas vari\u00e1veis ser\u00e3o copiadas [=] ou se uma refer\u00eancia para elas ser\u00e1 utilizada na fun\u00e7\u00e3o [&] . O restante segue padr\u00f5es normalmente usados em C++ . Podemos inclusive, passar essas fun\u00e7\u00f5es como argumentos e devolv\u00ea-las como resultado de fun\u00e7\u00f5es. Para isto usamos o tipo std::function dispon\u00edvel no cabe\u00e7alho functional . Os exerc\u00edcios abaixo foram extra\u00eddos do arquivo exemplos-lambda.cpp . Fa\u00e7a-os e cheque seus resultados rodando o programa. Se houver d\u00favida chame o professor. Question Qual \u00e9 o resultado do c\u00f3digo abaixo? int c = 2 ; std :: function < double ( int ) > by_two = [ = ]( int n ) { return double ( n ) / c ; }; std :: cout << by_two ( 5 ) << \" \\n \" ; Question Qual \u00e9 o resultado do c\u00f3digo abaixo? int c = 2 ; std :: function < double ( int ) > by_c = [ & ]( int n ) { return double ( n ) / c ; }; std :: cout << by_c ( 7 ) << \" \\n \" ; c = 3 ; std :: cout << by_c ( 7 ) << \" \\n \" ; Question Escreva abaixo o tipo de uma vari\u00e1vel que guarda refer\u00eancia para as fun\u00e7\u00f5es que testamos neste exerc\u00edcio log sqrt pow3 pow3mult sum Example Crie uma fun\u00e7\u00e3o std::vector<double> teste_incremental( tipo aqui ) que recebe um ponteiro para o tipo das fun\u00e7\u00f5es acima e executa a fun\u00e7\u00e3o recebida com tamanhos de vetores incrementalmente maiores. Sua fun\u00e7\u00e3o dever\u00e1 devolver os tempos (em segundos) para todas as execu\u00e7\u00f5es feitas. Ou seja, a fun\u00e7\u00e3o teste_incremental dever\u00e1 funcionar como uma \"casquinha\" que gera vetores, roda as fun\u00e7\u00f5es matem\u00e1ticas testadas e retorna seus tempos de execu\u00e7\u00e3o. Example voc\u00ea deve ter notado que a fun\u00e7\u00e3o sum n\u00e3o possui a mesma assinatura das outras. Use uma fun\u00e7\u00e3o lambda para adaptar os tipos e usar a fun\u00e7\u00e3o acima para testar a fun\u00e7\u00e3o sum tamb\u00e9m.","title":"Projeto 0 - adicionando STL"},{"location":"aulas/03-cmake/","text":"03 - CMake e Debugging no VSCode \u00b6 At\u00e9 o momento todos nossos arquivos eram compilados em uma s\u00f3 linha usando g++ . Conforme projetos ficam maiores e s\u00e3o divididos em v\u00e1rios m\u00f3dulos isto se torna invi\u00e1vel. Neste roteiro iremos usar o CMake, uma ferramenta de gerenciamento de projetos em C++. No fim, iremos configurar o VSCode para abrir projetos CMake. Aten\u00e7\u00e3o Usar ferramentas adequadas aumenta consideravelmente a produtividade e tamb\u00e9m facilita encontrar erros no c\u00f3digo. A partir desta aula ser\u00e1 obrigat\u00f3rio j\u00e1 ter debugado o programa antes de tirar d\u00favidas. Gerenciamento de projetos com CMake \u00b6 O CMake \u00e9 uma das ferramentas mais usadas para gerenciar projetos C/C++. Outras ferramentas comumente usadas s\u00e3o ninja e meson . Em CMake , um projeto \u00e9 definido por um arquivo nomeado CMakeLists.txt . Este arquivo cont\u00e9m defini\u00e7\u00f5es como nome do projeto, quais depend\u00eancias (bibliotecas externas e subprojetos) s\u00e3o usadas e o quais arquivos ser\u00e3o gerados pelo projeto. Cada arquivo gerado \u00e9 chamado de target na nomenclatura usada pelo CMake e pode ser um execut\u00e1vel ou uma biblioteca (est\u00e1tica ou din\u00e2mica). Um arquivo CMakeLists.txt b\u00e1sico pode conter apenas tr\u00eas linhas (pasta 03-cmake ): cmake_minimum_required(VERSION 3.10) project (projeto_basico) add_executable(hello hello.cpp) Este arquivo somente descreve o projeto. Para efetivamente compilarmos o programa precisamos passar pela fase de configura\u00e7\u00e3o , em que o CMake checa se todas as depend\u00eancias foram encontradas e se os compiladores necess\u00e1rios est\u00e3o instalados. Se tudo estiver em ordem podemos gerar um Makefile (para Linux) ou um projeto do Visual Studio (para Windows). Para fazer a configura\u00e7\u00e3o do projeto basta rodar o comando cmake mais o caminho para a pasta do projeto. Voc\u00ea s\u00f3 precisar\u00e1 refazer a configura\u00e7\u00e3o do projeto se modificar o arquivo CMakeLists.txt . \u00c9 boa pr\u00e1tica fazer a compila\u00e7\u00e3o do c\u00f3digo em uma pasta separada, como na sequ\u00eancia de comandos abaixo. mkdir build cd build cmake .. Estes comandos devem ter gerado uma s\u00e9rie de arquivos na pasta build , incluindo um Makefile . Para compilar o projeto basta rodar make E um execut\u00e1vel de nome hello dever\u00e1 aparecer na pasta build . Exerc\u00edcio Crie um arquivo CMakeLists.txt para o projeto 0. Voc\u00ea dever\u00e1 adicionar um target chamado vector_ops . Exerc\u00edcio Separe as fun\u00e7\u00f5es matem\u00e1ticas testadas em arquivos .cpp/h e use-os no seu projeto. A diretiva add_executable aceita v\u00e1rios arquivos .cpp para criar um execut\u00e1vel. Op\u00e7\u00f5es de compila\u00e7\u00e3o \u00b6 Al\u00e9m da cria\u00e7\u00e3o de execut\u00e1veis o CMake tamb\u00e9m permite adicionar op\u00e7\u00f5es de compila\u00e7\u00e3o espec\u00edficas para cada target com a diretiva target_compile_options . No contexto desta mat\u00e9ria isto ser\u00e1 especialmente interessante pois o g++ oferece flags para ativar otimiza\u00e7\u00f5es que podem melhorar significativamente o desempenho de nosso programa. Portanto, podemos facilmente compilar o mesmo programa com e sem otimiza\u00e7\u00f5es no mesmo projeto! O exemplo abaixo ativa a flag O3 no target hello criado no exemplo anterior. target_compile_options(hello PUBLIC -O3) Podemos tamb\u00e9m usar #define para fazer compila\u00e7\u00e3o condicional do nosso c\u00f3digo. Usar a diretiva abaixo equivale e colocar um #define OPT no topo de cada arquivo do target hello . target_compile_definitions(hello PUBLIC OPT) Exerc\u00edcio Modifique seu target vector_ops para que ele use a op\u00e7\u00e3o de compila\u00e7\u00e3o O2 . Exerc\u00edcio Crie um novo target vector_ops_no_opt que compile os mesmos arquivos de vector_ops mas use a op\u00e7\u00e3o de compila\u00e7\u00e3o O0 . Projeto 0 - Benchmarking e compara\u00e7\u00f5es de desempenho \u00b6 Vamos agora fazer um pequeno resumo dos resultados dos experimentos. Este resumo dever\u00e1 conter os seguintes itens e dever\u00e1 ser entregue em formato PDF . uma breve descri\u00e7\u00e3o do programa testado (um par\u00e1grafo); os nomes dos execut\u00e1veis testados e qual a diferen\u00e7a entre eles os tamanhos de entrada usados e a m\u00e1quina usada para seus testes gr\u00e1ficos ilustrando a diferen\u00e7a de desempenho para cada fun\u00e7\u00e3o testada coment\u00e1rios sobre os resultados mostrados nos gr\u00e1ficos Dicas \u00b6 Ferramentas como PWeave ou Jupyter Notebook ajudam muito a criar textos que misturam c\u00f3digo para criar gr\u00e1ficos, rodar programas automaticamente e interpretar sua sa\u00edda. Tente automatizar o m\u00e1ximo poss\u00edvel a gera\u00e7\u00e3o de gr\u00e1ficos de desempenho. Isso facilitar\u00e1 muito sua vida em projetos posteriores. Extra 01 - Debugando seu projeto \u00b6 Agora iremos abrir nosso projeto um ambiente de desenvolvimento em vez de continuar trabalhando na linha de comando. Adotaremos o VSCode como ambiente padr\u00e3o. O VSCode n\u00e3o vem com suporte por padr\u00e3o a projetos CMake, mas a extens\u00e3o Cmake Tools possui um bom suporte. Instale-a e carregue o projeto. A extens\u00e3o possui uma documenta\u00e7\u00e3o tanto para a etapa de configura\u00e7\u00e3o e compila\u00e7\u00e3o quanto para execu\u00e7\u00e3o dos programas e debugging . Para executar os programas voc\u00ea pode usar a op\u00e7\u00e3o \"Run in terminal\" dispon\u00edvel no menu do bot\u00e3o direito de cada target . Supondo que a etapa anterior funcionou, vamos agora rodar o nosso programa usando um debugger. Isto permite parar a execu\u00e7\u00e3o no meio do programa e examinar o valor das vari\u00e1veis. coloque um ou mais breakpoints no c\u00f3digo. Basta clicar ao lado do n\u00famero da linha. Um c\u00edrculo vermelho indica que a execu\u00e7\u00e3o ser\u00e1 interrompida quando chegar nesta linha. bot\u00e3o direito no target -> \"Run with debugger\". quando o programa parar teremos as seguintes op\u00e7\u00f5es: Continue : roda at\u00e9 o pr\u00f3ximo breakpoint Step Over : roda a linha atual e passa para a pr\u00f3xima. Step Into : se a linha atual tem uma chamada de fun\u00e7\u00e3o, continua o debug dentro da fun\u00e7\u00e3o chamada. Step Out : executa at\u00e9 o fim da fun\u00e7\u00e3o atual e para logo ap\u00f3s o retorno. Tamb\u00e9m podemos colocar o mouse em cima de cada vari\u00e1vel para ver seu valor. O explorador de vari\u00e1veis (que mostra todas as v\u00e1lidas na fun\u00e7\u00e3o atual) aparece no painel esquerdo, dentro da view debug . Exerc\u00edcio Abra sua atividade e rode-a com o debugger. Pause a execu\u00e7\u00e3o no meio e verifique os tempos de execu\u00e7\u00e3o.","title":"03 - CMake e Debugging no VSCode"},{"location":"aulas/03-cmake/#03-cmake-e-debugging-no-vscode","text":"At\u00e9 o momento todos nossos arquivos eram compilados em uma s\u00f3 linha usando g++ . Conforme projetos ficam maiores e s\u00e3o divididos em v\u00e1rios m\u00f3dulos isto se torna invi\u00e1vel. Neste roteiro iremos usar o CMake, uma ferramenta de gerenciamento de projetos em C++. No fim, iremos configurar o VSCode para abrir projetos CMake. Aten\u00e7\u00e3o Usar ferramentas adequadas aumenta consideravelmente a produtividade e tamb\u00e9m facilita encontrar erros no c\u00f3digo. A partir desta aula ser\u00e1 obrigat\u00f3rio j\u00e1 ter debugado o programa antes de tirar d\u00favidas.","title":"03 - CMake e Debugging no VSCode"},{"location":"aulas/03-cmake/#gerenciamento-de-projetos-com-cmake","text":"O CMake \u00e9 uma das ferramentas mais usadas para gerenciar projetos C/C++. Outras ferramentas comumente usadas s\u00e3o ninja e meson . Em CMake , um projeto \u00e9 definido por um arquivo nomeado CMakeLists.txt . Este arquivo cont\u00e9m defini\u00e7\u00f5es como nome do projeto, quais depend\u00eancias (bibliotecas externas e subprojetos) s\u00e3o usadas e o quais arquivos ser\u00e3o gerados pelo projeto. Cada arquivo gerado \u00e9 chamado de target na nomenclatura usada pelo CMake e pode ser um execut\u00e1vel ou uma biblioteca (est\u00e1tica ou din\u00e2mica). Um arquivo CMakeLists.txt b\u00e1sico pode conter apenas tr\u00eas linhas (pasta 03-cmake ): cmake_minimum_required(VERSION 3.10) project (projeto_basico) add_executable(hello hello.cpp) Este arquivo somente descreve o projeto. Para efetivamente compilarmos o programa precisamos passar pela fase de configura\u00e7\u00e3o , em que o CMake checa se todas as depend\u00eancias foram encontradas e se os compiladores necess\u00e1rios est\u00e3o instalados. Se tudo estiver em ordem podemos gerar um Makefile (para Linux) ou um projeto do Visual Studio (para Windows). Para fazer a configura\u00e7\u00e3o do projeto basta rodar o comando cmake mais o caminho para a pasta do projeto. Voc\u00ea s\u00f3 precisar\u00e1 refazer a configura\u00e7\u00e3o do projeto se modificar o arquivo CMakeLists.txt . \u00c9 boa pr\u00e1tica fazer a compila\u00e7\u00e3o do c\u00f3digo em uma pasta separada, como na sequ\u00eancia de comandos abaixo. mkdir build cd build cmake .. Estes comandos devem ter gerado uma s\u00e9rie de arquivos na pasta build , incluindo um Makefile . Para compilar o projeto basta rodar make E um execut\u00e1vel de nome hello dever\u00e1 aparecer na pasta build . Exerc\u00edcio Crie um arquivo CMakeLists.txt para o projeto 0. Voc\u00ea dever\u00e1 adicionar um target chamado vector_ops . Exerc\u00edcio Separe as fun\u00e7\u00f5es matem\u00e1ticas testadas em arquivos .cpp/h e use-os no seu projeto. A diretiva add_executable aceita v\u00e1rios arquivos .cpp para criar um execut\u00e1vel.","title":"Gerenciamento de projetos com CMake"},{"location":"aulas/03-cmake/#opcoes-de-compilacao","text":"Al\u00e9m da cria\u00e7\u00e3o de execut\u00e1veis o CMake tamb\u00e9m permite adicionar op\u00e7\u00f5es de compila\u00e7\u00e3o espec\u00edficas para cada target com a diretiva target_compile_options . No contexto desta mat\u00e9ria isto ser\u00e1 especialmente interessante pois o g++ oferece flags para ativar otimiza\u00e7\u00f5es que podem melhorar significativamente o desempenho de nosso programa. Portanto, podemos facilmente compilar o mesmo programa com e sem otimiza\u00e7\u00f5es no mesmo projeto! O exemplo abaixo ativa a flag O3 no target hello criado no exemplo anterior. target_compile_options(hello PUBLIC -O3) Podemos tamb\u00e9m usar #define para fazer compila\u00e7\u00e3o condicional do nosso c\u00f3digo. Usar a diretiva abaixo equivale e colocar um #define OPT no topo de cada arquivo do target hello . target_compile_definitions(hello PUBLIC OPT) Exerc\u00edcio Modifique seu target vector_ops para que ele use a op\u00e7\u00e3o de compila\u00e7\u00e3o O2 . Exerc\u00edcio Crie um novo target vector_ops_no_opt que compile os mesmos arquivos de vector_ops mas use a op\u00e7\u00e3o de compila\u00e7\u00e3o O0 .","title":"Op\u00e7\u00f5es de compila\u00e7\u00e3o"},{"location":"aulas/03-cmake/#projeto-0-benchmarking-e-comparacoes-de-desempenho","text":"Vamos agora fazer um pequeno resumo dos resultados dos experimentos. Este resumo dever\u00e1 conter os seguintes itens e dever\u00e1 ser entregue em formato PDF . uma breve descri\u00e7\u00e3o do programa testado (um par\u00e1grafo); os nomes dos execut\u00e1veis testados e qual a diferen\u00e7a entre eles os tamanhos de entrada usados e a m\u00e1quina usada para seus testes gr\u00e1ficos ilustrando a diferen\u00e7a de desempenho para cada fun\u00e7\u00e3o testada coment\u00e1rios sobre os resultados mostrados nos gr\u00e1ficos","title":"Projeto 0 - Benchmarking e compara\u00e7\u00f5es de desempenho"},{"location":"aulas/03-cmake/#dicas","text":"Ferramentas como PWeave ou Jupyter Notebook ajudam muito a criar textos que misturam c\u00f3digo para criar gr\u00e1ficos, rodar programas automaticamente e interpretar sua sa\u00edda. Tente automatizar o m\u00e1ximo poss\u00edvel a gera\u00e7\u00e3o de gr\u00e1ficos de desempenho. Isso facilitar\u00e1 muito sua vida em projetos posteriores.","title":"Dicas"},{"location":"aulas/03-cmake/#extra-01-debugando-seu-projeto","text":"Agora iremos abrir nosso projeto um ambiente de desenvolvimento em vez de continuar trabalhando na linha de comando. Adotaremos o VSCode como ambiente padr\u00e3o. O VSCode n\u00e3o vem com suporte por padr\u00e3o a projetos CMake, mas a extens\u00e3o Cmake Tools possui um bom suporte. Instale-a e carregue o projeto. A extens\u00e3o possui uma documenta\u00e7\u00e3o tanto para a etapa de configura\u00e7\u00e3o e compila\u00e7\u00e3o quanto para execu\u00e7\u00e3o dos programas e debugging . Para executar os programas voc\u00ea pode usar a op\u00e7\u00e3o \"Run in terminal\" dispon\u00edvel no menu do bot\u00e3o direito de cada target . Supondo que a etapa anterior funcionou, vamos agora rodar o nosso programa usando um debugger. Isto permite parar a execu\u00e7\u00e3o no meio do programa e examinar o valor das vari\u00e1veis. coloque um ou mais breakpoints no c\u00f3digo. Basta clicar ao lado do n\u00famero da linha. Um c\u00edrculo vermelho indica que a execu\u00e7\u00e3o ser\u00e1 interrompida quando chegar nesta linha. bot\u00e3o direito no target -> \"Run with debugger\". quando o programa parar teremos as seguintes op\u00e7\u00f5es: Continue : roda at\u00e9 o pr\u00f3ximo breakpoint Step Over : roda a linha atual e passa para a pr\u00f3xima. Step Into : se a linha atual tem uma chamada de fun\u00e7\u00e3o, continua o debug dentro da fun\u00e7\u00e3o chamada. Step Out : executa at\u00e9 o fim da fun\u00e7\u00e3o atual e para logo ap\u00f3s o retorno. Tamb\u00e9m podemos colocar o mouse em cima de cada vari\u00e1vel para ver seu valor. O explorador de vari\u00e1veis (que mostra todas as v\u00e1lidas na fun\u00e7\u00e3o atual) aparece no painel esquerdo, dentro da view debug . Exerc\u00edcio Abra sua atividade e rode-a com o debugger. Pause a execu\u00e7\u00e3o no meio e verifique os tempos de execu\u00e7\u00e3o.","title":"Extra 01 - Debugando seu projeto"},{"location":"aulas/04-autovec/","text":"04 - SIMD: Autovetoriza\u00e7\u00e3o \u00b6 Programas de fazer c\u00e1lculos podem ser acelerados significativamente por instru\u00e7\u00f5es SIMD ( Single Instruction Multiple Data ). Neste contexto, a utiliza\u00e7\u00e3o de compiladores com op\u00e7\u00e3o de autovetoriza\u00e7\u00e3o \u00e9 muito conveniente: se o c\u00f3digo compilado tiver algumas caracter\u00edsticas o compilador \u00e9 capaz utilizar estas instru\u00e7\u00f5es automaticamente e melhorar muito o desempenho sem que um programador precise modificar c\u00f3digo. Um guia para autovetoriza\u00e7\u00e3o usando gcc pode ser encontrado em sua documenta\u00e7\u00e3o . Info Os exerc\u00edcios de aula podem ser feitos em dupla. Capacidade dos registradores \u00b6 Question Levando em conta que a arquitetura AVX armazena dados em registradores de 128 bits , podemos armazenar em um \u00fanico registrador at\u00e9: ____ chars; ____ shorts; ____ ints; ____ longs; ____ floats; ____ doubles; Question A arquitetura AVX2 suporta registradores de 256 bits . Isto significa que c\u00f3digo autovetorizado com instru\u00e7\u00f5es AVX2 pode ser at\u00e9 ____ vezes mais r\u00e1pido do que c\u00f3digo vetorizado com AVX Question Toda instru\u00e7\u00e3o SIMD opera sobre todos os elementos guardados ao mesmo tempo. Ou seja, ao executar uma instru\u00e7\u00e3o SIMD de soma de vari\u00e1veis int no registrador %xmm0 estarei somando ____ vari\u00e1veis em uma s\u00f3 instru\u00e7\u00e3o. Instru\u00e7\u00f5es vetoriais \u00b6 Vamos agora compilar alguns c\u00f3digos em C++ para Assembly usando as op\u00e7\u00f5es -ffast-math -ftree-vectorize -mavx do gcc . Estas op\u00e7\u00f5es habilitam a autovetoriza\u00e7\u00e3o de c\u00f3digo. Ou sejam elas analisam o c\u00f3digo e procuram substituir loops e acessos sequenciais a vetores por instru\u00e7\u00f5es SIMD que fa\u00e7am o mesmo trabalho. A flag -mavx indica que o c\u00f3digo de m\u00e1quina gerado pode utilizar instru\u00e7\u00f5es SIMD da arquitetura AVX (e de sua predecessora, SSE), que usa registradores de 128 bits nomeados %xmm0 at\u00e9 %xmm7 e de 256 bits nomeados %ymm0 at\u00e9 %ymm15 . Vamos agora analisar o c\u00f3digo Assembly de uma fun\u00e7\u00e3o simples que soma todos elementos de um vetor. // Original: Nicolas Brailovsky #define SIZE (400) long sum ( long v [ SIZE ]) { long s = 0 ; for ( long i = 0 ; i < SIZE ; i ++ ) s += v [ i ]; return s ; } Example Compile este c\u00f3digo com otimiza\u00e7\u00f5es b\u00e1sicas ( -O2 ) $ g++ -S -c -O2 tarefa1.cpp -o /dev/stdout | c++filt Agora adicione autovetoriza\u00e7\u00e3o (com as flags listadas acima) $ g++ -S -c -O2 -ffast-math -ftree-vectorize -mavx tarefa1.cpp -o /dev/stdout | c++filt Question Compare as instru\u00e7\u00f5es Assembly geradas acima e escreva abaixo as diferen\u00e7as percebidas. Voc\u00ea consegue explicar seu funcionamento? Aplicando autovetoriza\u00e7\u00e3o \u00b6 Nesta tarefa iremos trabalhar com as op\u00e7\u00f5es de autovetoriza\u00e7\u00e3o do gcc para entender como escrever c\u00f3digo que possa ser otimizado automaticamente. Example Escreva uma fun\u00e7\u00e3o main que gera um vetor de tamanho 10.000.000 contendo n\u00fameros aleat\u00f3rios uniformemente distribu\u00eddos entre -10 e 10 . Use as fun\u00e7\u00f5es do cabe\u00e7alho <random> . Example Escreva uma fun\u00e7\u00e3o double soma_positivos1(double *a, int n) que soma todos os n\u00fameros positivos do vetor a . Adicione uma chamada a esta fun\u00e7\u00e3o no seu main e use as fun\u00e7\u00f5es do cabe\u00e7alho <chrono> para medir o tempo de execu\u00e7\u00e3o da sua fun\u00e7\u00e3o. Neste exerc\u00edcio voc\u00ea dever\u00e1 usar um if para checar se os n\u00fameros s\u00e3o positivos. Question Compile com e sem as otimiza\u00e7\u00f5es SIMD e escreva abaixo os tempos de execu\u00e7\u00e3o. O auto vetorizador suporta uma s\u00e9rie de padr\u00f5es de codifica\u00e7\u00e3o relativamente abrangente ( lista completa ). Por\u00e9m, c\u00f3digos que s\u00e3o vetorizados de maneira id\u00eantica podem possuir desempenho bastante diferente quanto a vetoriza\u00e7\u00e3o n\u00e3o est\u00e1 habilitada. Example Fa\u00e7a uma fun\u00e7\u00e3o double soma_positivos2(double *a, int n) que faz o mesmo que a fun\u00e7\u00e3o anterior, mas usando agora o operador tern\u00e1rio (cond)?expr_true:expr_false ao inv\u00e9s de um if . (Se voc\u00ea fez com o operador tern\u00e1rio acima fa\u00e7a com if ). Houve diferen\u00e7a de desempenho na vers\u00e3o SIMD? E na vers\u00e3o sem SIMD? Question Complete a tabela abaixo com os tempos obtidos - SIMD sem SIMD if-else tern\u00e1rio Exerc\u00edcio Qual vers\u00e3o da fun\u00e7\u00e3o anterior voc\u00ea usaria se seu c\u00f3digo fosse executado em processadores de baixo custo (Intel Celeron) ou muito antigos (mais de 5 anos)? E se o plano for executar em processadores novos? Projeto 0 - aplicando autovetoriza\u00e7\u00e3o \u00b6 Warning Os exerc\u00edcios do Projeto 0 s\u00e3o individuais. Nas \u00faltimas duas tarefas vimos como usar as op\u00e7\u00f5es do compilador para gerar instru\u00e7\u00f5es SIMD, tornando nossos programas mais eficientes. Agora vamos aplic\u00e1-las ao nosso exemplo dos experimentos. Voc\u00ea dever\u00e1 criar um novo target vector_ops_simd com as op\u00e7\u00f5es de compila\u00e7\u00e3o SIMD e a flag de otimiza\u00e7\u00e3o O3 atualizar seus gr\u00e1ficos de desempenho com o novo experimento comentar os novos resultados, respondendo \u00e0s seguintes perguntas: A partir de qual tamanho de array o c\u00f3digo vetorizado mostra ganhos de desempenho expressivos? Qual \u00e9 o ganho de desempenho esperado? Leve em conta a arquitetura usada e o tipo de dados usado. Os ganhos de desempenho s\u00e3o consistentes com o esperado?","title":"04 - SIMD: Autovetoriza\u00e7\u00e3o"},{"location":"aulas/04-autovec/#04-simd-autovetorizacao","text":"Programas de fazer c\u00e1lculos podem ser acelerados significativamente por instru\u00e7\u00f5es SIMD ( Single Instruction Multiple Data ). Neste contexto, a utiliza\u00e7\u00e3o de compiladores com op\u00e7\u00e3o de autovetoriza\u00e7\u00e3o \u00e9 muito conveniente: se o c\u00f3digo compilado tiver algumas caracter\u00edsticas o compilador \u00e9 capaz utilizar estas instru\u00e7\u00f5es automaticamente e melhorar muito o desempenho sem que um programador precise modificar c\u00f3digo. Um guia para autovetoriza\u00e7\u00e3o usando gcc pode ser encontrado em sua documenta\u00e7\u00e3o . Info Os exerc\u00edcios de aula podem ser feitos em dupla.","title":"04 - SIMD: Autovetoriza\u00e7\u00e3o"},{"location":"aulas/04-autovec/#capacidade-dos-registradores","text":"Question Levando em conta que a arquitetura AVX armazena dados em registradores de 128 bits , podemos armazenar em um \u00fanico registrador at\u00e9: ____ chars; ____ shorts; ____ ints; ____ longs; ____ floats; ____ doubles; Question A arquitetura AVX2 suporta registradores de 256 bits . Isto significa que c\u00f3digo autovetorizado com instru\u00e7\u00f5es AVX2 pode ser at\u00e9 ____ vezes mais r\u00e1pido do que c\u00f3digo vetorizado com AVX Question Toda instru\u00e7\u00e3o SIMD opera sobre todos os elementos guardados ao mesmo tempo. Ou seja, ao executar uma instru\u00e7\u00e3o SIMD de soma de vari\u00e1veis int no registrador %xmm0 estarei somando ____ vari\u00e1veis em uma s\u00f3 instru\u00e7\u00e3o.","title":"Capacidade dos registradores"},{"location":"aulas/04-autovec/#instrucoes-vetoriais","text":"Vamos agora compilar alguns c\u00f3digos em C++ para Assembly usando as op\u00e7\u00f5es -ffast-math -ftree-vectorize -mavx do gcc . Estas op\u00e7\u00f5es habilitam a autovetoriza\u00e7\u00e3o de c\u00f3digo. Ou sejam elas analisam o c\u00f3digo e procuram substituir loops e acessos sequenciais a vetores por instru\u00e7\u00f5es SIMD que fa\u00e7am o mesmo trabalho. A flag -mavx indica que o c\u00f3digo de m\u00e1quina gerado pode utilizar instru\u00e7\u00f5es SIMD da arquitetura AVX (e de sua predecessora, SSE), que usa registradores de 128 bits nomeados %xmm0 at\u00e9 %xmm7 e de 256 bits nomeados %ymm0 at\u00e9 %ymm15 . Vamos agora analisar o c\u00f3digo Assembly de uma fun\u00e7\u00e3o simples que soma todos elementos de um vetor. // Original: Nicolas Brailovsky #define SIZE (400) long sum ( long v [ SIZE ]) { long s = 0 ; for ( long i = 0 ; i < SIZE ; i ++ ) s += v [ i ]; return s ; } Example Compile este c\u00f3digo com otimiza\u00e7\u00f5es b\u00e1sicas ( -O2 ) $ g++ -S -c -O2 tarefa1.cpp -o /dev/stdout | c++filt Agora adicione autovetoriza\u00e7\u00e3o (com as flags listadas acima) $ g++ -S -c -O2 -ffast-math -ftree-vectorize -mavx tarefa1.cpp -o /dev/stdout | c++filt Question Compare as instru\u00e7\u00f5es Assembly geradas acima e escreva abaixo as diferen\u00e7as percebidas. Voc\u00ea consegue explicar seu funcionamento?","title":"Instru\u00e7\u00f5es vetoriais"},{"location":"aulas/04-autovec/#aplicando-autovetorizacao","text":"Nesta tarefa iremos trabalhar com as op\u00e7\u00f5es de autovetoriza\u00e7\u00e3o do gcc para entender como escrever c\u00f3digo que possa ser otimizado automaticamente. Example Escreva uma fun\u00e7\u00e3o main que gera um vetor de tamanho 10.000.000 contendo n\u00fameros aleat\u00f3rios uniformemente distribu\u00eddos entre -10 e 10 . Use as fun\u00e7\u00f5es do cabe\u00e7alho <random> . Example Escreva uma fun\u00e7\u00e3o double soma_positivos1(double *a, int n) que soma todos os n\u00fameros positivos do vetor a . Adicione uma chamada a esta fun\u00e7\u00e3o no seu main e use as fun\u00e7\u00f5es do cabe\u00e7alho <chrono> para medir o tempo de execu\u00e7\u00e3o da sua fun\u00e7\u00e3o. Neste exerc\u00edcio voc\u00ea dever\u00e1 usar um if para checar se os n\u00fameros s\u00e3o positivos. Question Compile com e sem as otimiza\u00e7\u00f5es SIMD e escreva abaixo os tempos de execu\u00e7\u00e3o. O auto vetorizador suporta uma s\u00e9rie de padr\u00f5es de codifica\u00e7\u00e3o relativamente abrangente ( lista completa ). Por\u00e9m, c\u00f3digos que s\u00e3o vetorizados de maneira id\u00eantica podem possuir desempenho bastante diferente quanto a vetoriza\u00e7\u00e3o n\u00e3o est\u00e1 habilitada. Example Fa\u00e7a uma fun\u00e7\u00e3o double soma_positivos2(double *a, int n) que faz o mesmo que a fun\u00e7\u00e3o anterior, mas usando agora o operador tern\u00e1rio (cond)?expr_true:expr_false ao inv\u00e9s de um if . (Se voc\u00ea fez com o operador tern\u00e1rio acima fa\u00e7a com if ). Houve diferen\u00e7a de desempenho na vers\u00e3o SIMD? E na vers\u00e3o sem SIMD? Question Complete a tabela abaixo com os tempos obtidos - SIMD sem SIMD if-else tern\u00e1rio Exerc\u00edcio Qual vers\u00e3o da fun\u00e7\u00e3o anterior voc\u00ea usaria se seu c\u00f3digo fosse executado em processadores de baixo custo (Intel Celeron) ou muito antigos (mais de 5 anos)? E se o plano for executar em processadores novos?","title":"Aplicando autovetoriza\u00e7\u00e3o"},{"location":"aulas/04-autovec/#projeto-0-aplicando-autovetorizacao","text":"Warning Os exerc\u00edcios do Projeto 0 s\u00e3o individuais. Nas \u00faltimas duas tarefas vimos como usar as op\u00e7\u00f5es do compilador para gerar instru\u00e7\u00f5es SIMD, tornando nossos programas mais eficientes. Agora vamos aplic\u00e1-las ao nosso exemplo dos experimentos. Voc\u00ea dever\u00e1 criar um novo target vector_ops_simd com as op\u00e7\u00f5es de compila\u00e7\u00e3o SIMD e a flag de otimiza\u00e7\u00e3o O3 atualizar seus gr\u00e1ficos de desempenho com o novo experimento comentar os novos resultados, respondendo \u00e0s seguintes perguntas: A partir de qual tamanho de array o c\u00f3digo vetorizado mostra ganhos de desempenho expressivos? Qual \u00e9 o ganho de desempenho esperado? Leve em conta a arquitetura usada e o tipo de dados usado. Os ganhos de desempenho s\u00e3o consistentes com o esperado?","title":"Projeto 0 - aplicando autovetoriza\u00e7\u00e3o"},{"location":"aulas/05-intro-multi-core/","text":"05 - Introdu\u00e7\u00e3o a multi-core \u00b6 Fonte: https://en.wikipedia.org/wiki/File:Fork_join.svg Como visto em aula, o modelo fork-join segue tr\u00eas passos b\u00e1sicos: Dividir o problema em peda\u00e7os Resolver cada peda\u00e7o individualmente Juntar as respostas parciais em um resultado final Vamos criar uma implementa\u00e7\u00e3o raiz desse modelo usando threads em C++11. Parte 1 - o cabe\u00e7alho thread \u00b6 Nesta parte iremos aprender a criar threads e esperar sua finaliza\u00e7\u00e3o usando C++11 std::threads . Veja abaixo um exemplo com as fun\u00e7\u00f5es que precisaremos usar (arquivo exemplo1-threads.cpp ). #include <thread> #include <iostream> void funcao_rodando_em_paralelo ( int a , int * b ) { std :: cout << \"a=\" << a << std :: endl ; * b = 5 ; } int main () { int b = 10 ; // Cria thread e a executa. // Primeiro argumento \u00e9 a fun\u00e7\u00e3o a ser executada. // Os argumentos em seguida s\u00e3o passados diretamente // para a fun\u00e7\u00e3o passada no primeiro argumento. std :: thread t1 ( funcao_rodando_em_paralelo , 15 , & b ); std :: cout << \"Antes do join b=\" << b << std :: endl ; // Espera at\u00e9 que a fun\u00e7\u00e3o acabe de executar. t1 . join (); std :: cout << \"Depois do join b=\" << b << std :: endl ; } Example Compile e roda o programa acima. Voc\u00ea precisar\u00e1 passar a flag -pthread para o g++ . O resultado \u00e9 o esperado? Example Modifique o programa acima para criar 4 threads e atribuir a cada uma um id de 0 a 3. Cada thread deve executar uma fun\u00e7\u00e3o que imprime \"Thread: \" + id. (Voc\u00ea precisa ainda da vari\u00e1vel int *b ?) Question Pesquise como detectar o m\u00e1ximo de threads de hardware e incorpore esta informa\u00e7\u00e3o no seu programa acima. Ele dever\u00e1 criar este n\u00famero de threads. Escreva a chamada usada abaixo. Example Modifique seu programa acima para retornar um o id da thread ao quadrado. Como voc\u00ea faria isto? Como voc\u00ea guardaria essa informa\u00e7\u00e3o no main ? Dica : exemplo1-threads.cpp faz isso com a vari\u00e1vel b . Example Fa\u00e7a sua fun\u00e7\u00e3o main mostrar a soma dos quadrados dos valores recebidos no item anterior. Parte 2 - paralelizando uma opera\u00e7\u00e3o de complexa \u00b6 Vamos agora paralelizar um problema mais complexo: o c\u00e1lculo do pi . O arquivo pi-numeric-integration.cpp cont\u00e9m uma implementa\u00e7\u00e3o sequencial usando a t\u00e9cnica de integra\u00e7\u00e3o num\u00e9rica vista nos slides. Seu trabalho ser\u00e1: dividir o trabalho desta fun\u00e7\u00e3o em 4 threads, cada uma computando uma parte da sequ\u00eancia salvar os resultados parciais de cada thread em um elemento de um vetor criado no main somar os resultados parciais. Seu programa dever\u00e1 apresentar resultado similar ao programa sequencial, mas funcionar em aproximadamente um quarto do tempo. Warning Este trabalho est\u00e1 com uma descri\u00e7\u00e3o vaga de prop\u00f3sito. \u00c9 parte dos objetivos entender o c\u00f3digo sequencial dado como exemplo e como dividir os trabalhos entre as threads.","title":"05 - Introdu\u00e7\u00e3o a multi-core"},{"location":"aulas/05-intro-multi-core/#05-introducao-a-multi-core","text":"Fonte: https://en.wikipedia.org/wiki/File:Fork_join.svg Como visto em aula, o modelo fork-join segue tr\u00eas passos b\u00e1sicos: Dividir o problema em peda\u00e7os Resolver cada peda\u00e7o individualmente Juntar as respostas parciais em um resultado final Vamos criar uma implementa\u00e7\u00e3o raiz desse modelo usando threads em C++11.","title":"05 - Introdu\u00e7\u00e3o a multi-core"},{"location":"aulas/05-intro-multi-core/#parte-1-o-cabecalho-thread","text":"Nesta parte iremos aprender a criar threads e esperar sua finaliza\u00e7\u00e3o usando C++11 std::threads . Veja abaixo um exemplo com as fun\u00e7\u00f5es que precisaremos usar (arquivo exemplo1-threads.cpp ). #include <thread> #include <iostream> void funcao_rodando_em_paralelo ( int a , int * b ) { std :: cout << \"a=\" << a << std :: endl ; * b = 5 ; } int main () { int b = 10 ; // Cria thread e a executa. // Primeiro argumento \u00e9 a fun\u00e7\u00e3o a ser executada. // Os argumentos em seguida s\u00e3o passados diretamente // para a fun\u00e7\u00e3o passada no primeiro argumento. std :: thread t1 ( funcao_rodando_em_paralelo , 15 , & b ); std :: cout << \"Antes do join b=\" << b << std :: endl ; // Espera at\u00e9 que a fun\u00e7\u00e3o acabe de executar. t1 . join (); std :: cout << \"Depois do join b=\" << b << std :: endl ; } Example Compile e roda o programa acima. Voc\u00ea precisar\u00e1 passar a flag -pthread para o g++ . O resultado \u00e9 o esperado? Example Modifique o programa acima para criar 4 threads e atribuir a cada uma um id de 0 a 3. Cada thread deve executar uma fun\u00e7\u00e3o que imprime \"Thread: \" + id. (Voc\u00ea precisa ainda da vari\u00e1vel int *b ?) Question Pesquise como detectar o m\u00e1ximo de threads de hardware e incorpore esta informa\u00e7\u00e3o no seu programa acima. Ele dever\u00e1 criar este n\u00famero de threads. Escreva a chamada usada abaixo. Example Modifique seu programa acima para retornar um o id da thread ao quadrado. Como voc\u00ea faria isto? Como voc\u00ea guardaria essa informa\u00e7\u00e3o no main ? Dica : exemplo1-threads.cpp faz isso com a vari\u00e1vel b . Example Fa\u00e7a sua fun\u00e7\u00e3o main mostrar a soma dos quadrados dos valores recebidos no item anterior.","title":"Parte 1 - o cabe\u00e7alho thread"},{"location":"aulas/05-intro-multi-core/#parte-2-paralelizando-uma-operacao-de-complexa","text":"Vamos agora paralelizar um problema mais complexo: o c\u00e1lculo do pi . O arquivo pi-numeric-integration.cpp cont\u00e9m uma implementa\u00e7\u00e3o sequencial usando a t\u00e9cnica de integra\u00e7\u00e3o num\u00e9rica vista nos slides. Seu trabalho ser\u00e1: dividir o trabalho desta fun\u00e7\u00e3o em 4 threads, cada uma computando uma parte da sequ\u00eancia salvar os resultados parciais de cada thread em um elemento de um vetor criado no main somar os resultados parciais. Seu programa dever\u00e1 apresentar resultado similar ao programa sequencial, mas funcionar em aproximadamente um quarto do tempo. Warning Este trabalho est\u00e1 com uma descri\u00e7\u00e3o vaga de prop\u00f3sito. \u00c9 parte dos objetivos entender o c\u00f3digo sequencial dado como exemplo e como dividir os trabalhos entre as threads.","title":"Parte 2 - paralelizando uma opera\u00e7\u00e3o de complexa"},{"location":"aulas/06-intro-openmp/","text":"06 - Introdu\u00e7\u00e3o a OpenMP \u00b6 OpenMP \u00e9 uma tecnologia de computa\u00e7\u00e3o multi-core usada para paralelizar programas de modo facilitado. Ele \u00e9 ideal para programar programas que usem o modelo fork-join que estudaremos nesta primeira parte do curso. Fonte: https://en.wikipedia.org/wiki/File:Fork_join.svg Parte 0 - primeiros usos \u00b6 Nesta parte do roteiro usaremos 4 chamadas do OpenMP para recriar o primeiro exemplo da aula passada. #pragma omp parallel cria um conjunto de threads. Deve ser aplicado acima de um bloco de c\u00f3digo limitado por { } int omp_get_num_threads(); retorna o n\u00famero de threads criadas (dentro de uma regi\u00e3o paralela) int omp_get_max_threads(); retorna o n\u00famero de m\u00e1ximo de threads (fora de uma regi\u00e3o paralela) int omp_get_thread_num(); retorna o id da thread atual (entre 0 e o valor acima, dentro de uma regi\u00e3o paralela) O c\u00f3digo abaixo ( exemplo1.c ) ilustra como utilizar OpenMP para fazer o exercicio 1 do roteiro anterior (criar 4 threads e imprimir um id de 0 a 3). #include <iostream> #include <omp.h> int main () { #pragma omp parallel { std :: cout << \"ID:\" << omp_get_thread_num () << \"/\" << omp_get_num_threads () << \" \\n \" ; } std :: cout << \"Join implicito no fim do bloco!\" << \" \\n \" ; return 0 ; } Perceba que a principal utilidade do OpenMP \u00e9 facilitar a programa\u00e7\u00e3o quando todas as threads rodam o mesmo programa e a cria\u00e7\u00e3o de threads e a jun\u00e7\u00e3o de seus resultados ocorre de maneira frequente no programa. Example Compile o programa abaixo usando a seguinte linha de comando e rode-o. $ g++ -O3 exemplo1.cpp -o exemplo1 -fopenmp Question O OpenMP permite alterar o n\u00famero m\u00e1ximo de threads criados usando a vari\u00e1vel de ambiente OMP_NUM_THREADS . Rode exemplo1 como abaixo. OMP_NUM_THREADS=2 ./exemplo1 Os resultados foram os esperados? Rode agora sem a vari\u00e1vel de ambiente. Qual \u00e9 o valor padr\u00e3o assumido pelo OpenMP? \u00c9 uma boa ideia usar mais threads que o valor padr\u00e3o? A utiliza\u00e7\u00e3o de OMP_NUM_THREADS ajuda a realizar testes de modo a compreender os ganhos de desempenho de um programa conforme mais threads s\u00e3o utilizadas. Parte 1 - funcionalidades do OpenMP \u00b6 Vamos continuar usando o exemplo pi-numeric-integration.cpp neste roteiro. Iremos comparar nosso programa da aula passada com implementa\u00e7\u00f5es usando OpenMP. Example Refatore sua implementa\u00e7\u00e3o da aula passada para que todo seu c\u00f3digo usando threads esteja dispon\u00edvel em um fun\u00e7\u00e3o double_pi_threads_raiz(long steps) e que o c\u00f3digo original esteja em uma fun\u00e7\u00e3o double pi_seq(long steps) . Example Chame ambas fun\u00e7\u00f5es no main e compare seus resultados e o tempo necess\u00e1rio para cada uma rodar. Note Verifique que a vers\u00e3o usando threads demora um quarto do tempo da vers\u00e3o sequencial. Vamos agora fazer um primeiro teste usando OpenMP. No exerc\u00edcio abaixo vamos somente substituir a cria\u00e7\u00e3o das threads usando <threads> pela cria\u00e7\u00e3o usando diretivas do OpenMP. Example Crie uma fun\u00e7\u00e3o double pi_omp_parallel(long steps) que fa\u00e7a o c\u00e1lculo do pi de modo paralelo usando #pragma omp parallel . Siga a mesma receita do seu programa usando threads: As itera\u00e7\u00f5es do for s\u00e3o divididas por igual entre as threads; Cada thread acumula seus resultados parciais armazenados em um vetor double sum[] . Para efeitos de exerc\u00edcio, use a constru\u00e7\u00e3o sum[id] += No fim os resultados parciais s\u00e3o usados para o c\u00e1lculo final. Adicione uma chamada a esta fun\u00e7\u00e3o no main e mostre seu resultado e o tempo gasto. J\u00e1 vimos que acessar a mesma vari\u00e1vel (ou posi\u00e7\u00e3o em um vetor) resulta em resultados incorretos. Por quest\u00f5es de cache, escrever em posi\u00e7\u00f5es vizinhas de um vetor resulta em desempenho longe do ideal. Podemos arrumar isto criando uma vari\u00e1vel local para acumular a soma e s\u00f3 escrever seu resultado no vetor double sum[] no fim. Example Crie uma fun\u00e7\u00e3o double pi_omp_parallel_local(long steps) que, ao inv\u00e9s de fazer sum[id] += use uma vari\u00e1vel local para guardar a soma e fa\u00e7a a atribui\u00e7\u00e3o somente no fim da se\u00e7\u00e3o paralela. Como antes, adicione uma chamada ao main e verifique se houve ganho de desempenho. Sincroniza\u00e7\u00e3o \u00b6 O OpenMP nos permite eliminar o vetor double sum[] usando diretivas de sincroniza\u00e7\u00e3o de alto n\u00edvel. As duas mais simples s\u00e3o atomic e critical . A diretiva atomic executa uma atribui\u00e7\u00e3o ou uma opera\u00e7\u00e3o aritm\u00e9tica inplace ( +=, -=, *=, /= ) garantindo que ela ser\u00e1 conclu\u00edda mesmo se outros cores tentarem faz\u00ea-la. Question Como voc\u00ea poderia eliminar o vetor double sum[] usado nos exerc\u00edcios anteriores usando atomic ? Example Fa\u00e7a uma fun\u00e7\u00e3o double pi_omp_parallel_atomic(long steps) usando esta diretiva, adicione-a no main e mostre seu resultado e o tempo gasto. Dever\u00e1 haver ganho de desempenho. A diretiva critical \u00e9 aplicada a um bloco e faz com que ele esteja em execu\u00e7\u00e3o em no m\u00e1ximo 1 das threads. Este nome vem do conceito de se\u00e7\u00e3o cr\u00edtica , que representa uma se\u00e7\u00e3o de uma tarefa que n\u00e3o pode ser paralelizada de jeito algum e obrigatoriamente deve ser executada de modo sequencial. O uso de critical \u00e9 muito perigoso, pois ao for\u00e7ar a execu\u00e7\u00e3o sequencial de um bloco de c\u00f3digo podemos estar efetivamente matando o paralelismo do nosso programa. A constru\u00e7\u00e3o atomic \u00e9 uma se\u00e7\u00e3o cr\u00edtica de apenas uma linha e usa suporte do hardware para rodar. A constru\u00e7\u00e3o critical permite serializar v\u00e1rias linhas de c\u00f3digo, mas exige suporte do Sistema Operacional e \u00e9 bastante lenta. Example Fa\u00e7a uma fun\u00e7\u00e3o double pi_omp_parallel_critical(long steps) usando esta diretiva, adicione-a no main e mostre seu resultado e o tempo gasto. A implementa\u00e7\u00e3o correta dever\u00e1 ficar praticamente igual ao atomic . Example Vamos agora fazer uma implementa\u00e7\u00e3o errada de critical . Na vers\u00e3o anterior usamos uma vari\u00e1vel local para cada armazenar os resultados parciais de cada thread. Troque seu uso para armazenar na vari\u00e1vel de fora da se\u00e7\u00e3o paralela usando critical . Chame esta fun\u00e7\u00e3o de double pi_omp_parallel_critical_errado(long steps) . Adicione-a no main e mostre seu resultado e o tempo gasto. O resultado final dever\u00e1 ser pior que suas outras vers\u00f5es. Neste momento voc\u00ea deve ter obtido um programa com desempenho ao menos cerca de 50% mais r\u00e1pido que o programa original. Mais importante, seu programa agora \u00e9 muito mais simples de ler (e escrever) do que usando diretamente std::thread . Na pr\u00f3xima aula veremos como simplificar ainda mais estes c\u00f3digos usando constru\u00e7\u00f5es de alto n\u00edvel do OpenMP.","title":"06 - Introdu\u00e7\u00e3o a OpenMP"},{"location":"aulas/06-intro-openmp/#06-introducao-a-openmp","text":"OpenMP \u00e9 uma tecnologia de computa\u00e7\u00e3o multi-core usada para paralelizar programas de modo facilitado. Ele \u00e9 ideal para programar programas que usem o modelo fork-join que estudaremos nesta primeira parte do curso. Fonte: https://en.wikipedia.org/wiki/File:Fork_join.svg","title":"06 - Introdu\u00e7\u00e3o a OpenMP"},{"location":"aulas/06-intro-openmp/#parte-0-primeiros-usos","text":"Nesta parte do roteiro usaremos 4 chamadas do OpenMP para recriar o primeiro exemplo da aula passada. #pragma omp parallel cria um conjunto de threads. Deve ser aplicado acima de um bloco de c\u00f3digo limitado por { } int omp_get_num_threads(); retorna o n\u00famero de threads criadas (dentro de uma regi\u00e3o paralela) int omp_get_max_threads(); retorna o n\u00famero de m\u00e1ximo de threads (fora de uma regi\u00e3o paralela) int omp_get_thread_num(); retorna o id da thread atual (entre 0 e o valor acima, dentro de uma regi\u00e3o paralela) O c\u00f3digo abaixo ( exemplo1.c ) ilustra como utilizar OpenMP para fazer o exercicio 1 do roteiro anterior (criar 4 threads e imprimir um id de 0 a 3). #include <iostream> #include <omp.h> int main () { #pragma omp parallel { std :: cout << \"ID:\" << omp_get_thread_num () << \"/\" << omp_get_num_threads () << \" \\n \" ; } std :: cout << \"Join implicito no fim do bloco!\" << \" \\n \" ; return 0 ; } Perceba que a principal utilidade do OpenMP \u00e9 facilitar a programa\u00e7\u00e3o quando todas as threads rodam o mesmo programa e a cria\u00e7\u00e3o de threads e a jun\u00e7\u00e3o de seus resultados ocorre de maneira frequente no programa. Example Compile o programa abaixo usando a seguinte linha de comando e rode-o. $ g++ -O3 exemplo1.cpp -o exemplo1 -fopenmp Question O OpenMP permite alterar o n\u00famero m\u00e1ximo de threads criados usando a vari\u00e1vel de ambiente OMP_NUM_THREADS . Rode exemplo1 como abaixo. OMP_NUM_THREADS=2 ./exemplo1 Os resultados foram os esperados? Rode agora sem a vari\u00e1vel de ambiente. Qual \u00e9 o valor padr\u00e3o assumido pelo OpenMP? \u00c9 uma boa ideia usar mais threads que o valor padr\u00e3o? A utiliza\u00e7\u00e3o de OMP_NUM_THREADS ajuda a realizar testes de modo a compreender os ganhos de desempenho de um programa conforme mais threads s\u00e3o utilizadas.","title":"Parte 0 - primeiros usos"},{"location":"aulas/06-intro-openmp/#parte-1-funcionalidades-do-openmp","text":"Vamos continuar usando o exemplo pi-numeric-integration.cpp neste roteiro. Iremos comparar nosso programa da aula passada com implementa\u00e7\u00f5es usando OpenMP. Example Refatore sua implementa\u00e7\u00e3o da aula passada para que todo seu c\u00f3digo usando threads esteja dispon\u00edvel em um fun\u00e7\u00e3o double_pi_threads_raiz(long steps) e que o c\u00f3digo original esteja em uma fun\u00e7\u00e3o double pi_seq(long steps) . Example Chame ambas fun\u00e7\u00f5es no main e compare seus resultados e o tempo necess\u00e1rio para cada uma rodar. Note Verifique que a vers\u00e3o usando threads demora um quarto do tempo da vers\u00e3o sequencial. Vamos agora fazer um primeiro teste usando OpenMP. No exerc\u00edcio abaixo vamos somente substituir a cria\u00e7\u00e3o das threads usando <threads> pela cria\u00e7\u00e3o usando diretivas do OpenMP. Example Crie uma fun\u00e7\u00e3o double pi_omp_parallel(long steps) que fa\u00e7a o c\u00e1lculo do pi de modo paralelo usando #pragma omp parallel . Siga a mesma receita do seu programa usando threads: As itera\u00e7\u00f5es do for s\u00e3o divididas por igual entre as threads; Cada thread acumula seus resultados parciais armazenados em um vetor double sum[] . Para efeitos de exerc\u00edcio, use a constru\u00e7\u00e3o sum[id] += No fim os resultados parciais s\u00e3o usados para o c\u00e1lculo final. Adicione uma chamada a esta fun\u00e7\u00e3o no main e mostre seu resultado e o tempo gasto. J\u00e1 vimos que acessar a mesma vari\u00e1vel (ou posi\u00e7\u00e3o em um vetor) resulta em resultados incorretos. Por quest\u00f5es de cache, escrever em posi\u00e7\u00f5es vizinhas de um vetor resulta em desempenho longe do ideal. Podemos arrumar isto criando uma vari\u00e1vel local para acumular a soma e s\u00f3 escrever seu resultado no vetor double sum[] no fim. Example Crie uma fun\u00e7\u00e3o double pi_omp_parallel_local(long steps) que, ao inv\u00e9s de fazer sum[id] += use uma vari\u00e1vel local para guardar a soma e fa\u00e7a a atribui\u00e7\u00e3o somente no fim da se\u00e7\u00e3o paralela. Como antes, adicione uma chamada ao main e verifique se houve ganho de desempenho.","title":"Parte 1 - funcionalidades do OpenMP"},{"location":"aulas/06-intro-openmp/#sincronizacao","text":"O OpenMP nos permite eliminar o vetor double sum[] usando diretivas de sincroniza\u00e7\u00e3o de alto n\u00edvel. As duas mais simples s\u00e3o atomic e critical . A diretiva atomic executa uma atribui\u00e7\u00e3o ou uma opera\u00e7\u00e3o aritm\u00e9tica inplace ( +=, -=, *=, /= ) garantindo que ela ser\u00e1 conclu\u00edda mesmo se outros cores tentarem faz\u00ea-la. Question Como voc\u00ea poderia eliminar o vetor double sum[] usado nos exerc\u00edcios anteriores usando atomic ? Example Fa\u00e7a uma fun\u00e7\u00e3o double pi_omp_parallel_atomic(long steps) usando esta diretiva, adicione-a no main e mostre seu resultado e o tempo gasto. Dever\u00e1 haver ganho de desempenho. A diretiva critical \u00e9 aplicada a um bloco e faz com que ele esteja em execu\u00e7\u00e3o em no m\u00e1ximo 1 das threads. Este nome vem do conceito de se\u00e7\u00e3o cr\u00edtica , que representa uma se\u00e7\u00e3o de uma tarefa que n\u00e3o pode ser paralelizada de jeito algum e obrigatoriamente deve ser executada de modo sequencial. O uso de critical \u00e9 muito perigoso, pois ao for\u00e7ar a execu\u00e7\u00e3o sequencial de um bloco de c\u00f3digo podemos estar efetivamente matando o paralelismo do nosso programa. A constru\u00e7\u00e3o atomic \u00e9 uma se\u00e7\u00e3o cr\u00edtica de apenas uma linha e usa suporte do hardware para rodar. A constru\u00e7\u00e3o critical permite serializar v\u00e1rias linhas de c\u00f3digo, mas exige suporte do Sistema Operacional e \u00e9 bastante lenta. Example Fa\u00e7a uma fun\u00e7\u00e3o double pi_omp_parallel_critical(long steps) usando esta diretiva, adicione-a no main e mostre seu resultado e o tempo gasto. A implementa\u00e7\u00e3o correta dever\u00e1 ficar praticamente igual ao atomic . Example Vamos agora fazer uma implementa\u00e7\u00e3o errada de critical . Na vers\u00e3o anterior usamos uma vari\u00e1vel local para cada armazenar os resultados parciais de cada thread. Troque seu uso para armazenar na vari\u00e1vel de fora da se\u00e7\u00e3o paralela usando critical . Chame esta fun\u00e7\u00e3o de double pi_omp_parallel_critical_errado(long steps) . Adicione-a no main e mostre seu resultado e o tempo gasto. O resultado final dever\u00e1 ser pior que suas outras vers\u00f5es. Neste momento voc\u00ea deve ter obtido um programa com desempenho ao menos cerca de 50% mais r\u00e1pido que o programa original. Mais importante, seu programa agora \u00e9 muito mais simples de ler (e escrever) do que usando diretamente std::thread . Na pr\u00f3xima aula veremos como simplificar ainda mais estes c\u00f3digos usando constru\u00e7\u00f5es de alto n\u00edvel do OpenMP.","title":"Sincroniza\u00e7\u00e3o"},{"location":"aulas/07-openmp-for/","text":"07 - OpenMP: Constru\u00e7\u00f5es de alto n\u00edvel \u00b6 Agora que vimos as constru\u00e7\u00f5es de for paralelo e de redu\u00e7\u00e3o iremos aplic\u00e1-las no nosso exerc\u00edcio do c\u00e1lculo do pi. Por tr\u00e1s dos panos essas constru\u00e7\u00f5es fazem o mesmo trabalho dos c\u00f3digos que criamos anteriormente, por\u00e9m n\u00e3o precisamos escrever tanto c\u00f3digo. Example Modifique sua solu\u00e7\u00e3o para usar as constru\u00e7\u00f5es parallel for e reduce . Coloque seu resultado na fun\u00e7\u00e3o double pi_omp_for(long steps) . Seus resultados se mantiveram iguais? Se seu exerc\u00edcio deu certo voc\u00ea deve ter obtido tempos compar\u00e1veis com as melhores implementa\u00e7\u00f5es anteriores, por\u00e9m seu programa atual \u00e9 praticamente igual ao sequencial. Esta \u00e9 a principal vantagem de trabalhar com OpenMP: com poucas modifica\u00e7\u00f5es conseguimos transformar um c\u00f3digo sequencial em um programa paralelo. Paralelizando um programa j\u00e1 existente. \u00b6 A atividade hoje ser\u00e1 debugar um programa paralelo que deu errado! Curiosidade : fractais s\u00e3o estruturas matem\u00e1ticas que s\u00e3o definidas por sua auto-similaridade. Eles s\u00e3o \u00fateis para modelar objetos e fen\u00f4menos que possuem as mesmas caracter\u00edsticas em escalas completamente diferentes, como nuvens, montanhas e compress\u00e3o de arquivos . O arquivo mandel.cpp tem uma implementa\u00e7\u00e3o que calcula a \u00e1rea abaixo do Fractal de Mandelbrot . Foi feita uma tentativa pregui\u00e7osa de paraleliza\u00e7\u00e3o usando OpenMP que est\u00e1 dando resultados muito estranhos. Example Este c\u00f3digo tem problemas de compartilhamento indevido de dados. Voc\u00ea dever\u00e1 modificar o pragma que paraleliza o for para que n\u00e3o haja compartilhamento indevido de vari\u00e1veis. verificar se existe compartilhamento n\u00e3o intencional das vari\u00e1veis globais e arrumar, caso necess\u00e1rio. Voc\u00ea deve modificar o programa o m\u00ednimo poss\u00edvel Teoria - Efeitos colaterais \u00b6 Dizemos que quando uma fun\u00e7\u00e3o escreve/l\u00ea em vari\u00e1veis globais (ou static ) ela possui efeitos colaterais . Ou seja, ap\u00f3s rodar ela modifica o estado do programa. Em compara\u00e7\u00e3o, uma fun\u00e7\u00e3o que s\u00f3 depende dos valores passados nos argumentos e n\u00e3o escreve seu resultado (ou valores intermedi\u00e1rios) em vari\u00e1veis globais \u00e9 dita sem efeitos colaterais . Este tipo de fun\u00e7\u00e3o pode ser chamado por v\u00e1rias threads simult\u00e2neamente e \u00e9 uma boa pr\u00e1tica de programa\u00e7\u00e3o paralela criar fun\u00e7\u00f5es sem efeitos colaterais. Example Apesar do programa agora funcionar, os erros do exerc\u00edcio acima eram causados essencialmente por m\u00e1s pr\u00e1ticas de programa\u00e7\u00e3o. Reestruture o c\u00f3digo para que o resultado de suas fun\u00e7\u00f5es s\u00f3 dependa dos valores passados nos argumentos. Isto costuma implicar na convers\u00e3o de valores lidos/escritos em vari\u00e1veis globais para valores passados nos par\u00e2metros da fun\u00e7\u00e3o. Neste exerc\u00edcio voc\u00ea pode mudar o programa extensamente, desde que os resultados continuem os mesmos.","title":"07 - OpenMP: Constru\u00e7\u00f5es de alto n\u00edvel"},{"location":"aulas/07-openmp-for/#07-openmp-construcoes-de-alto-nivel","text":"Agora que vimos as constru\u00e7\u00f5es de for paralelo e de redu\u00e7\u00e3o iremos aplic\u00e1-las no nosso exerc\u00edcio do c\u00e1lculo do pi. Por tr\u00e1s dos panos essas constru\u00e7\u00f5es fazem o mesmo trabalho dos c\u00f3digos que criamos anteriormente, por\u00e9m n\u00e3o precisamos escrever tanto c\u00f3digo. Example Modifique sua solu\u00e7\u00e3o para usar as constru\u00e7\u00f5es parallel for e reduce . Coloque seu resultado na fun\u00e7\u00e3o double pi_omp_for(long steps) . Seus resultados se mantiveram iguais? Se seu exerc\u00edcio deu certo voc\u00ea deve ter obtido tempos compar\u00e1veis com as melhores implementa\u00e7\u00f5es anteriores, por\u00e9m seu programa atual \u00e9 praticamente igual ao sequencial. Esta \u00e9 a principal vantagem de trabalhar com OpenMP: com poucas modifica\u00e7\u00f5es conseguimos transformar um c\u00f3digo sequencial em um programa paralelo.","title":"07 - OpenMP: Constru\u00e7\u00f5es de alto n\u00edvel"},{"location":"aulas/07-openmp-for/#paralelizando-um-programa-ja-existente","text":"A atividade hoje ser\u00e1 debugar um programa paralelo que deu errado! Curiosidade : fractais s\u00e3o estruturas matem\u00e1ticas que s\u00e3o definidas por sua auto-similaridade. Eles s\u00e3o \u00fateis para modelar objetos e fen\u00f4menos que possuem as mesmas caracter\u00edsticas em escalas completamente diferentes, como nuvens, montanhas e compress\u00e3o de arquivos . O arquivo mandel.cpp tem uma implementa\u00e7\u00e3o que calcula a \u00e1rea abaixo do Fractal de Mandelbrot . Foi feita uma tentativa pregui\u00e7osa de paraleliza\u00e7\u00e3o usando OpenMP que est\u00e1 dando resultados muito estranhos. Example Este c\u00f3digo tem problemas de compartilhamento indevido de dados. Voc\u00ea dever\u00e1 modificar o pragma que paraleliza o for para que n\u00e3o haja compartilhamento indevido de vari\u00e1veis. verificar se existe compartilhamento n\u00e3o intencional das vari\u00e1veis globais e arrumar, caso necess\u00e1rio. Voc\u00ea deve modificar o programa o m\u00ednimo poss\u00edvel","title":"Paralelizando um programa j\u00e1 existente."},{"location":"aulas/07-openmp-for/#teoria-efeitos-colaterais","text":"Dizemos que quando uma fun\u00e7\u00e3o escreve/l\u00ea em vari\u00e1veis globais (ou static ) ela possui efeitos colaterais . Ou seja, ap\u00f3s rodar ela modifica o estado do programa. Em compara\u00e7\u00e3o, uma fun\u00e7\u00e3o que s\u00f3 depende dos valores passados nos argumentos e n\u00e3o escreve seu resultado (ou valores intermedi\u00e1rios) em vari\u00e1veis globais \u00e9 dita sem efeitos colaterais . Este tipo de fun\u00e7\u00e3o pode ser chamado por v\u00e1rias threads simult\u00e2neamente e \u00e9 uma boa pr\u00e1tica de programa\u00e7\u00e3o paralela criar fun\u00e7\u00f5es sem efeitos colaterais. Example Apesar do programa agora funcionar, os erros do exerc\u00edcio acima eram causados essencialmente por m\u00e1s pr\u00e1ticas de programa\u00e7\u00e3o. Reestruture o c\u00f3digo para que o resultado de suas fun\u00e7\u00f5es s\u00f3 dependa dos valores passados nos argumentos. Isto costuma implicar na convers\u00e3o de valores lidos/escritos em vari\u00e1veis globais para valores passados nos par\u00e2metros da fun\u00e7\u00e3o. Neste exerc\u00edcio voc\u00ea pode mudar o programa extensamente, desde que os resultados continuem os mesmos.","title":"Teoria - Efeitos colaterais"},{"location":"aulas/08-efeitos-colaterais/","text":"08 - Efeitos colaterais \u00b6 Escrever c\u00f3digo sem efeitos colaterais pode render ganhos de desempenho significativos ao paralelizar programas. Conceito Uma fun\u00e7\u00e3o tem efeitos colaterais quando ela modifica dados que n\u00e3o s\u00e3o nem passados via argumentos nem retornados pela fun\u00e7\u00e3o. S\u00e3o exemplos desse tipo de dados: vari\u00e1veis globais vari\u00e1veis alocadas via malloc vari\u00e1veis apontadas por ponteiros Uma fun\u00e7\u00e3o sem efeitos colaterais recebe todos os seus argumentos por c\u00f3pia, os processa e devolve seu resultado exclusivamente via retorno da fun\u00e7\u00e3o. Ou seja, todas as outras vari\u00e1veis do programa mant\u00e9m o mesmo valor que tinham antes da chamada dessa fun\u00e7\u00e3o. Pela defini\u00e7\u00e3o acima, notamos que uma fun\u00e7\u00e3o sem efeitos colaterais pode ser chamada por v\u00e1rias threads ao mesmo tempo. Claramente isto \u00e9 uma vantagem, j\u00e1 que isto pode facilitar muito a paraleliza\u00e7\u00e3o de c\u00f3digo. Parte 0: analizando o c\u00f3digo existente \u00b6 Nesta parte do roteiro iremos analisar o c\u00f3digo exemplo, testar uma paraleliza\u00e7\u00e3o ing\u00eanua e identificar seus poss\u00edveis problemas de paraleliza\u00e7\u00e3o. Question Considerando somente o arquivo pi_mc.c , existe c\u00f3digo com efeitos colaterais? Example Fa\u00e7a uma paraleliza\u00e7\u00e3o ing\u00eanua deste c\u00f3digo. Example Teste a paraleliza\u00e7\u00e3o ing\u00eanua do exerc\u00edcio anterior. Ela retorna os mesmos resultados em todas execu\u00e7\u00f5es? Se n\u00e3o, comente por que isto \u00e9 um problema. Dado que n\u00e3o encontramos problemas no arquivo pi_mc.c , vamos olhar ent\u00e3o os arquivos random.c/h . Question Existe c\u00f3digo com efeitos colaterais? Liste as fun\u00e7\u00f5es encontradas. Question Voltando para pi_mc.c , onde s\u00e3o chamadas as fun\u00e7\u00f5es identificadas acima? Question Agora que voc\u00ea est\u00e1 familiarizado com todo o c\u00f3digo, explique por que os resultados s\u00e3o diferentes quando rodamos o c\u00f3digo ingenuamente paralelo. S\u00f3 prossiga ap\u00f3s validar as respostas do item anterior com o professor ou com um colega que j\u00e1 tenha finalizado esta parte. Parte 1: exclus\u00e3o m\u00fatua \u00b6 Identificamos na parte anterior que a fun\u00e7\u00e3o drandom possui efeitos colaterais e estes efeitos colaterais est\u00e3o atrapalhando a paraleliza\u00e7\u00e3o do c\u00f3digo. Esta implementa\u00e7\u00e3o \u00e9 parecida com as fun\u00e7\u00f5es do cabe\u00e7alho <random> : temos um estado do gerador de n\u00fameros que \u00e9 passado para toda fun\u00e7\u00e3o que faz sorteios. Neste caso, o resultado do pr\u00f3ximo n\u00famero sorteado depende dos valores globais MULTIPLIER , ADDEND , PMOD e da vari\u00e1vel est\u00e1tica random_last . Example Modifique o c\u00f3digo para que ele use as fun\u00e7\u00f5es de gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios usando <random> . Salve em pi_mc_random.cpp . Na aula 06 usamos omp critical para criar se\u00e7\u00f5es de exclus\u00e3o m\u00fatua em que somente uma das threads rode por vez. No nosso caso o problema ocorre com a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios: ao gerar um n\u00famero o estado interno do gerador se modifica. Logo, tem um problema de acessos concorrentes a mesma vari\u00e1vel. Question Partindo do c\u00f3digo sequencial, quais linhas precisariam ser protegidas de acessos concorrentes? Example Utilize omp for e omp critical para paralelizar o c\u00f3digo em pi_mc_random.cpp . Question Avalie seu c\u00f3digo em termos de desempenho obtido e facilidade de programa\u00e7\u00e3o Parte 2: paraleliza\u00e7\u00e3o das dist\u00e2ncias \u00b6 Na parte anterior eliminamos acessos concorrentes ao gerador de n\u00fameros aleat\u00f3rios. Isso seria equivalente a fazer todos os sorteios antes e depois fazer os c\u00e1lculos das dist\u00e2ncias. Ou seja, os c\u00e1lculos de dist\u00e2ncia s\u00e3o independentes desde que os sorteios aleat\u00f3rios j\u00e1 tenham sido feitos. Example Modifique pi_mc_random.cpp para que o sorteio dos pontos seja feito em um vetor antes do for que faz os c\u00e1lculos de dist\u00e2ncias. Question \u00c9 poss\u00edvel paralelizar o for que faz o sorteio dos n\u00fameros? E o que faz o c\u00e1lculo das dist\u00e2ncias? Example Com base em suas respostas do item acima, paralize o que for poss\u00edvel e salve em um arquivo pi_mc_par1.cpp Question Houve ganho de desempenho? Compare com o programa original. Esta estrat\u00e9gia \u00e9 muito comum em casos em que a tarefa de interesse pode ser decomposta em uma parte inerentemente sequencial e uma que pode ser paralelizada mas que depende dos resultados da parte sequencial. Se a parte paraleliz\u00e1vel for custosa essa estrat\u00e9gia pode trazer ganhos mesmo que o programa n\u00e3o seja inteiramente paraleliz\u00e1vel. Parte 3: partes independentes \u00b6 A segunda estrat\u00e9gia que usaremos \u00e9 criar um gerador de n\u00fameros aleat\u00f3rios para cada thread. Ou seja, cada thread precisar\u00e1: criar um gerador de n\u00fameros aleat\u00f3rios pr\u00f3prio acumular os resultados na mesma vari\u00e1vel de somar pontos. Note que esta estrat\u00e9gia n\u00e3o \u00e9 equivalente ao programa original: cada thread est\u00e1 seguindo uma sequ\u00eancia diferente de n\u00fameros aleat\u00f3rios. Example Reorganize seu c\u00f3digo (partindo de pi_mc_random.cpp ) para que cada thread crie seu pr\u00f3prio gerador de n\u00fameros aleat\u00f3rios e fa\u00e7a \u00bc das itera\u00e7\u00f5es originais. Salve seu trabalho em pi_mc_par2.c Question Compare o desempenho com o programa original. Parte 4 - compara\u00e7\u00e3o de desempenho final \u00b6 Compare o desempenho das duas abordagens de paraleliza\u00e7\u00e3o. Question Qual \u00e9 mais r\u00e1pida? Question Qual \u00e9 mais f\u00e1cil de ser entendida?","title":"08 - Efeitos colaterais"},{"location":"aulas/08-efeitos-colaterais/#08-efeitos-colaterais","text":"Escrever c\u00f3digo sem efeitos colaterais pode render ganhos de desempenho significativos ao paralelizar programas. Conceito Uma fun\u00e7\u00e3o tem efeitos colaterais quando ela modifica dados que n\u00e3o s\u00e3o nem passados via argumentos nem retornados pela fun\u00e7\u00e3o. S\u00e3o exemplos desse tipo de dados: vari\u00e1veis globais vari\u00e1veis alocadas via malloc vari\u00e1veis apontadas por ponteiros Uma fun\u00e7\u00e3o sem efeitos colaterais recebe todos os seus argumentos por c\u00f3pia, os processa e devolve seu resultado exclusivamente via retorno da fun\u00e7\u00e3o. Ou seja, todas as outras vari\u00e1veis do programa mant\u00e9m o mesmo valor que tinham antes da chamada dessa fun\u00e7\u00e3o. Pela defini\u00e7\u00e3o acima, notamos que uma fun\u00e7\u00e3o sem efeitos colaterais pode ser chamada por v\u00e1rias threads ao mesmo tempo. Claramente isto \u00e9 uma vantagem, j\u00e1 que isto pode facilitar muito a paraleliza\u00e7\u00e3o de c\u00f3digo.","title":"08 - Efeitos colaterais"},{"location":"aulas/08-efeitos-colaterais/#parte-0-analizando-o-codigo-existente","text":"Nesta parte do roteiro iremos analisar o c\u00f3digo exemplo, testar uma paraleliza\u00e7\u00e3o ing\u00eanua e identificar seus poss\u00edveis problemas de paraleliza\u00e7\u00e3o. Question Considerando somente o arquivo pi_mc.c , existe c\u00f3digo com efeitos colaterais? Example Fa\u00e7a uma paraleliza\u00e7\u00e3o ing\u00eanua deste c\u00f3digo. Example Teste a paraleliza\u00e7\u00e3o ing\u00eanua do exerc\u00edcio anterior. Ela retorna os mesmos resultados em todas execu\u00e7\u00f5es? Se n\u00e3o, comente por que isto \u00e9 um problema. Dado que n\u00e3o encontramos problemas no arquivo pi_mc.c , vamos olhar ent\u00e3o os arquivos random.c/h . Question Existe c\u00f3digo com efeitos colaterais? Liste as fun\u00e7\u00f5es encontradas. Question Voltando para pi_mc.c , onde s\u00e3o chamadas as fun\u00e7\u00f5es identificadas acima? Question Agora que voc\u00ea est\u00e1 familiarizado com todo o c\u00f3digo, explique por que os resultados s\u00e3o diferentes quando rodamos o c\u00f3digo ingenuamente paralelo. S\u00f3 prossiga ap\u00f3s validar as respostas do item anterior com o professor ou com um colega que j\u00e1 tenha finalizado esta parte.","title":"Parte 0: analizando o c\u00f3digo existente"},{"location":"aulas/08-efeitos-colaterais/#parte-1-exclusao-mutua","text":"Identificamos na parte anterior que a fun\u00e7\u00e3o drandom possui efeitos colaterais e estes efeitos colaterais est\u00e3o atrapalhando a paraleliza\u00e7\u00e3o do c\u00f3digo. Esta implementa\u00e7\u00e3o \u00e9 parecida com as fun\u00e7\u00f5es do cabe\u00e7alho <random> : temos um estado do gerador de n\u00fameros que \u00e9 passado para toda fun\u00e7\u00e3o que faz sorteios. Neste caso, o resultado do pr\u00f3ximo n\u00famero sorteado depende dos valores globais MULTIPLIER , ADDEND , PMOD e da vari\u00e1vel est\u00e1tica random_last . Example Modifique o c\u00f3digo para que ele use as fun\u00e7\u00f5es de gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios usando <random> . Salve em pi_mc_random.cpp . Na aula 06 usamos omp critical para criar se\u00e7\u00f5es de exclus\u00e3o m\u00fatua em que somente uma das threads rode por vez. No nosso caso o problema ocorre com a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios: ao gerar um n\u00famero o estado interno do gerador se modifica. Logo, tem um problema de acessos concorrentes a mesma vari\u00e1vel. Question Partindo do c\u00f3digo sequencial, quais linhas precisariam ser protegidas de acessos concorrentes? Example Utilize omp for e omp critical para paralelizar o c\u00f3digo em pi_mc_random.cpp . Question Avalie seu c\u00f3digo em termos de desempenho obtido e facilidade de programa\u00e7\u00e3o","title":"Parte 1: exclus\u00e3o m\u00fatua"},{"location":"aulas/08-efeitos-colaterais/#parte-2-paralelizacao-das-distancias","text":"Na parte anterior eliminamos acessos concorrentes ao gerador de n\u00fameros aleat\u00f3rios. Isso seria equivalente a fazer todos os sorteios antes e depois fazer os c\u00e1lculos das dist\u00e2ncias. Ou seja, os c\u00e1lculos de dist\u00e2ncia s\u00e3o independentes desde que os sorteios aleat\u00f3rios j\u00e1 tenham sido feitos. Example Modifique pi_mc_random.cpp para que o sorteio dos pontos seja feito em um vetor antes do for que faz os c\u00e1lculos de dist\u00e2ncias. Question \u00c9 poss\u00edvel paralelizar o for que faz o sorteio dos n\u00fameros? E o que faz o c\u00e1lculo das dist\u00e2ncias? Example Com base em suas respostas do item acima, paralize o que for poss\u00edvel e salve em um arquivo pi_mc_par1.cpp Question Houve ganho de desempenho? Compare com o programa original. Esta estrat\u00e9gia \u00e9 muito comum em casos em que a tarefa de interesse pode ser decomposta em uma parte inerentemente sequencial e uma que pode ser paralelizada mas que depende dos resultados da parte sequencial. Se a parte paraleliz\u00e1vel for custosa essa estrat\u00e9gia pode trazer ganhos mesmo que o programa n\u00e3o seja inteiramente paraleliz\u00e1vel.","title":"Parte 2: paraleliza\u00e7\u00e3o das dist\u00e2ncias"},{"location":"aulas/08-efeitos-colaterais/#parte-3-partes-independentes","text":"A segunda estrat\u00e9gia que usaremos \u00e9 criar um gerador de n\u00fameros aleat\u00f3rios para cada thread. Ou seja, cada thread precisar\u00e1: criar um gerador de n\u00fameros aleat\u00f3rios pr\u00f3prio acumular os resultados na mesma vari\u00e1vel de somar pontos. Note que esta estrat\u00e9gia n\u00e3o \u00e9 equivalente ao programa original: cada thread est\u00e1 seguindo uma sequ\u00eancia diferente de n\u00fameros aleat\u00f3rios. Example Reorganize seu c\u00f3digo (partindo de pi_mc_random.cpp ) para que cada thread crie seu pr\u00f3prio gerador de n\u00fameros aleat\u00f3rios e fa\u00e7a \u00bc das itera\u00e7\u00f5es originais. Salve seu trabalho em pi_mc_par2.c Question Compare o desempenho com o programa original.","title":"Parte 3: partes independentes"},{"location":"aulas/08-efeitos-colaterais/#parte-4-comparacao-de-desempenho-final","text":"Compare o desempenho das duas abordagens de paraleliza\u00e7\u00e3o. Question Qual \u00e9 mais r\u00e1pida? Question Qual \u00e9 mais f\u00e1cil de ser entendida?","title":"Parte 4 - compara\u00e7\u00e3o de desempenho final"},{"location":"aulas/09-tarefas/","text":"09 - Tarefas \u00b6 O uso de tarefas (tasks) para paralelizar c\u00f3digos apresenta bons resultados em diversas aplica\u00e7\u00f5es que n\u00e3o se encaixam exatamente no modelo fork-join . Nessa aula exploraremos o uso de tarefas para paralelizar a execu\u00e7\u00e3o de fun\u00e7\u00f5es recursivas. Parte 0 - comandos task e master \u00b6 Revis\u00e3o #pragma omp task - cria uma tarefa, que ser\u00e1 executada por alguma das threads dispon\u00edveis. #pragma omp master - executa o bloco abaixo da diretiva na thread principal ( id == 0 ) Example Escreva um programa usando tarefas (tasks) que ir\u00e1 aleatoriamente gerar uma das duas cadeias de caracteres: I think race cars are fun I think car races are fun Dica : use tarefas para imprimir a parte indeterminada da sa\u00edda (ou seja, as palavras \"race\" ou \"cars\"). Question O programa retorna sempre a mesma resposta? Essa situa\u00e7\u00e3o \u00e9 chamada de \"Condi\u00e7\u00e3o da corrida\". Conceito Uma condi\u00e7\u00e3o de corrida ocorre quando o resultado de um programa depende de como o sistema operacional escalona as threads. Ou seja, seu resultado n\u00e3o \u00e9 determin\u00edstico. Parte 1 - tarefas e fun\u00e7\u00f5es recursivas \u00b6 O c\u00f3digo abaixo calcula a sequ\u00eancia de Fibonacci usando um algoritmo recursivo. #include <iostream> int fib ( int n ) { int x , y ; if ( n < 2 ) return n ; x = fib ( n - 1 ); y = fib ( n - 2 ); return ( x + y ); } int main () { int NW = 45 ; int f = fib ( NW ); std :: cout << f << std :: endl ; } Example Crie uma nova fun\u00e7\u00e3o int fib_par1(int n); e paraleliza as chamadas recursivas usando task s. Fa\u00e7a com que cada chamada recursiva seja executada como uma tarefa. Dica : \u00e9 preciso esperar as tarefas acabarem antes do return ? Example Compare com o c\u00f3digo original. Houve melhora? Por que? O exerc\u00edcio acima exemplifica o custo de criar e escalonar tarefas. Vamos melhorar esta paraleliza\u00e7\u00e3o agora limitando o n\u00famero de tarefas criadas. Example Crie uma nova fun\u00e7\u00e3o int fib_par2(int n) e paraleliza as chamadas recursivas. Fa\u00e7a com que sejam criadas no m\u00e1ximo max_tasks tarefas. Dica : passar como argumento o n\u00edvel da recurs\u00e3o pode ajudar. Parte 2 - estrat\u00e9gias de paraleliza\u00e7\u00e3o \u00b6 A etapa final de nossa aula trabalhar\u00e1 o algoritmo de c\u00e1lculo do pi usando integra\u00e7\u00e3o numerica novamente, mas agora escrito de maneira recursiva. Question Abra o arquivo pi_recursivo.cpp e examine seu conte\u00fado. Quantos n\u00edveis de recurs\u00e3o s\u00e3o feitos? Em outras palavras, quantas chamadas s\u00e3o necess\u00e1rias at\u00e9 que o for seja executado sequencialmente? Dica : veja a rela\u00e7\u00e3o entre MIN_BLK e num_steps . Example A paraleliza\u00e7\u00e3o de c\u00f3digo \u00e9 sempre muito mais f\u00e1cil quando eliminamos todos os efeitos colaterais. Elimine todas as vari\u00e1veis globais do c\u00f3digo. Crie tamb\u00e9m uma fun\u00e7\u00e3o double pi_par_tasks(long num_steps) que chama a fun\u00e7\u00e3o double pi_r com os valores iniciais corretos. Example Agora use omp task para paralelizar as chamadas recursivas. Example Varie o valor de MIN_BLK e me\u00e7a o desempenho do programa. Escreva, junto desse valor, quantas tarefas foram criadas e quantos processadores estiveram ativos durante a execu\u00e7\u00e3o do programa. Parte 3 - estrat\u00e9gias de paraleliza\u00e7\u00e3o \u00b6 Question Resuma, com suas palavras, a estrat\u00e9gia de paraleliza\u00e7\u00e3o usada na parte 2. Como ela se relaciona com o n\u00famero de thread s dispon\u00edveis em um sistema? Question Resuma, com suas palavras, a estrat\u00e9gia de paraleliza\u00e7\u00e3o usada na parte 3. Qual a rela\u00e7\u00e3o entre MIN_BLK e o n\u00famero de thread s dispon\u00edveis em um sistema? Devemos modificar MIN_BLK baseado na entrada?","title":"09 - Tarefas"},{"location":"aulas/09-tarefas/#09-tarefas","text":"O uso de tarefas (tasks) para paralelizar c\u00f3digos apresenta bons resultados em diversas aplica\u00e7\u00f5es que n\u00e3o se encaixam exatamente no modelo fork-join . Nessa aula exploraremos o uso de tarefas para paralelizar a execu\u00e7\u00e3o de fun\u00e7\u00f5es recursivas.","title":"09 - Tarefas"},{"location":"aulas/09-tarefas/#parte-0-comandos-task-e-master","text":"Revis\u00e3o #pragma omp task - cria uma tarefa, que ser\u00e1 executada por alguma das threads dispon\u00edveis. #pragma omp master - executa o bloco abaixo da diretiva na thread principal ( id == 0 ) Example Escreva um programa usando tarefas (tasks) que ir\u00e1 aleatoriamente gerar uma das duas cadeias de caracteres: I think race cars are fun I think car races are fun Dica : use tarefas para imprimir a parte indeterminada da sa\u00edda (ou seja, as palavras \"race\" ou \"cars\"). Question O programa retorna sempre a mesma resposta? Essa situa\u00e7\u00e3o \u00e9 chamada de \"Condi\u00e7\u00e3o da corrida\". Conceito Uma condi\u00e7\u00e3o de corrida ocorre quando o resultado de um programa depende de como o sistema operacional escalona as threads. Ou seja, seu resultado n\u00e3o \u00e9 determin\u00edstico.","title":"Parte 0 - comandos task e master"},{"location":"aulas/09-tarefas/#parte-1-tarefas-e-funcoes-recursivas","text":"O c\u00f3digo abaixo calcula a sequ\u00eancia de Fibonacci usando um algoritmo recursivo. #include <iostream> int fib ( int n ) { int x , y ; if ( n < 2 ) return n ; x = fib ( n - 1 ); y = fib ( n - 2 ); return ( x + y ); } int main () { int NW = 45 ; int f = fib ( NW ); std :: cout << f << std :: endl ; } Example Crie uma nova fun\u00e7\u00e3o int fib_par1(int n); e paraleliza as chamadas recursivas usando task s. Fa\u00e7a com que cada chamada recursiva seja executada como uma tarefa. Dica : \u00e9 preciso esperar as tarefas acabarem antes do return ? Example Compare com o c\u00f3digo original. Houve melhora? Por que? O exerc\u00edcio acima exemplifica o custo de criar e escalonar tarefas. Vamos melhorar esta paraleliza\u00e7\u00e3o agora limitando o n\u00famero de tarefas criadas. Example Crie uma nova fun\u00e7\u00e3o int fib_par2(int n) e paraleliza as chamadas recursivas. Fa\u00e7a com que sejam criadas no m\u00e1ximo max_tasks tarefas. Dica : passar como argumento o n\u00edvel da recurs\u00e3o pode ajudar.","title":"Parte 1 - tarefas e fun\u00e7\u00f5es recursivas"},{"location":"aulas/09-tarefas/#parte-2-estrategias-de-paralelizacao","text":"A etapa final de nossa aula trabalhar\u00e1 o algoritmo de c\u00e1lculo do pi usando integra\u00e7\u00e3o numerica novamente, mas agora escrito de maneira recursiva. Question Abra o arquivo pi_recursivo.cpp e examine seu conte\u00fado. Quantos n\u00edveis de recurs\u00e3o s\u00e3o feitos? Em outras palavras, quantas chamadas s\u00e3o necess\u00e1rias at\u00e9 que o for seja executado sequencialmente? Dica : veja a rela\u00e7\u00e3o entre MIN_BLK e num_steps . Example A paraleliza\u00e7\u00e3o de c\u00f3digo \u00e9 sempre muito mais f\u00e1cil quando eliminamos todos os efeitos colaterais. Elimine todas as vari\u00e1veis globais do c\u00f3digo. Crie tamb\u00e9m uma fun\u00e7\u00e3o double pi_par_tasks(long num_steps) que chama a fun\u00e7\u00e3o double pi_r com os valores iniciais corretos. Example Agora use omp task para paralelizar as chamadas recursivas. Example Varie o valor de MIN_BLK e me\u00e7a o desempenho do programa. Escreva, junto desse valor, quantas tarefas foram criadas e quantos processadores estiveram ativos durante a execu\u00e7\u00e3o do programa.","title":"Parte 2 - estrat\u00e9gias de paraleliza\u00e7\u00e3o"},{"location":"aulas/09-tarefas/#parte-3-estrategias-de-paralelizacao","text":"Question Resuma, com suas palavras, a estrat\u00e9gia de paraleliza\u00e7\u00e3o usada na parte 2. Como ela se relaciona com o n\u00famero de thread s dispon\u00edveis em um sistema? Question Resuma, com suas palavras, a estrat\u00e9gia de paraleliza\u00e7\u00e3o usada na parte 3. Qual a rela\u00e7\u00e3o entre MIN_BLK e o n\u00famero de thread s dispon\u00edveis em um sistema? Devemos modificar MIN_BLK baseado na entrada?","title":"Parte 3 - estrat\u00e9gias de paraleliza\u00e7\u00e3o"},{"location":"aulas/10-gpu-I/","text":"10 - introdu\u00e7\u00e3o a GPU \u00b6 Como visto em aula, programa\u00e7\u00e3o para GPU requer ferramentas especializadas capazes de gerar c\u00f3digo que rode parte na CPU (chamada de host ) e parte na GPU (chamada de target ). Nesta parte introdut\u00f3ria usaremos a biblioteca cuda::thrust . Ela possui um pequeno conjunto de opera\u00e7\u00f5es otimizadas para GPU e que podem ser customizadas para diversos prop\u00f3sitos. Documenta\u00e7\u00e3o oficial A documenta\u00e7\u00e3o oficial da Thrust est\u00e1 dispon\u00edvel no endere\u00e7o https://thrust.github.io/doc/modules.html . Tamb\u00e9m vamos focar em usar m\u00e1quinas pr\u00e9-configuradas. Instru\u00e7\u00f5es de instala\u00e7\u00e3o local est\u00e3o dispon\u00edveis no Anexo 1 deste roteiro. Parte 0 - compila\u00e7\u00e3o \u00b6 Para compilar programas para rodar na GPU devemos usar o compilador nvcc . Ele identifica quais por\u00e7\u00f5es do c\u00f3digo dever\u00e3o ser compiladas para a GPU. O restante do c\u00f3digo, que roda exclusivamente na CPU, \u00e9 passado diretamente para um compilador C++ regular e um \u00fanico execut\u00e1vel \u00e9 gerado contendo o c\u00f3digo para CPU e chamadas inseridas pelo nvcc para invocar as fun\u00e7\u00f5es que rodam na GPU. Example Verifique que sua instala\u00e7\u00e3o funciona compilando o arquivo abaixo. $ nvcc -std=c++11 exemplo1-criacao-iteracao.cu -o exemplo1 Se der tudo certo a execu\u00e7\u00e3o do programa acima dever\u00e1 gerar um execut\u00e1vel exemplo1 que roda e produz o seguinte resultado. Host vector: 0 0 12 0 35 Device vector 0 0 0 0 35 Parte 1 - transfer\u00eancia de dados \u00b6 Como visto na expositiva, a CPU e a GPU possuem espa\u00e7os de endere\u00e7amento completamente distintos. Ou seja, a CPU n\u00e3o consegue acessar os dados na mem\u00f3ria da GPU e vice-versa. A thrust disponibiliza somente um tipo de container ( vector ) e facilita este gerenciamento deixando expl\u00edcito se ele est\u00e1 alocado na CPU ( host ) ou na GPU ( device ). A c\u00f3pia CPU \\leftrightarrow \\leftrightarrow GPU \u00e9 feita implicitamente quando criamos um device_vector ou quando usamos a opera\u00e7\u00e3o de atribui\u00e7\u00e3o entre host_vector e device_vector . Veja o exemplo abaixo: thrust :: host_vector < double > vec_cpu ( 10 ); // alocado na CPU vec1 [ 0 ] = 20 ; vec2 [ 1 ] = 30 ; // aloca vetor na GPU e transfere dados CPU->GPU thrust :: device_vector < double > vec_gpu ( vec_cpu ); //processa vec_gpu vec_cpu = vec_gpu ; // copia dados GPU -> CPU A thrust usa iteradores em todas as suas fun\u00e7\u00f5es. Pense em um iterador como um ponteiro para os elementos do array. Por\u00e9m, um iterador \u00e9 mais esperto: ele guarda tamb\u00e9m o tipo do vetor original e suporta opera\u00e7\u00f5es ++ e * para qualquer tipo de dado iterado de maneira transparente. Vetores thrust aceitam os m\u00e9todos v.begin() para retornar um iterador para o come\u00e7o do vetor e v.end() para um iterador para o fim (depois do \u00faltimo elemento). Podemos tamb\u00e9m somar um valor n a um iterador. Isto \u00e9 equivalente a fazer n vezes a opera\u00e7\u00e3o ++ . Veja abaixo um exemplo de uso das fun\u00e7\u00f5es fill e sequence para preencher valores em um vetor de maneira eficiente. thrust :: device_vector < int > v ( 5 , 0 ); // vetor de 5 ints zerado // v = {0, 0, 0, 0, 0} thrust :: sequence ( v . begin (), v . end ()); // preenche com 0, 1, 2, .... // v = {0, 1, 2, 3, 4} thrust :: fill ( v . begin (), v . begin () + 2 , 13 ); // dois primeiros elementos = 13 // v = {13, 13, 2, 3, 4} Consulte o arquivo exemplo1-criacao-iteracao.cu para um exemplo completo de aloca\u00e7\u00e3o e transfer\u00eancia de dados e do uso de iteradores. Example O fluxo de trabalho \"normal\" de aplica\u00e7\u00f5es usando GPU \u00e9 receber os dados em um vetor na CPU e copi\u00e1-los para a GPU para fazer processamentos. Crie um programa que l\u00ea uma sequ\u00eancia de double s da entrada padr\u00e3o em um thrust::host_vector e os copia para um thrust::device_vector . Teste seu programa com o arquivo stocks-google.txt , que cont\u00e9m o pre\u00e7o das a\u00e7\u00f5es do Google nos \u00faltimos 10 anos. Example A cria\u00e7\u00e3o de um device_vector \u00e9 demorada. Me\u00e7a o tempo que a opera\u00e7\u00e3o de aloca\u00e7\u00e3o e c\u00f3pia demora e imprima na sa\u00edda de erros. (Use std::chrono ). Parte 2 - redu\u00e7\u00f5es \u00b6 Uma opera\u00e7\u00e3o gen\u00e9rica de redu\u00e7\u00e3o transforma um vetor em um \u00fanico valor. Exemplos cl\u00e1ssicos de opera\u00e7\u00f5es de redu\u00e7\u00e3o incluem soma , m\u00e9dia e m\u00ednimo/m\u00e1ximo de um vetor. A thrust disponibiliza este tipo de opera\u00e7\u00e3o otimizada em GPU usando a fun\u00e7\u00e3o thrust::reduce : val = thrust :: reduce ( iter_comeco , iter_fim , inicial , op ); // iter_comeco: iterador para o come\u00e7o dos dados // iter_fim: iterador para o fim dos dados // inicial: valor inicial // op: opera\u00e7\u00e3o a ser feita. Um exemplo de uso de redu\u00e7\u00e3o para computar o m\u00e1ximo pode ser visto aqui . A lista completa de fun\u00e7\u00f5es que podem ser usadas no lugar de op pode ser vista neste link . Example Continuando o exerc\u00edcio anterior, calcule as seguintes medidas. N\u00e3o se esque\u00e7a de passar o device_vector para a sua fun\u00e7\u00e3o reduce O pre\u00e7o m\u00e9dio das a\u00e7\u00f5es nos \u00faltimos 10 anos. O pre\u00e7o m\u00e9dio das a\u00e7\u00f5es no \u00faltimo ano (365 dias atr\u00e1s). O maior e o menor pre\u00e7o da sequ\u00eancia inteira e do \u00faltimo ano. Respostas flkj sdlkf sdlkjfsl Voc\u00ea pode consultar todos os tipos de redu\u00e7\u00f5es dispon\u00edveis no site da thrust . Example Todos os algoritmos da thrust podem ser rodados tamb\u00e9m em OpenMP passando como primeiro argumento thrust::host . Modifique o seu exerc\u00edcio acima para fazer as mesmas chamadas por\u00e9m usando OpenMP e me\u00e7a o tempo das duas implementa\u00e7\u00f5es. Separe o tempo de c\u00f3pia para GPU e o de execu\u00e7\u00e3o em sua an\u00e1lise. Example Comente os resultado acima. Quando vale a pena paralelizar usando GPU? Compare o tempo de execu\u00e7\u00e3o na CPU e na GPU e o tempo de c\u00f3pia. Parte 3 - Transforma\u00e7\u00f5es ponto a ponto \u00b6 Al\u00e9m de opera\u00e7\u00f5es de redu\u00e7\u00e3o tamb\u00e9m podemos fazer opera\u00e7\u00f5es ponto a ponto em somente um vetor (como negar todas as componentes ou calcular os quadrados) quanto entre dois vetores (como somar dois vetores componente por componente ou comparar cada elemento com seu correspondente em outro vetor). A thrust d\u00e1 o nome de transformation para este tipo de opera\u00e7\u00e3o. // para opera\u00e7\u00f5es entre dois vetores iter1 e iter2. resultado armazenado em out thrust :: transform ( iter1_comeco , iter1_fim , iter2_comeco , out_comeco , op ); // iter1_comeco: iterador para o come\u00e7o de iter1 // iter1_fim: iterador para o fim de iter1 // iter2_comeco: iterador para o come\u00e7o de iter2 // out_comeco: iterador para o come\u00e7o de out // op: opera\u00e7\u00e3o a ser realizada. Um exemplo concreto pode ser visto abaixo. O c\u00f3digo completo est\u00e1 em exemplo2-transform.cu thrust :: device_vector < double > V1 ( 10 , 0 ); thrust :: device_vector < double > V2 ( 10 , 0 ); thrust :: device_vector < double > V3 ( 10 , 0 ); thrust :: device_vector < double > V4 ( 10 , 0 ); // inicializa V1 e V2 aqui //soma V1 e V2 thrust :: transform ( V1 . begin (), V1 . end (), V2 . begin (), V3 . begin (), thrust :: plus < double > ()); // multiplica V1 por 0.5 thrust :: transform ( V1 . begin (), V1 . end (), thrust :: constant_iterator < double > ( 0.5 ), V4 . begin (), thrust :: multiplies < double > ()); As opera\u00e7\u00f5es que foram usadas no reduce tamb\u00e9m podem ser usadas em um transform . N\u00e3o se esque\u00e7a de consultar a lista de opera\u00e7\u00f5es para fazer este exerc\u00edcio. Example Vamos agora trabalhar com o arquivo stocks2.csv . Ele cont\u00e9m a s\u00e9rie hist\u00f3rica de a\u00e7\u00f5es da Apple e da Microsoft. Seu objetivo \u00e9 calcular a diferen\u00e7a m\u00e9dia entre os pre\u00e7os das a\u00e7\u00f5es AAPL e MSFT. Dica : quebre o problema em duas partes. Primeiro calcule a diferen\u00e7a entre os pre\u00e7os e guarde isto em um vetor. Depois compute a m\u00e9dia deste vetor. Example Cada chamada a reduce e transform tem um custo fixo que pode se acumular caso fa\u00e7amos muitas chamadas. Estude como escrever seu programa usando transform_reduce . Anexo 1 - instala\u00e7\u00e3o local \u00b6 Instru\u00e7\u00f5es f\u00e1ceis : os reposit\u00f3rios oficiais do Ubuntu j\u00e1 cont\u00e9m o pacote nvidia-cuda-toolkit pronto para instala\u00e7\u00e3o via apt . A vers\u00e3o disponibilizada n\u00e3o \u00e9 a mais atual ( 9.1.85 vs 10.0 ), mas tudo funciona de maneira integrada e n\u00e3o \u00e9 necess\u00e1rio instalar nada manualmente. Esta vers\u00e3o ser\u00e1 suportada pelo curso. Instru\u00e7\u00f5es n\u00e3o t\u00e3o f\u00e1ceis : Visitar o site da NVIDIA , baixar o pacote .deb e instalar manualmente. Estas instru\u00e7\u00f5es n\u00e3o s\u00e3o dif\u00edceis, mas como pode ser necess\u00e1rio instalar novos drivers de v\u00eddeo isto pode dar algum trabalho.","title":"10 - introdu\u00e7\u00e3o a GPU"},{"location":"aulas/10-gpu-I/#10-introducao-a-gpu","text":"Como visto em aula, programa\u00e7\u00e3o para GPU requer ferramentas especializadas capazes de gerar c\u00f3digo que rode parte na CPU (chamada de host ) e parte na GPU (chamada de target ). Nesta parte introdut\u00f3ria usaremos a biblioteca cuda::thrust . Ela possui um pequeno conjunto de opera\u00e7\u00f5es otimizadas para GPU e que podem ser customizadas para diversos prop\u00f3sitos. Documenta\u00e7\u00e3o oficial A documenta\u00e7\u00e3o oficial da Thrust est\u00e1 dispon\u00edvel no endere\u00e7o https://thrust.github.io/doc/modules.html . Tamb\u00e9m vamos focar em usar m\u00e1quinas pr\u00e9-configuradas. Instru\u00e7\u00f5es de instala\u00e7\u00e3o local est\u00e3o dispon\u00edveis no Anexo 1 deste roteiro.","title":"10 - introdu\u00e7\u00e3o a GPU"},{"location":"aulas/10-gpu-I/#parte-0-compilacao","text":"Para compilar programas para rodar na GPU devemos usar o compilador nvcc . Ele identifica quais por\u00e7\u00f5es do c\u00f3digo dever\u00e3o ser compiladas para a GPU. O restante do c\u00f3digo, que roda exclusivamente na CPU, \u00e9 passado diretamente para um compilador C++ regular e um \u00fanico execut\u00e1vel \u00e9 gerado contendo o c\u00f3digo para CPU e chamadas inseridas pelo nvcc para invocar as fun\u00e7\u00f5es que rodam na GPU. Example Verifique que sua instala\u00e7\u00e3o funciona compilando o arquivo abaixo. $ nvcc -std=c++11 exemplo1-criacao-iteracao.cu -o exemplo1 Se der tudo certo a execu\u00e7\u00e3o do programa acima dever\u00e1 gerar um execut\u00e1vel exemplo1 que roda e produz o seguinte resultado. Host vector: 0 0 12 0 35 Device vector 0 0 0 0 35","title":"Parte 0 - compila\u00e7\u00e3o"},{"location":"aulas/10-gpu-I/#parte-1-transferencia-de-dados","text":"Como visto na expositiva, a CPU e a GPU possuem espa\u00e7os de endere\u00e7amento completamente distintos. Ou seja, a CPU n\u00e3o consegue acessar os dados na mem\u00f3ria da GPU e vice-versa. A thrust disponibiliza somente um tipo de container ( vector ) e facilita este gerenciamento deixando expl\u00edcito se ele est\u00e1 alocado na CPU ( host ) ou na GPU ( device ). A c\u00f3pia CPU \\leftrightarrow \\leftrightarrow GPU \u00e9 feita implicitamente quando criamos um device_vector ou quando usamos a opera\u00e7\u00e3o de atribui\u00e7\u00e3o entre host_vector e device_vector . Veja o exemplo abaixo: thrust :: host_vector < double > vec_cpu ( 10 ); // alocado na CPU vec1 [ 0 ] = 20 ; vec2 [ 1 ] = 30 ; // aloca vetor na GPU e transfere dados CPU->GPU thrust :: device_vector < double > vec_gpu ( vec_cpu ); //processa vec_gpu vec_cpu = vec_gpu ; // copia dados GPU -> CPU A thrust usa iteradores em todas as suas fun\u00e7\u00f5es. Pense em um iterador como um ponteiro para os elementos do array. Por\u00e9m, um iterador \u00e9 mais esperto: ele guarda tamb\u00e9m o tipo do vetor original e suporta opera\u00e7\u00f5es ++ e * para qualquer tipo de dado iterado de maneira transparente. Vetores thrust aceitam os m\u00e9todos v.begin() para retornar um iterador para o come\u00e7o do vetor e v.end() para um iterador para o fim (depois do \u00faltimo elemento). Podemos tamb\u00e9m somar um valor n a um iterador. Isto \u00e9 equivalente a fazer n vezes a opera\u00e7\u00e3o ++ . Veja abaixo um exemplo de uso das fun\u00e7\u00f5es fill e sequence para preencher valores em um vetor de maneira eficiente. thrust :: device_vector < int > v ( 5 , 0 ); // vetor de 5 ints zerado // v = {0, 0, 0, 0, 0} thrust :: sequence ( v . begin (), v . end ()); // preenche com 0, 1, 2, .... // v = {0, 1, 2, 3, 4} thrust :: fill ( v . begin (), v . begin () + 2 , 13 ); // dois primeiros elementos = 13 // v = {13, 13, 2, 3, 4} Consulte o arquivo exemplo1-criacao-iteracao.cu para um exemplo completo de aloca\u00e7\u00e3o e transfer\u00eancia de dados e do uso de iteradores. Example O fluxo de trabalho \"normal\" de aplica\u00e7\u00f5es usando GPU \u00e9 receber os dados em um vetor na CPU e copi\u00e1-los para a GPU para fazer processamentos. Crie um programa que l\u00ea uma sequ\u00eancia de double s da entrada padr\u00e3o em um thrust::host_vector e os copia para um thrust::device_vector . Teste seu programa com o arquivo stocks-google.txt , que cont\u00e9m o pre\u00e7o das a\u00e7\u00f5es do Google nos \u00faltimos 10 anos. Example A cria\u00e7\u00e3o de um device_vector \u00e9 demorada. Me\u00e7a o tempo que a opera\u00e7\u00e3o de aloca\u00e7\u00e3o e c\u00f3pia demora e imprima na sa\u00edda de erros. (Use std::chrono ).","title":"Parte 1 - transfer\u00eancia de dados"},{"location":"aulas/10-gpu-I/#parte-2-reducoes","text":"Uma opera\u00e7\u00e3o gen\u00e9rica de redu\u00e7\u00e3o transforma um vetor em um \u00fanico valor. Exemplos cl\u00e1ssicos de opera\u00e7\u00f5es de redu\u00e7\u00e3o incluem soma , m\u00e9dia e m\u00ednimo/m\u00e1ximo de um vetor. A thrust disponibiliza este tipo de opera\u00e7\u00e3o otimizada em GPU usando a fun\u00e7\u00e3o thrust::reduce : val = thrust :: reduce ( iter_comeco , iter_fim , inicial , op ); // iter_comeco: iterador para o come\u00e7o dos dados // iter_fim: iterador para o fim dos dados // inicial: valor inicial // op: opera\u00e7\u00e3o a ser feita. Um exemplo de uso de redu\u00e7\u00e3o para computar o m\u00e1ximo pode ser visto aqui . A lista completa de fun\u00e7\u00f5es que podem ser usadas no lugar de op pode ser vista neste link . Example Continuando o exerc\u00edcio anterior, calcule as seguintes medidas. N\u00e3o se esque\u00e7a de passar o device_vector para a sua fun\u00e7\u00e3o reduce O pre\u00e7o m\u00e9dio das a\u00e7\u00f5es nos \u00faltimos 10 anos. O pre\u00e7o m\u00e9dio das a\u00e7\u00f5es no \u00faltimo ano (365 dias atr\u00e1s). O maior e o menor pre\u00e7o da sequ\u00eancia inteira e do \u00faltimo ano. Respostas flkj sdlkf sdlkjfsl Voc\u00ea pode consultar todos os tipos de redu\u00e7\u00f5es dispon\u00edveis no site da thrust . Example Todos os algoritmos da thrust podem ser rodados tamb\u00e9m em OpenMP passando como primeiro argumento thrust::host . Modifique o seu exerc\u00edcio acima para fazer as mesmas chamadas por\u00e9m usando OpenMP e me\u00e7a o tempo das duas implementa\u00e7\u00f5es. Separe o tempo de c\u00f3pia para GPU e o de execu\u00e7\u00e3o em sua an\u00e1lise. Example Comente os resultado acima. Quando vale a pena paralelizar usando GPU? Compare o tempo de execu\u00e7\u00e3o na CPU e na GPU e o tempo de c\u00f3pia.","title":"Parte 2 - redu\u00e7\u00f5es"},{"location":"aulas/10-gpu-I/#parte-3-transformacoes-ponto-a-ponto","text":"Al\u00e9m de opera\u00e7\u00f5es de redu\u00e7\u00e3o tamb\u00e9m podemos fazer opera\u00e7\u00f5es ponto a ponto em somente um vetor (como negar todas as componentes ou calcular os quadrados) quanto entre dois vetores (como somar dois vetores componente por componente ou comparar cada elemento com seu correspondente em outro vetor). A thrust d\u00e1 o nome de transformation para este tipo de opera\u00e7\u00e3o. // para opera\u00e7\u00f5es entre dois vetores iter1 e iter2. resultado armazenado em out thrust :: transform ( iter1_comeco , iter1_fim , iter2_comeco , out_comeco , op ); // iter1_comeco: iterador para o come\u00e7o de iter1 // iter1_fim: iterador para o fim de iter1 // iter2_comeco: iterador para o come\u00e7o de iter2 // out_comeco: iterador para o come\u00e7o de out // op: opera\u00e7\u00e3o a ser realizada. Um exemplo concreto pode ser visto abaixo. O c\u00f3digo completo est\u00e1 em exemplo2-transform.cu thrust :: device_vector < double > V1 ( 10 , 0 ); thrust :: device_vector < double > V2 ( 10 , 0 ); thrust :: device_vector < double > V3 ( 10 , 0 ); thrust :: device_vector < double > V4 ( 10 , 0 ); // inicializa V1 e V2 aqui //soma V1 e V2 thrust :: transform ( V1 . begin (), V1 . end (), V2 . begin (), V3 . begin (), thrust :: plus < double > ()); // multiplica V1 por 0.5 thrust :: transform ( V1 . begin (), V1 . end (), thrust :: constant_iterator < double > ( 0.5 ), V4 . begin (), thrust :: multiplies < double > ()); As opera\u00e7\u00f5es que foram usadas no reduce tamb\u00e9m podem ser usadas em um transform . N\u00e3o se esque\u00e7a de consultar a lista de opera\u00e7\u00f5es para fazer este exerc\u00edcio. Example Vamos agora trabalhar com o arquivo stocks2.csv . Ele cont\u00e9m a s\u00e9rie hist\u00f3rica de a\u00e7\u00f5es da Apple e da Microsoft. Seu objetivo \u00e9 calcular a diferen\u00e7a m\u00e9dia entre os pre\u00e7os das a\u00e7\u00f5es AAPL e MSFT. Dica : quebre o problema em duas partes. Primeiro calcule a diferen\u00e7a entre os pre\u00e7os e guarde isto em um vetor. Depois compute a m\u00e9dia deste vetor. Example Cada chamada a reduce e transform tem um custo fixo que pode se acumular caso fa\u00e7amos muitas chamadas. Estude como escrever seu programa usando transform_reduce .","title":"Parte 3 - Transforma\u00e7\u00f5es ponto a ponto"},{"location":"aulas/10-gpu-I/#anexo-1-instalacao-local","text":"Instru\u00e7\u00f5es f\u00e1ceis : os reposit\u00f3rios oficiais do Ubuntu j\u00e1 cont\u00e9m o pacote nvidia-cuda-toolkit pronto para instala\u00e7\u00e3o via apt . A vers\u00e3o disponibilizada n\u00e3o \u00e9 a mais atual ( 9.1.85 vs 10.0 ), mas tudo funciona de maneira integrada e n\u00e3o \u00e9 necess\u00e1rio instalar nada manualmente. Esta vers\u00e3o ser\u00e1 suportada pelo curso. Instru\u00e7\u00f5es n\u00e3o t\u00e3o f\u00e1ceis : Visitar o site da NVIDIA , baixar o pacote .deb e instalar manualmente. Estas instru\u00e7\u00f5es n\u00e3o s\u00e3o dif\u00edceis, mas como pode ser necess\u00e1rio instalar novos drivers de v\u00eddeo isto pode dar algum trabalho.","title":"Anexo 1 - instala\u00e7\u00e3o local"},{"location":"aulas/11-gpu-II/","text":"11 - introdu\u00e7\u00e3o a GPU - II \u00b6 Na \u00faltima aula conseguimos rodar algumas fun\u00e7\u00f5es em GPU e medir o custo de transfer\u00eancia de dados. Chegamos a conclus\u00e3o de que, para valer a pena usar a GPU, ou precisamos tratar muitos dados ou precisamos fazer tratamentos pesados. Parte 1 - iteradores \u00b6 Continuando a partir do \u00faltimo item da aula anterior, suponha que voc\u00ea deseja calcular a vari\u00e2ncia das diferen\u00e7as. Agora que j\u00e1 temos a m\u00e9dia, a f\u00f3rmula da vari\u00e2ncia \u00e9 dada por \\frac{1}{n}\\sum_{i=0}^n (x_i - \\mu)^2 \\frac{1}{n}\\sum_{i=0}^n (x_i - \\mu)^2 Example J\u00e1 sabemos tudo o que precisamos para fazer este c\u00e1lculo. Crie um vetor em que todas as componentes sejam iguais a m\u00e9dia (usando thrust::fill ) e compute a vari\u00e2ncia usando a f\u00f3rmula acima. Apesar do c\u00f3digo acima funcionar, ele tem um problema grave: \u00e9 preciso alocar um vetor inteiro somente para preench\u00ea-lo com valores iguais! Se estivermos trabalhando com muitos dados isto significa diminuir bastante a quantidade de dados que conseguimos tratar antes de acabar com a mem\u00f3ria da GPU. Podemos contornar isso usando iteradores, que s\u00e3o vetores gerados dinamicamente pela thrust a partir de um valor \u00fanico ou a partir de outros vetores. Example Pesquise a documenta\u00e7\u00e3o de thrust::constant_iterator e use-o para substituir a aloca\u00e7\u00e3o de mem\u00f3ria extra no exerc\u00edcio acima. Vamos agora nos preparar para a parte 2 criando um programa novamente em cima do arquivo stocks.txt . Example Leia o arquivo stocks.txt e crie um vetor contendo a diferen\u00e7a entre o dia atual e o anterior. Ou seja, dado que o vetor de sa\u00edda tenha nome ganho_diario e o de entrada stocks , temos que ganho_diario[i] = stocks[i+1] - stocks[i] Claramente ganho_diario.size() == stocks.size() - 1 . Leve isto em conta ao utilizar a opera\u00e7\u00e3o transform para criar o vetor ganho_diario . Parte 2 - redu\u00e7\u00f5es customizadas \u00b6 Com o vetor ganho_diario acima conseguimos saber se o valor da a\u00e7\u00e3o subiu ou caiu de um dia para o outro! Duas perguntas se seguem: quantas vezes o valor subiu? qual \u00e9 o aumento m\u00e9dio, considerando s\u00f3 as vezes em que o valor aumentou de fato? Podemos implementar essas l\u00f3gicas usando opera\u00e7\u00f5es customizadas. Como estamos fazendo uma opera\u00e7\u00e3o de redu\u00e7\u00e3o, nossa opera\u00e7\u00e3o consiste em receber dois elementos do vetor e devolver um terceiro que resume eles. Ao fazermos isso com todos os pares de elementos sucessivamente chegamos no valor final da redu\u00e7\u00e3o. Note que isto significa que nossa opera\u00e7\u00e3o de redu\u00e7\u00e3o n\u00e3o \u00e9 sens\u00edvel a ordem em que \u00e9 executada. O c\u00f3digo para definir opera\u00e7\u00f5es customizadas \u00e9 um pouco estranho, mas segue a l\u00f3gica abaixo. Um exemplo concreto pode ser visto no arquivo example-reduction.cu . O arquivo mostra uma opera\u00e7\u00e3o de redu\u00e7\u00e3o, mas a sintaxe e estilo de uso vale para qualquer opera\u00e7\u00e3o da thrust . struct custom_reduce { __host__ __device__ double operator ()( const double & x , const double & y ) const { // opera\u00e7\u00f5es podem ser bin\u00e1rias (receber x e y) ou un\u00e1rias (receber s\u00f3 um argumento) // o resultado \u00e9 sempre devolvido } }; Em geral a documenta\u00e7\u00e3o da thrust especifica que uma opera\u00e7\u00e3o recebe um UnaryOp ou BinaryOp . Isto significa que a fun\u00e7\u00e3o operator() acima receber\u00e1, respectivamente, um valor ou dois valores. Warning \u00c9 sempre importante consultar a documenta\u00e7\u00e3o para entender como essa fun\u00e7\u00e3o ser\u00e1 aplicada. Em alguns casos \u00e9 necess\u00e1rio que a fun\u00e7\u00e3o passada obede\u00e7a algumas restri\u00e7\u00f5es para que os resultados obtidos fa\u00e7am sentido. Note A thrust j\u00e1 tem suporte a opera\u00e7\u00f5es de redu\u00e7\u00e3o que s\u00e3o contagens. Veja sua documenta\u00e7\u00e3o oficial neste link . Qual fun\u00e7\u00e3o dessa p\u00e1gina voc\u00ea usaria para contar somente os elementos positivos de ganhos_diarios ? Example Use a fun\u00e7\u00e3o acima para calcular quantas vezes o valor da a\u00e7\u00e3o subiu. Resposta 1309 Vamos agora para o segundo item: \"Calcular o aumento m\u00e9dio, considerando somente as vezes em que o valor aumentou de fato\". Uma estrat\u00e9gia poss\u00edvel \u00e9 zerar todos os elementos negativos do vetor e depois calcular sua soma. Note A documenta\u00e7\u00e3o sobre transforma\u00e7\u00f5es \u00e9 bastante vasta. Voc\u00ea consegue encontrar alguma fun\u00e7\u00e3o que possa substituir elementos de um vetor baseado em uma condi\u00e7\u00e3o booleana? Example Use a fun\u00e7\u00e3o acima para substituir todos os valores negativos por 0 em ganhos_diarios . Example Calcule agora e m\u00e9dia dos valores positivos do vetor. Voc\u00ea j\u00e1 tem todos os que s\u00e3o positivos no exerc\u00edcio acima e a quantidade de valores positivos. Resposta 5,25179","title":"11 - introdu\u00e7\u00e3o a GPU - II"},{"location":"aulas/11-gpu-II/#11-introducao-a-gpu-ii","text":"Na \u00faltima aula conseguimos rodar algumas fun\u00e7\u00f5es em GPU e medir o custo de transfer\u00eancia de dados. Chegamos a conclus\u00e3o de que, para valer a pena usar a GPU, ou precisamos tratar muitos dados ou precisamos fazer tratamentos pesados.","title":"11 - introdu\u00e7\u00e3o a GPU - II"},{"location":"aulas/11-gpu-II/#parte-1-iteradores","text":"Continuando a partir do \u00faltimo item da aula anterior, suponha que voc\u00ea deseja calcular a vari\u00e2ncia das diferen\u00e7as. Agora que j\u00e1 temos a m\u00e9dia, a f\u00f3rmula da vari\u00e2ncia \u00e9 dada por \\frac{1}{n}\\sum_{i=0}^n (x_i - \\mu)^2 \\frac{1}{n}\\sum_{i=0}^n (x_i - \\mu)^2 Example J\u00e1 sabemos tudo o que precisamos para fazer este c\u00e1lculo. Crie um vetor em que todas as componentes sejam iguais a m\u00e9dia (usando thrust::fill ) e compute a vari\u00e2ncia usando a f\u00f3rmula acima. Apesar do c\u00f3digo acima funcionar, ele tem um problema grave: \u00e9 preciso alocar um vetor inteiro somente para preench\u00ea-lo com valores iguais! Se estivermos trabalhando com muitos dados isto significa diminuir bastante a quantidade de dados que conseguimos tratar antes de acabar com a mem\u00f3ria da GPU. Podemos contornar isso usando iteradores, que s\u00e3o vetores gerados dinamicamente pela thrust a partir de um valor \u00fanico ou a partir de outros vetores. Example Pesquise a documenta\u00e7\u00e3o de thrust::constant_iterator e use-o para substituir a aloca\u00e7\u00e3o de mem\u00f3ria extra no exerc\u00edcio acima. Vamos agora nos preparar para a parte 2 criando um programa novamente em cima do arquivo stocks.txt . Example Leia o arquivo stocks.txt e crie um vetor contendo a diferen\u00e7a entre o dia atual e o anterior. Ou seja, dado que o vetor de sa\u00edda tenha nome ganho_diario e o de entrada stocks , temos que ganho_diario[i] = stocks[i+1] - stocks[i] Claramente ganho_diario.size() == stocks.size() - 1 . Leve isto em conta ao utilizar a opera\u00e7\u00e3o transform para criar o vetor ganho_diario .","title":"Parte 1 - iteradores"},{"location":"aulas/11-gpu-II/#parte-2-reducoes-customizadas","text":"Com o vetor ganho_diario acima conseguimos saber se o valor da a\u00e7\u00e3o subiu ou caiu de um dia para o outro! Duas perguntas se seguem: quantas vezes o valor subiu? qual \u00e9 o aumento m\u00e9dio, considerando s\u00f3 as vezes em que o valor aumentou de fato? Podemos implementar essas l\u00f3gicas usando opera\u00e7\u00f5es customizadas. Como estamos fazendo uma opera\u00e7\u00e3o de redu\u00e7\u00e3o, nossa opera\u00e7\u00e3o consiste em receber dois elementos do vetor e devolver um terceiro que resume eles. Ao fazermos isso com todos os pares de elementos sucessivamente chegamos no valor final da redu\u00e7\u00e3o. Note que isto significa que nossa opera\u00e7\u00e3o de redu\u00e7\u00e3o n\u00e3o \u00e9 sens\u00edvel a ordem em que \u00e9 executada. O c\u00f3digo para definir opera\u00e7\u00f5es customizadas \u00e9 um pouco estranho, mas segue a l\u00f3gica abaixo. Um exemplo concreto pode ser visto no arquivo example-reduction.cu . O arquivo mostra uma opera\u00e7\u00e3o de redu\u00e7\u00e3o, mas a sintaxe e estilo de uso vale para qualquer opera\u00e7\u00e3o da thrust . struct custom_reduce { __host__ __device__ double operator ()( const double & x , const double & y ) const { // opera\u00e7\u00f5es podem ser bin\u00e1rias (receber x e y) ou un\u00e1rias (receber s\u00f3 um argumento) // o resultado \u00e9 sempre devolvido } }; Em geral a documenta\u00e7\u00e3o da thrust especifica que uma opera\u00e7\u00e3o recebe um UnaryOp ou BinaryOp . Isto significa que a fun\u00e7\u00e3o operator() acima receber\u00e1, respectivamente, um valor ou dois valores. Warning \u00c9 sempre importante consultar a documenta\u00e7\u00e3o para entender como essa fun\u00e7\u00e3o ser\u00e1 aplicada. Em alguns casos \u00e9 necess\u00e1rio que a fun\u00e7\u00e3o passada obede\u00e7a algumas restri\u00e7\u00f5es para que os resultados obtidos fa\u00e7am sentido. Note A thrust j\u00e1 tem suporte a opera\u00e7\u00f5es de redu\u00e7\u00e3o que s\u00e3o contagens. Veja sua documenta\u00e7\u00e3o oficial neste link . Qual fun\u00e7\u00e3o dessa p\u00e1gina voc\u00ea usaria para contar somente os elementos positivos de ganhos_diarios ? Example Use a fun\u00e7\u00e3o acima para calcular quantas vezes o valor da a\u00e7\u00e3o subiu. Resposta 1309 Vamos agora para o segundo item: \"Calcular o aumento m\u00e9dio, considerando somente as vezes em que o valor aumentou de fato\". Uma estrat\u00e9gia poss\u00edvel \u00e9 zerar todos os elementos negativos do vetor e depois calcular sua soma. Note A documenta\u00e7\u00e3o sobre transforma\u00e7\u00f5es \u00e9 bastante vasta. Voc\u00ea consegue encontrar alguma fun\u00e7\u00e3o que possa substituir elementos de um vetor baseado em uma condi\u00e7\u00e3o booleana? Example Use a fun\u00e7\u00e3o acima para substituir todos os valores negativos por 0 em ganhos_diarios . Example Calcule agora e m\u00e9dia dos valores positivos do vetor. Voc\u00ea j\u00e1 tem todos os que s\u00e3o positivos no exerc\u00edcio acima e a quantidade de valores positivos. Resposta 5,25179","title":"Parte 2 - redu\u00e7\u00f5es customizadas"},{"location":"aulas/12-gpu-III/","text":"12 - introdu\u00e7\u00e3o a GPU - III \u00b6 Hoje o foco ser\u00e1 opera\u00e7\u00f5es customizadas. Parte 0 - revis\u00e3o \u00b6 Na aula anterior fizemos v\u00e1rias implementa\u00e7\u00f5es da vari\u00e2ncia. Podemos fazer uma vers\u00e3o ainda mais sucinta usando opera\u00e7\u00f5es customizadas. Um truque comum \u00e9 adicionar atributos no struct usado como opera\u00e7\u00e3o: struct T { int attr ; T ( int a ) : attr ( a ) {}; // TODO: opera\u00e7\u00e3o customizada aqui }; A linha T(int a): attr(a) {} declara o construtor do struct T . Ela faz com que o atributo attr seja inicializado com o valor do par\u00e2metro a . Se houver mais de uma atribui\u00e7\u00e3o par\u00e2metro - atributo \u00e9 s\u00f3 usar , para separar as inicializa\u00e7\u00f5es. Example Fa\u00e7a uma nova implementa\u00e7\u00e3o da vari\u00e2ncia, dessa vez usando uma opera\u00e7\u00e3o customizada e com a chamada transform_reduce . Dica : passe a m\u00e9dia e o tamanho do vetor como atributo do struct . Parte 1 - acesso direto a vetores \u00b6 Apesar da thrust nos permitir acessar os dados de cada itera\u00e7\u00e3o, o acesso a elementos arbitr\u00e1rios do vetor n\u00e3o \u00e9 diretamente suportado. Apesar de ser poss\u00edvel fazer isto com iteradores e tuplas, vamos usar uma abordagem um pouco diferente: acessar o vetor diretamente e usar a thrust para fornecer ao nossa transforma\u00e7\u00e3o customizada o \u00edndice a ser usado. Vejamos abaixo um exemplo simples: #include <thrust/device_vector.h> #include <thrust/iterator/counting_iterator.h> #include <iostream> #include \"imagem.h\" struct raw_access { double * ptr ; raw_access ( double * ptr ) : ptr ( ptr ) {}; __device__ __host__ double operator ()( const int & i ) { return ptr [ i ] + 1 ; } }; int main () { thrust :: device_vector < double > vec ( 10 , 1 ); thrust :: counting_iterator < int > iter ( 0 ); raw_access ra ( thrust :: raw_pointer_cast ( vec . data ())); thrust :: transform ( iter , iter + 10 , vec . begin (), ra ); for ( const double & d : vec ) { std :: cout << d << \" \\n \" ; } return 0 ; } O struct raw_access recebe um ponteiro para o vetor e guarda em um atributo. Os valores recebidos em operator() s\u00e3o simplesmente os \u00edndices do vetor a serem tratados. Com isso, podemos fazer modifica\u00e7\u00f5es complexas em vetores trabalhando apenas com \u00edndices e acessos diretos a mem\u00f3ria. Warning A thrust \u00e9 bastante eficiente e os algoritmos foram implementados por especialistas em GPGPU. Prefira usar os recursos dispon\u00edveis na biblioteca se poss\u00edvel. Example Reimplemente o c\u00e1lculo das diferen\u00e7as adjancente usando uma transforma\u00e7\u00e3o customizada. Aproveite e j\u00e1 zere toda diferen\u00e7a negativa no novo vetor. Parte 2 - acesso a matrizes \u00b6 Assim como na CPU, podemos representar imagens como um vetor \"deitado\". O acesso ao elemento (i, j) \u00e9 feito como abaixo. img [ i * width + j ] = 10 ; Question Examine os arquivo imagem.cpp/h . Quais fun\u00e7\u00f5es s\u00e3o definidas e o qu\u00ea elas fazem? O filtro de m\u00e9dia \u00e9 um processamento de imagens simples muito usado para tirar suavizar imagens. Sua implementa\u00e7\u00e3o \u00e9 bastante simples. Dada uma imagem de entrada I I , a imagem de sa\u00edda O O \u00e9 dada pela seguinte express\u00e3o. O[i, j] = \\frac{I[i, j] + I[i-1, j] + I[i+1, j] + I[i, j-1] + I[i,j+1]}{5} O[i, j] = \\frac{I[i, j] + I[i-1, j] + I[i+1, j] + I[i, j-1] + I[i,j+1]}{5} Ambas as imagens tem o mesmo tamanho. Se o pixel acessado estiver fora da \u00e1rea v\u00e1lida da imagem ele deve ser considerado 0. Note Voc\u00ea pode converter qualquer imagem que tiver em seu computador para PGM usando o programa convert : $> convert imagem.png -compress None imagem.pgm Example Implemente um programa media_gpu que faz o processamento descrito acima usando thrust . Seu programa dever\u00e1 funcionar como abaixo. $> media_gpu in.pgm out.pgm Example Fa\u00e7a uma implementa\u00e7\u00e3o em CPU do filtro de m\u00e9dia. Chame-a de media_cpu . Ela dever\u00e1 funcionar de maneira id\u00eantica ao programa acima. Example Teste seu programa com diferentes tamanhos de imagens e compare os tempos de execu\u00e7\u00e3o. A partir de qual tamanho os tempos ficam equivalentes?","title":"12 - introdu\u00e7\u00e3o a GPU - III"},{"location":"aulas/12-gpu-III/#12-introducao-a-gpu-iii","text":"Hoje o foco ser\u00e1 opera\u00e7\u00f5es customizadas.","title":"12 - introdu\u00e7\u00e3o a GPU - III"},{"location":"aulas/12-gpu-III/#parte-0-revisao","text":"Na aula anterior fizemos v\u00e1rias implementa\u00e7\u00f5es da vari\u00e2ncia. Podemos fazer uma vers\u00e3o ainda mais sucinta usando opera\u00e7\u00f5es customizadas. Um truque comum \u00e9 adicionar atributos no struct usado como opera\u00e7\u00e3o: struct T { int attr ; T ( int a ) : attr ( a ) {}; // TODO: opera\u00e7\u00e3o customizada aqui }; A linha T(int a): attr(a) {} declara o construtor do struct T . Ela faz com que o atributo attr seja inicializado com o valor do par\u00e2metro a . Se houver mais de uma atribui\u00e7\u00e3o par\u00e2metro - atributo \u00e9 s\u00f3 usar , para separar as inicializa\u00e7\u00f5es. Example Fa\u00e7a uma nova implementa\u00e7\u00e3o da vari\u00e2ncia, dessa vez usando uma opera\u00e7\u00e3o customizada e com a chamada transform_reduce . Dica : passe a m\u00e9dia e o tamanho do vetor como atributo do struct .","title":"Parte 0 - revis\u00e3o"},{"location":"aulas/12-gpu-III/#parte-1-acesso-direto-a-vetores","text":"Apesar da thrust nos permitir acessar os dados de cada itera\u00e7\u00e3o, o acesso a elementos arbitr\u00e1rios do vetor n\u00e3o \u00e9 diretamente suportado. Apesar de ser poss\u00edvel fazer isto com iteradores e tuplas, vamos usar uma abordagem um pouco diferente: acessar o vetor diretamente e usar a thrust para fornecer ao nossa transforma\u00e7\u00e3o customizada o \u00edndice a ser usado. Vejamos abaixo um exemplo simples: #include <thrust/device_vector.h> #include <thrust/iterator/counting_iterator.h> #include <iostream> #include \"imagem.h\" struct raw_access { double * ptr ; raw_access ( double * ptr ) : ptr ( ptr ) {}; __device__ __host__ double operator ()( const int & i ) { return ptr [ i ] + 1 ; } }; int main () { thrust :: device_vector < double > vec ( 10 , 1 ); thrust :: counting_iterator < int > iter ( 0 ); raw_access ra ( thrust :: raw_pointer_cast ( vec . data ())); thrust :: transform ( iter , iter + 10 , vec . begin (), ra ); for ( const double & d : vec ) { std :: cout << d << \" \\n \" ; } return 0 ; } O struct raw_access recebe um ponteiro para o vetor e guarda em um atributo. Os valores recebidos em operator() s\u00e3o simplesmente os \u00edndices do vetor a serem tratados. Com isso, podemos fazer modifica\u00e7\u00f5es complexas em vetores trabalhando apenas com \u00edndices e acessos diretos a mem\u00f3ria. Warning A thrust \u00e9 bastante eficiente e os algoritmos foram implementados por especialistas em GPGPU. Prefira usar os recursos dispon\u00edveis na biblioteca se poss\u00edvel. Example Reimplemente o c\u00e1lculo das diferen\u00e7as adjancente usando uma transforma\u00e7\u00e3o customizada. Aproveite e j\u00e1 zere toda diferen\u00e7a negativa no novo vetor.","title":"Parte 1 - acesso direto a vetores"},{"location":"aulas/12-gpu-III/#parte-2-acesso-a-matrizes","text":"Assim como na CPU, podemos representar imagens como um vetor \"deitado\". O acesso ao elemento (i, j) \u00e9 feito como abaixo. img [ i * width + j ] = 10 ; Question Examine os arquivo imagem.cpp/h . Quais fun\u00e7\u00f5es s\u00e3o definidas e o qu\u00ea elas fazem? O filtro de m\u00e9dia \u00e9 um processamento de imagens simples muito usado para tirar suavizar imagens. Sua implementa\u00e7\u00e3o \u00e9 bastante simples. Dada uma imagem de entrada I I , a imagem de sa\u00edda O O \u00e9 dada pela seguinte express\u00e3o. O[i, j] = \\frac{I[i, j] + I[i-1, j] + I[i+1, j] + I[i, j-1] + I[i,j+1]}{5} O[i, j] = \\frac{I[i, j] + I[i-1, j] + I[i+1, j] + I[i, j-1] + I[i,j+1]}{5} Ambas as imagens tem o mesmo tamanho. Se o pixel acessado estiver fora da \u00e1rea v\u00e1lida da imagem ele deve ser considerado 0. Note Voc\u00ea pode converter qualquer imagem que tiver em seu computador para PGM usando o programa convert : $> convert imagem.png -compress None imagem.pgm Example Implemente um programa media_gpu que faz o processamento descrito acima usando thrust . Seu programa dever\u00e1 funcionar como abaixo. $> media_gpu in.pgm out.pgm Example Fa\u00e7a uma implementa\u00e7\u00e3o em CPU do filtro de m\u00e9dia. Chame-a de media_cpu . Ela dever\u00e1 funcionar de maneira id\u00eantica ao programa acima. Example Teste seu programa com diferentes tamanhos de imagens e compare os tempos de execu\u00e7\u00e3o. A partir de qual tamanho os tempos ficam equivalentes?","title":"Parte 2 - acesso a matrizes"},{"location":"aulas/13-gpu-rand/","text":"13 - N\u00fameros aleat\u00f3rios em GPU \u00b6 A \u00faltima etapa da nossa forma\u00e7\u00e3o em GPU \u00e9 a utiliza\u00e7\u00e3o de geradores de n\u00fameros pseudo-aleat\u00f3rios. Isso \u00e9 uma etapa importante para implementa\u00e7\u00e3o de algoritmos de simula\u00e7\u00e3o e otimiza\u00e7\u00e3o. Parte 0 - revis\u00e3o de n\u00fameros aleat\u00f3rios \u00b6 Um gerador de n\u00fameros pseudo-aleat\u00f3rios (RNG) \u00e9 um algoritmo determin\u00edstico que gera uma sequ\u00eancia de n\u00fameros que parece aleat\u00f3ria. Essa frase possui dois termos importantes que precisamos destrinchar: determin\u00edstico : Um RNG tipicamente recebe como entrada um inteiro seed (que representa uma sequ\u00eancia de bits \"aleat\u00f3ria\") e gera uma sequ\u00eancia de n\u00fameros baseada no seed . Ou seja, o algoritmo \u00e9 determin\u00edstico pois gera sempre a mesma sequ\u00eancia para uma determinada entrada ( seed ). parece aleat\u00f3ria : Se compararmos duas sequ\u00eancias de n\u00fameros, uma gerada por um RNG e outra por uma distribui\u00e7\u00e3o uniforme de verdade, n\u00e3o conseguimos dizer qual distribui\u00e7\u00e3o foi gerada pelo RNG . Ou seja, ao escolhermos um seed a sequ\u00eancia gerada ser\u00e1 sempre a mesma, mesmo se executarmos o programa em outras m\u00e1quinas. Isso torna a utiliza\u00e7\u00e3o de RNGs para experimentos bastante interessante: \u00e9 poss\u00edvel reproduzir os resultados feitos por outros desenvolvedores/cientistas. Para isto \u00e9 necess\u00e1rio que o programa permita escolher o seed da simula\u00e7\u00e3o; que o seed usado seja publicado junto com os resultados. Question E se quisermos gerar uma sequ\u00eancia diferente a cada execu\u00e7\u00e3o do programa? Como poder\u00edamos configurar o seed para que isto aconte\u00e7a? Muitas implementa\u00e7\u00f5es de RNGs s\u00e3o divididas em duas partes: engine : algoritmo que gera um inteiro cujos bits formam uma sequ\u00eancia pseudo-aleat\u00f3ria. distribution : utiliza os bits acima para retornar n\u00fameros que sigam alguma distribui\u00e7\u00e3o estat\u00edstica (como normal ou uniforme). As classes do cabe\u00e7alho <random> seguem este padr\u00e3o: std::random::default_random_engine gera bits aleat\u00f3rios todas as fun\u00e7\u00f5es std::random::*_distribution . Cada um dos exemplos abaixo gera n\u00fameros seguindo suas respectivas distribui\u00e7\u00f5es estat\u00edsticas e recebem os par\u00e2metros de cada distribui\u00e7\u00e3o. poisson_distribution uniform_int_distribution uniform_real_distribution normal_distribution . Vamos agora verificar na pr\u00e1tica essas propriedades criando um programa de testes. Example Crie um programa que leia um inteiro seed do terminal e: crie um objeto default_random_engine que o utilize como seed. mostre no terminal uma sequ\u00eancia de 10 n\u00fameros fracion\u00e1rios tirados de uma distribui\u00e7\u00e3o uniforme [25, 40] . Parte 1 - thrust e RNG \u00b6 A thrust cont\u00e9m uma API de gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios muito parecida com a API da biblioteca padr\u00e3o de C++. Question Consulte a documenta\u00e7\u00e3o oficial da thrust e encontre as p\u00e1ginas que descrevem os engines e distributions implementados. Vamos agora repetir o exerc\u00edcio da parte anterior em thrust . Example Crie um programa que leia um inteiro seed do terminal e: crie um objeto default_random_engine que o utilize como seed. mostre no terminal uma sequ\u00eancia de 10 n\u00fameros fracion\u00e1rios tirados de uma distribui\u00e7\u00e3o uniforme [25, 40] . Seu programa dever\u00e1 estar implementado usando os tipos definidos em thrust::random . Um ponto importante da API thrust para gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 que essas fun\u00e7\u00f5es podem ser chamadas dentro de opera\u00e7\u00f5es customizadas! Vamos continuar trabalhando com imagens no pr\u00f3ximo exerc\u00edcio, mas desta vez faremos uma opera\u00e7\u00e3o exatamente contr\u00e1ria: adicionaremos ru\u00eddo a uma imagem. Usaremos o seguinte algoritmo: para cada ponto da imagem sortearemos um n\u00famero entre 1 e 10 inclusive. Se o n\u00famero for 1 a cor atual deve ser substitu\u00edda por preto. Se o n\u00famero for 10 a cor atual deve ser substitu\u00edda por branco. Caso contr\u00e1rio n\u00e3o mexa na cor atual. Example Crie um programa que recebe uma imagem como argumento e escreva em uma segunda imagem o resultado do algoritmo de ru\u00eddo acima. Seu programa dever\u00e1 funcionar como abaixo: $> ruido in.pgm out.pgm Warning Mesmo que seu programa aparentemente n\u00e3o funcione, valide sua sa\u00edda com o professor. Parte 2 - seeds em programas paralelos \u00b6 Um desafio em programas paralelos \u00e9 gerar sequ\u00eancias pseudo-aleat\u00f3rias de qualidade. Se n\u00e3o tormarmos cuidado acabamos gerando os mesmos n\u00fameros em threads diferentes e desperdi\u00e7amos grande quantidade de trabalho! Em geral existem duas abordagens Abordagem 1 : usar seeds diferentes em cada thread. Abordagem 2 : usar a mesma seed em todas as threads, mas cada uma come\u00e7a em um ponto diferente da sequ\u00eancia daquela seed. Note que em ambos os casos os resultados dependem do n\u00famero de threads usadas! Como vimos em aulas anteriores, um RNG tem estado interno e n\u00e3o pode ser facilmente compartilhado entre v\u00e1rias threads. Example Implemente a abordagem 1 no exerc\u00edcio da parte anterior. Para isto voc\u00ea pode usar o \u00edndice recebido como seed Example Implemente a abordagem 2 no exerc\u00edcio da parte anterior. Para isto voc\u00ea pode descartar os i primeiros n\u00fameros aleat\u00f3rios gerados. Procure na documenta\u00e7\u00e3o oficial como fazer isto. Example Compare os dois resultados em termos de tempo e quantidade de ru\u00eddo presente na imagem de sa\u00edda.","title":"13 - N\u00fameros aleat\u00f3rios em GPU"},{"location":"aulas/13-gpu-rand/#13-numeros-aleatorios-em-gpu","text":"A \u00faltima etapa da nossa forma\u00e7\u00e3o em GPU \u00e9 a utiliza\u00e7\u00e3o de geradores de n\u00fameros pseudo-aleat\u00f3rios. Isso \u00e9 uma etapa importante para implementa\u00e7\u00e3o de algoritmos de simula\u00e7\u00e3o e otimiza\u00e7\u00e3o.","title":"13 - N\u00fameros aleat\u00f3rios em GPU"},{"location":"aulas/13-gpu-rand/#parte-0-revisao-de-numeros-aleatorios","text":"Um gerador de n\u00fameros pseudo-aleat\u00f3rios (RNG) \u00e9 um algoritmo determin\u00edstico que gera uma sequ\u00eancia de n\u00fameros que parece aleat\u00f3ria. Essa frase possui dois termos importantes que precisamos destrinchar: determin\u00edstico : Um RNG tipicamente recebe como entrada um inteiro seed (que representa uma sequ\u00eancia de bits \"aleat\u00f3ria\") e gera uma sequ\u00eancia de n\u00fameros baseada no seed . Ou seja, o algoritmo \u00e9 determin\u00edstico pois gera sempre a mesma sequ\u00eancia para uma determinada entrada ( seed ). parece aleat\u00f3ria : Se compararmos duas sequ\u00eancias de n\u00fameros, uma gerada por um RNG e outra por uma distribui\u00e7\u00e3o uniforme de verdade, n\u00e3o conseguimos dizer qual distribui\u00e7\u00e3o foi gerada pelo RNG . Ou seja, ao escolhermos um seed a sequ\u00eancia gerada ser\u00e1 sempre a mesma, mesmo se executarmos o programa em outras m\u00e1quinas. Isso torna a utiliza\u00e7\u00e3o de RNGs para experimentos bastante interessante: \u00e9 poss\u00edvel reproduzir os resultados feitos por outros desenvolvedores/cientistas. Para isto \u00e9 necess\u00e1rio que o programa permita escolher o seed da simula\u00e7\u00e3o; que o seed usado seja publicado junto com os resultados. Question E se quisermos gerar uma sequ\u00eancia diferente a cada execu\u00e7\u00e3o do programa? Como poder\u00edamos configurar o seed para que isto aconte\u00e7a? Muitas implementa\u00e7\u00f5es de RNGs s\u00e3o divididas em duas partes: engine : algoritmo que gera um inteiro cujos bits formam uma sequ\u00eancia pseudo-aleat\u00f3ria. distribution : utiliza os bits acima para retornar n\u00fameros que sigam alguma distribui\u00e7\u00e3o estat\u00edstica (como normal ou uniforme). As classes do cabe\u00e7alho <random> seguem este padr\u00e3o: std::random::default_random_engine gera bits aleat\u00f3rios todas as fun\u00e7\u00f5es std::random::*_distribution . Cada um dos exemplos abaixo gera n\u00fameros seguindo suas respectivas distribui\u00e7\u00f5es estat\u00edsticas e recebem os par\u00e2metros de cada distribui\u00e7\u00e3o. poisson_distribution uniform_int_distribution uniform_real_distribution normal_distribution . Vamos agora verificar na pr\u00e1tica essas propriedades criando um programa de testes. Example Crie um programa que leia um inteiro seed do terminal e: crie um objeto default_random_engine que o utilize como seed. mostre no terminal uma sequ\u00eancia de 10 n\u00fameros fracion\u00e1rios tirados de uma distribui\u00e7\u00e3o uniforme [25, 40] .","title":"Parte 0 - revis\u00e3o de n\u00fameros aleat\u00f3rios"},{"location":"aulas/13-gpu-rand/#parte-1-thrust-e-rng","text":"A thrust cont\u00e9m uma API de gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios muito parecida com a API da biblioteca padr\u00e3o de C++. Question Consulte a documenta\u00e7\u00e3o oficial da thrust e encontre as p\u00e1ginas que descrevem os engines e distributions implementados. Vamos agora repetir o exerc\u00edcio da parte anterior em thrust . Example Crie um programa que leia um inteiro seed do terminal e: crie um objeto default_random_engine que o utilize como seed. mostre no terminal uma sequ\u00eancia de 10 n\u00fameros fracion\u00e1rios tirados de uma distribui\u00e7\u00e3o uniforme [25, 40] . Seu programa dever\u00e1 estar implementado usando os tipos definidos em thrust::random . Um ponto importante da API thrust para gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 que essas fun\u00e7\u00f5es podem ser chamadas dentro de opera\u00e7\u00f5es customizadas! Vamos continuar trabalhando com imagens no pr\u00f3ximo exerc\u00edcio, mas desta vez faremos uma opera\u00e7\u00e3o exatamente contr\u00e1ria: adicionaremos ru\u00eddo a uma imagem. Usaremos o seguinte algoritmo: para cada ponto da imagem sortearemos um n\u00famero entre 1 e 10 inclusive. Se o n\u00famero for 1 a cor atual deve ser substitu\u00edda por preto. Se o n\u00famero for 10 a cor atual deve ser substitu\u00edda por branco. Caso contr\u00e1rio n\u00e3o mexa na cor atual. Example Crie um programa que recebe uma imagem como argumento e escreva em uma segunda imagem o resultado do algoritmo de ru\u00eddo acima. Seu programa dever\u00e1 funcionar como abaixo: $> ruido in.pgm out.pgm Warning Mesmo que seu programa aparentemente n\u00e3o funcione, valide sua sa\u00edda com o professor.","title":"Parte 1 - thrust e RNG"},{"location":"aulas/13-gpu-rand/#parte-2-seeds-em-programas-paralelos","text":"Um desafio em programas paralelos \u00e9 gerar sequ\u00eancias pseudo-aleat\u00f3rias de qualidade. Se n\u00e3o tormarmos cuidado acabamos gerando os mesmos n\u00fameros em threads diferentes e desperdi\u00e7amos grande quantidade de trabalho! Em geral existem duas abordagens Abordagem 1 : usar seeds diferentes em cada thread. Abordagem 2 : usar a mesma seed em todas as threads, mas cada uma come\u00e7a em um ponto diferente da sequ\u00eancia daquela seed. Note que em ambos os casos os resultados dependem do n\u00famero de threads usadas! Como vimos em aulas anteriores, um RNG tem estado interno e n\u00e3o pode ser facilmente compartilhado entre v\u00e1rias threads. Example Implemente a abordagem 1 no exerc\u00edcio da parte anterior. Para isto voc\u00ea pode usar o \u00edndice recebido como seed Example Implemente a abordagem 2 no exerc\u00edcio da parte anterior. Para isto voc\u00ea pode descartar os i primeiros n\u00fameros aleat\u00f3rios gerados. Procure na documenta\u00e7\u00e3o oficial como fazer isto. Example Compare os dois resultados em termos de tempo e quantidade de ru\u00eddo presente na imagem de sa\u00edda.","title":"Parte 2 - seeds em programas paralelos"},{"location":"aulas/14-gpu-rand-II/","text":"14 - Mais n\u00fameros aleat\u00f3rios em \u00b6 Na \u00faltima aula trabalhamos com algoritmos simples que faziam sorteios aleat\u00f3rios. Neste aula exploraremos novamente o Parte 0 - revis\u00e3o do algoritmo sequencial \u00b6 O algoritmo sequencial se baseia em sorteios de pontos dentro de um quadrado de lado 2 . Se a dist\u00e2ncia entre o ponto e o centro do quadrado for menor que 1 ent\u00e3o o ponto cai dentro do c\u00edrculo inscrito no quadrado. A quantidade de pontos que caem dentro do quadrado \u00e9 proporcional a \\pi \\pi . sum = 0 De i=0 at\u00e9 N : sorteie pontos x,y \\in [0,1] x,y \\in [0,1] se x^2 + y^2 \\leq 1 x^2 + y^2 \\leq 1 , sum += 1 devolva 4 * sum / N Parte 1 - implementa\u00e7\u00f5es inocentes \u00b6 Vamos iniciar nossa implementa\u00e7\u00e3o fazendo uma implementa\u00e7\u00e3o ing\u00eanua do programa acima. Primeiro iremos sortear todos os pares de pontos. Ent\u00e3o, iremos usar uma opera\u00e7\u00e3o customizada para fazer a compara\u00e7\u00e3o acima e fazer a soma final. Example Crie um programa que gera N=100 000 pares de n\u00fameros aleat\u00f3rios no intervalo [0,1] . Use a Abordagem 1 da aula passada (uma seed por thread). Armazene as componentes x x em um vetor rx e as componentes y y em um vetor ry . Example Fa\u00e7a uma transforma\u00e7\u00e3o customizada que cria um vetor dentro em que cada posi\u00e7\u00e3o i contem 1 se x[i], yi[i] satisfazem a condi\u00e7\u00e3o da parte 0 e 0 caso contr\u00e1rio. Use este vetor para calcular o \\pi \\pi Example Podemos usar acesso direto a elementos do vetor para eliminar o vetor tempor\u00e1rio do exerc\u00edcio acima. Fa\u00e7a isto e compare os tempos de execu\u00e7\u00e3o. Dica : use transform_reduce Parte 2 - economizando mem\u00f3ria e calibrando o RNG \u00b6 Uma grande desvantagem do programa acima \u00e9 que ele gasta muita mem\u00f3ria. Um transform \u00e9 feito s\u00f3 para gerar os n\u00fameros aleat\u00f3rios e armazenar nos vetores rx, ry ! Poder\u00edamos fazer isto direto na transforma\u00e7\u00e3o customizada do \u00faltimo exerc\u00edcio! Example Crie uma nova vers\u00e3o do seu exerc\u00edcio anterior, mas agora fa\u00e7a a gera\u00e7\u00e3o do par x,y x,y e a compara\u00e7\u00e3o em uma chamada s\u00f3. Ou seja, voc\u00ea estar\u00e1 juntando seus dois struct s em um s\u00f3. Seu struct agora receber\u00e1 \u00edndices e n\u00e3o mais as componentes (x, y) (x, y) do ponto. Agora nosso programa est\u00e1 mais eficiente: faz somente uma chamada \u00e0 GPU ( transform_reduce ) e n\u00e3o usa mem\u00f3ria auxiliar. Ainda assim h\u00e1 dois problemas: uma thread \u00e9 aberta s\u00f3 para sortear dois n\u00fameros e fazer uma compara\u00e7\u00e3o. Ou seja, geramos N=100 000 threads que fazem pouqu\u00edssimo trabalho. Isto pode significar que o custo de gerar todas essas threads seja grande perto do tempo que passamos realmente calculando o que precisamos! o RNG est\u00e1 gerando somente um n\u00famero por seed . Apesar do primeiro item n\u00e3o ser exatamente um grande o problema (pode ser que fique mais r\u00e1pido se balancear), o segundo item afeta diretamente a precis\u00e3o do nosso programa! Vamos realizar um experimento r\u00e1pido e testar se a quantidade de n\u00fameros sorteados pelo RNG afeta os resultados. Example Modifique seu struct para receber um n\u00famero N_thread que representar\u00e1 o n\u00famero de sorteios feitos por cada thread. Teste seu programa com N_thread=1 e N=100000 e verifique que ele continua funcionando. Vamos agora executar o experimento Question Com N= 100 000 , escreva abaixo o valor do pi para cada valor de N_thread : 1 : ____ 10 :____ 100 :_____ N\u00e3o se esque\u00e7a de calibrar tamb\u00e9m o n\u00famero N_parts de threads criadas! Ou seja, N == N_parts * N_threads . Esses resultados ocorrem pois o RNG garante que sua sequ\u00eancia parece aleat\u00f3ria, n\u00e3o que o primeiro n\u00famero de cada sequ\u00eancia ser\u00e1 aleat\u00f3rio! Ou seja, s\u00f3 conseguimos as propriedades de aleatoriedade se, para cada seed , gerarmos uma quantidade grande de n\u00fameros! Question Com N= 100 000 , escreva abaixo o tempo total do programa para cada valor de N_thread : 1 : ____ 10 :____ 100 :_____ Warning A primeira execu\u00e7\u00e3o de um programa em GPU \u00e9 muito lenta pois ela inclui um tempo de compila\u00e7\u00e3o e transfer\u00eancia do programa para a GPU. Os tempos para as execu\u00e7\u00f5es subsequentes devem ser bem menores e ter menos vari\u00e2ncia. Por outro lado, GPUs s\u00e3o muito boas em criar grande quantidade de threads e execut\u00e1-las. Ou seja, quanto mais trabalho \u00e9 feito por cada thread menos vantajoso ser\u00e1 sua paraleliza\u00e7\u00e3o em GPU! Como visto acima, o tempo aumenta proporcional a quantidade de trabalho feito nas threads.","title":"14 - Mais n\u00fameros aleat\u00f3rios em"},{"location":"aulas/14-gpu-rand-II/#14-mais-numeros-aleatorios-em","text":"Na \u00faltima aula trabalhamos com algoritmos simples que faziam sorteios aleat\u00f3rios. Neste aula exploraremos novamente o","title":"14 - Mais n\u00fameros aleat\u00f3rios em"},{"location":"aulas/14-gpu-rand-II/#parte-0-revisao-do-algoritmo-sequencial","text":"O algoritmo sequencial se baseia em sorteios de pontos dentro de um quadrado de lado 2 . Se a dist\u00e2ncia entre o ponto e o centro do quadrado for menor que 1 ent\u00e3o o ponto cai dentro do c\u00edrculo inscrito no quadrado. A quantidade de pontos que caem dentro do quadrado \u00e9 proporcional a \\pi \\pi . sum = 0 De i=0 at\u00e9 N : sorteie pontos x,y \\in [0,1] x,y \\in [0,1] se x^2 + y^2 \\leq 1 x^2 + y^2 \\leq 1 , sum += 1 devolva 4 * sum / N","title":"Parte 0 - revis\u00e3o do algoritmo sequencial"},{"location":"aulas/14-gpu-rand-II/#parte-1-implementacoes-inocentes","text":"Vamos iniciar nossa implementa\u00e7\u00e3o fazendo uma implementa\u00e7\u00e3o ing\u00eanua do programa acima. Primeiro iremos sortear todos os pares de pontos. Ent\u00e3o, iremos usar uma opera\u00e7\u00e3o customizada para fazer a compara\u00e7\u00e3o acima e fazer a soma final. Example Crie um programa que gera N=100 000 pares de n\u00fameros aleat\u00f3rios no intervalo [0,1] . Use a Abordagem 1 da aula passada (uma seed por thread). Armazene as componentes x x em um vetor rx e as componentes y y em um vetor ry . Example Fa\u00e7a uma transforma\u00e7\u00e3o customizada que cria um vetor dentro em que cada posi\u00e7\u00e3o i contem 1 se x[i], yi[i] satisfazem a condi\u00e7\u00e3o da parte 0 e 0 caso contr\u00e1rio. Use este vetor para calcular o \\pi \\pi Example Podemos usar acesso direto a elementos do vetor para eliminar o vetor tempor\u00e1rio do exerc\u00edcio acima. Fa\u00e7a isto e compare os tempos de execu\u00e7\u00e3o. Dica : use transform_reduce","title":"Parte 1 - implementa\u00e7\u00f5es inocentes"},{"location":"aulas/14-gpu-rand-II/#parte-2-economizando-memoria-e-calibrando-o-rng","text":"Uma grande desvantagem do programa acima \u00e9 que ele gasta muita mem\u00f3ria. Um transform \u00e9 feito s\u00f3 para gerar os n\u00fameros aleat\u00f3rios e armazenar nos vetores rx, ry ! Poder\u00edamos fazer isto direto na transforma\u00e7\u00e3o customizada do \u00faltimo exerc\u00edcio! Example Crie uma nova vers\u00e3o do seu exerc\u00edcio anterior, mas agora fa\u00e7a a gera\u00e7\u00e3o do par x,y x,y e a compara\u00e7\u00e3o em uma chamada s\u00f3. Ou seja, voc\u00ea estar\u00e1 juntando seus dois struct s em um s\u00f3. Seu struct agora receber\u00e1 \u00edndices e n\u00e3o mais as componentes (x, y) (x, y) do ponto. Agora nosso programa est\u00e1 mais eficiente: faz somente uma chamada \u00e0 GPU ( transform_reduce ) e n\u00e3o usa mem\u00f3ria auxiliar. Ainda assim h\u00e1 dois problemas: uma thread \u00e9 aberta s\u00f3 para sortear dois n\u00fameros e fazer uma compara\u00e7\u00e3o. Ou seja, geramos N=100 000 threads que fazem pouqu\u00edssimo trabalho. Isto pode significar que o custo de gerar todas essas threads seja grande perto do tempo que passamos realmente calculando o que precisamos! o RNG est\u00e1 gerando somente um n\u00famero por seed . Apesar do primeiro item n\u00e3o ser exatamente um grande o problema (pode ser que fique mais r\u00e1pido se balancear), o segundo item afeta diretamente a precis\u00e3o do nosso programa! Vamos realizar um experimento r\u00e1pido e testar se a quantidade de n\u00fameros sorteados pelo RNG afeta os resultados. Example Modifique seu struct para receber um n\u00famero N_thread que representar\u00e1 o n\u00famero de sorteios feitos por cada thread. Teste seu programa com N_thread=1 e N=100000 e verifique que ele continua funcionando. Vamos agora executar o experimento Question Com N= 100 000 , escreva abaixo o valor do pi para cada valor de N_thread : 1 : ____ 10 :____ 100 :_____ N\u00e3o se esque\u00e7a de calibrar tamb\u00e9m o n\u00famero N_parts de threads criadas! Ou seja, N == N_parts * N_threads . Esses resultados ocorrem pois o RNG garante que sua sequ\u00eancia parece aleat\u00f3ria, n\u00e3o que o primeiro n\u00famero de cada sequ\u00eancia ser\u00e1 aleat\u00f3rio! Ou seja, s\u00f3 conseguimos as propriedades de aleatoriedade se, para cada seed , gerarmos uma quantidade grande de n\u00fameros! Question Com N= 100 000 , escreva abaixo o tempo total do programa para cada valor de N_thread : 1 : ____ 10 :____ 100 :_____ Warning A primeira execu\u00e7\u00e3o de um programa em GPU \u00e9 muito lenta pois ela inclui um tempo de compila\u00e7\u00e3o e transfer\u00eancia do programa para a GPU. Os tempos para as execu\u00e7\u00f5es subsequentes devem ser bem menores e ter menos vari\u00e2ncia. Por outro lado, GPUs s\u00e3o muito boas em criar grande quantidade de threads e execut\u00e1-las. Ou seja, quanto mais trabalho \u00e9 feito por cada thread menos vantajoso ser\u00e1 sua paraleliza\u00e7\u00e3o em GPU! Como visto acima, o tempo aumenta proporcional a quantidade de trabalho feito nas threads.","title":"Parte 2 - economizando mem\u00f3ria e calibrando o RNG"},{"location":"projetos/","text":"\u00cdndice de projetos \u00b6 A disciplina \u00e9 baseada em 4 projetos organizados em 5 entregas. Projeto 1 \u00b6 O projeto 1 consiste em atividades incrementais feitas em sala nas aula 01-05. Seu objetivo \u00e9 escrever programas b\u00e1sicos em C++; praticar o uso de conteiners da STL; cria\u00e7\u00e3o de projetos CMake; introduzir o processo de benchmarking. As atividades est\u00e3o descritas nas aulas 1-5 e o projeto deve ser entregue at\u00e9 04/03 . Sua entrega dever\u00e1 atender a todos os requisitos de entrega Aloca\u00e7\u00e3o de alunos no PFE \u00b6 Nestes tr\u00eas projetos resolveremos o problema da Aloca\u00e7\u00e3o de alunos para o PFE usando diferentes t\u00e9cnicas de computa\u00e7\u00e3o paralela. Cada parte abaixo cont\u00e9m programas de valida\u00e7\u00e3o da implementa\u00e7\u00e3o feita. Esses programas ser\u00e3o atualizados continuamente durante o semestre. Parte 1: algoritmos e estrat\u00e9gias de solu\u00e7\u00e3o Parte 2: programa\u00e7\u00e3o multi-core Parte 3: GPGPU Parte 4: An\u00e1lise de desempenho As rubricas de avalia\u00e7\u00e3o est\u00e3o explicadas em cada parte. As seguintes regras ser\u00e3o adotadas para a nota final: M\u00ednimo de C na parte 4. Nenhum I nas partes de implementa\u00e7\u00e3o No m\u00e1ximo um D nas partes de implementa\u00e7\u00e3o A nota final \u00e9 a m\u00e9dia simples de todas as partes Requisitos b\u00e1sicos de projeto Caso os requisitos b\u00e1sicos de projeto n\u00e3o sejam cumpridos sua nota ser\u00e1 limitada a D .","title":"\u00cdndice"},{"location":"projetos/#indice-de-projetos","text":"A disciplina \u00e9 baseada em 4 projetos organizados em 5 entregas.","title":"\u00cdndice de projetos"},{"location":"projetos/#projeto-1","text":"O projeto 1 consiste em atividades incrementais feitas em sala nas aula 01-05. Seu objetivo \u00e9 escrever programas b\u00e1sicos em C++; praticar o uso de conteiners da STL; cria\u00e7\u00e3o de projetos CMake; introduzir o processo de benchmarking. As atividades est\u00e3o descritas nas aulas 1-5 e o projeto deve ser entregue at\u00e9 04/03 . Sua entrega dever\u00e1 atender a todos os requisitos de entrega","title":"Projeto 1"},{"location":"projetos/#alocacao-de-alunos-no-pfe","text":"Nestes tr\u00eas projetos resolveremos o problema da Aloca\u00e7\u00e3o de alunos para o PFE usando diferentes t\u00e9cnicas de computa\u00e7\u00e3o paralela. Cada parte abaixo cont\u00e9m programas de valida\u00e7\u00e3o da implementa\u00e7\u00e3o feita. Esses programas ser\u00e3o atualizados continuamente durante o semestre. Parte 1: algoritmos e estrat\u00e9gias de solu\u00e7\u00e3o Parte 2: programa\u00e7\u00e3o multi-core Parte 3: GPGPU Parte 4: An\u00e1lise de desempenho As rubricas de avalia\u00e7\u00e3o est\u00e3o explicadas em cada parte. As seguintes regras ser\u00e3o adotadas para a nota final: M\u00ednimo de C na parte 4. Nenhum I nas partes de implementa\u00e7\u00e3o No m\u00e1ximo um D nas partes de implementa\u00e7\u00e3o A nota final \u00e9 a m\u00e9dia simples de todas as partes Requisitos b\u00e1sicos de projeto Caso os requisitos b\u00e1sicos de projeto n\u00e3o sejam cumpridos sua nota ser\u00e1 limitada a D .","title":"Aloca\u00e7\u00e3o de alunos no PFE"},{"location":"projetos/checklist/","text":"Requisitos b\u00e1sicos de projeto \u00b6 Os seguintes pontos s\u00e3o obrigat\u00f3rios para todos projetos entregues na disciplina. Caso eles n\u00e3o sejam satisfeitos a nota final ser\u00e1 D . Se sua nota for maior que C e alguns desses itens for o \u00fanico problema da entrega voc\u00ea pode reentregar sem desconto de nota. Warning A condi\u00e7\u00e3o acima n\u00e3o vale para o projeto 0 - revis\u00e3o de C++ , j\u00e1 que grande parte dele \u00e9 realizar as tarefas abaixo. CMakeLists.txt gera um execut\u00e1vel por m\u00e9todo testado Relat\u00f3rio feito em Jupyter Notebook ou PWeave. Seu relat\u00f3rio deve conter as seguintes se\u00e7\u00f5es: Descri\u00e7\u00e3o do problema tratado Descri\u00e7\u00e3o dos testes feitos (tamanho de entradas, quantas execu\u00e7\u00f5es s\u00e3o feitas, como mediu tempo, infra usada) Organiza\u00e7\u00e3o em alto n\u00edvel de seu projeto. Vers\u00e3o j\u00e1 rodada do relat\u00f3rio exportada para PDF README.txt explicando como rodar seus testes (pode estar no relat\u00f3rio). Conjunto de testes automatizados (via script Python ou direto no relat\u00f3rio) Respeitar os formatos de entrada e sa\u00edda definidos nos enunciados. Seu programa dever\u00e1 retornar sempre o mesmo resultado. Os tempos ser\u00e3o ligeiramente diferentes em cada execu\u00e7\u00e3o, mas o resultado final dever\u00e1 ser sempre o mesmo.","title":"Requisitos b\u00e1sicos de projeto"},{"location":"projetos/checklist/#requisitos-basicos-de-projeto","text":"Os seguintes pontos s\u00e3o obrigat\u00f3rios para todos projetos entregues na disciplina. Caso eles n\u00e3o sejam satisfeitos a nota final ser\u00e1 D . Se sua nota for maior que C e alguns desses itens for o \u00fanico problema da entrega voc\u00ea pode reentregar sem desconto de nota. Warning A condi\u00e7\u00e3o acima n\u00e3o vale para o projeto 0 - revis\u00e3o de C++ , j\u00e1 que grande parte dele \u00e9 realizar as tarefas abaixo. CMakeLists.txt gera um execut\u00e1vel por m\u00e9todo testado Relat\u00f3rio feito em Jupyter Notebook ou PWeave. Seu relat\u00f3rio deve conter as seguintes se\u00e7\u00f5es: Descri\u00e7\u00e3o do problema tratado Descri\u00e7\u00e3o dos testes feitos (tamanho de entradas, quantas execu\u00e7\u00f5es s\u00e3o feitas, como mediu tempo, infra usada) Organiza\u00e7\u00e3o em alto n\u00edvel de seu projeto. Vers\u00e3o j\u00e1 rodada do relat\u00f3rio exportada para PDF README.txt explicando como rodar seus testes (pode estar no relat\u00f3rio). Conjunto de testes automatizados (via script Python ou direto no relat\u00f3rio) Respeitar os formatos de entrada e sa\u00edda definidos nos enunciados. Seu programa dever\u00e1 retornar sempre o mesmo resultado. Os tempos ser\u00e3o ligeiramente diferentes em cada execu\u00e7\u00e3o, mas o resultado final dever\u00e1 ser sempre o mesmo.","title":"Requisitos b\u00e1sicos de projeto"},{"location":"projetos/projeto-algoritmos/","text":"Algoritmos para problemas NP-completo \u00b6 Na primeira etapa do projeto nos concentraremos na resolu\u00e7\u00e3o do problema proposto de maneira eficiente. O arquivo solucao-ingenua.py cont\u00e9m uma solu\u00e7\u00e3o simplista escrita em Python. Este programa sempre encontra a melhor solu\u00e7\u00e3o, mas \u00e9 extremamente ing\u00eanuo . Por isso, ele tamb\u00e9m \u00e9 extremamente lento . Implementa\u00e7\u00e3o em C++ \u00b6 Nosso primeiro passo ser\u00e1 implementar esse mesmo programa em C++. O objetivo desta parte \u00e9 compreender o efeito da linguagem de programa\u00e7\u00e3o escolhida no desempenho da solu\u00e7\u00e3o. Sua implementa\u00e7\u00e3o dever\u00e1 se chamar busca_exaustiva_seq . Al\u00e9m de devolver a sa\u00edda no formato indicado no enunciado , seu programa tamb\u00e9m dever\u00e1 mostrar informa\u00e7\u00f5es de debug na sa\u00edda de erros. Sempre que for encontrada uma solu\u00e7\u00e3o melhor que a atual seu programa dever\u00e1 mostrar uma linha como a abaixo na sa\u00edda de erros: Melhor: sat pa1 pa2 pa3 ... pa(n_alunos) sat \u00e9 a satisfa\u00e7\u00e3o da solu\u00e7\u00e3o encontrada. pa1 at\u00e9 pa(n_alunos) \u00e9 o vetor contendo o projeto atribu\u00eddo a cada aluno. Seu programa dever\u00e1 encontrar exatamente as mesmas solu\u00e7\u00f5es que o programa em Python, pois ele \u00e9 uma tradu\u00e7\u00e3o fiel do algoritmo utilizado e deveria percorrer as solu\u00e7\u00f5es poss\u00edveis na mesma ordem. Valida\u00e7\u00e3o \u00b6 Para validar sua implementa\u00e7\u00e3o deste item voc\u00ea dever\u00e1 usar o script code/projeto-validacao/validacao-exaustivo.py . Este script recebe o seu execut\u00e1vel e roda uma s\u00e9rie de testes, verificando tanto a sa\u00edda esperada quanto as informa\u00e7\u00f5es de diagn\u00f3stico mostradas na sa\u00edda de erros. As entradas usadas est\u00e3o na pasta entradas . Busca local \u00b6 A estrat\u00e9gia de busca local visa encontrar boas solu\u00e7\u00f5es em um processo de melhora iterativa. A partir de uma solu\u00e7\u00e3o inicial (que pode ser aleat\u00f3ria), tentamos aplicar uma heur\u00edstica (truque) que pode melhorar a solu\u00e7\u00e3o (mas nunca piorar). Note que isto somente garante que a solu\u00e7\u00e3o ir\u00e1 melhorar iterativamente, por\u00e9m n\u00e3o garante que eventualmente chegaremos na melhor solu\u00e7\u00e3o poss\u00edvel. Al\u00e9m disto, a solu\u00e7\u00e3o encontrada muda conforme a solu\u00e7\u00e3o inicial nem todas as solu\u00e7\u00f5es s\u00e3o poss\u00edveis de serem encontradas. Uma boa heur\u00edstica geralmente \u00e9 baseada em alguma caracter\u00edstica da solu\u00e7\u00e3o \u00f3tima. Para este problema usaremos a seguinte propriedade n\u00e3o existe nenhuma dupla de alunos que, se for trocada de projeto, melhora a satisfa\u00e7\u00e3o global. Claramente se a solu\u00e7\u00e3o \u00e9 a melhor poss\u00edvel ent\u00e3o isto n\u00e3o pode acontecer. Nosso algoritmo ser\u00e1 escolha uma atribui\u00e7\u00e3o aluno-projeto v\u00e1lida aleatoriamente verifique se existe um par de alunos cuja troca de projeto melhore a satisfa\u00e7\u00e3o global se existir fa\u00e7a a troca e repita o teste acima se n\u00e3o existir retorne a solu\u00e7\u00e3o atual Ao repertirmos este algoritmo conseguimos solu\u00e7\u00f5es razo\u00e1veis muito rapidamente. Ele \u00e9 uma busca local pois \u00e9 feita usando apenas informa\u00e7\u00f5es de dois alunos. Ou seja, n\u00e3o \u00e9 poss\u00edvel garantir que essas solu\u00e7\u00f5es ir\u00e3o resultar na maior atribui\u00e7\u00e3o poss\u00edvel. Apenas que ao realizar trocas \u00e9 poss\u00edvel encontrar uma solu\u00e7\u00e3o melhor que a atual. Valida\u00e7\u00e3o \u00b6 O programa code/projeto-validacao/validacao-busca-local.py recebe sua implementa\u00e7\u00e3o e roda uma sequ\u00eancia de testes automatizados. Para funcionar ele espera que seu programa tenha o seguinte comportamento: \u00c9 poss\u00edvel configurar o n\u00famero de itera\u00e7\u00f5es que a busca local rodar\u00e1 usando a vari\u00e1vel de ambiente ITER . Se ela n\u00e3o for passada assuma ITER=100 000 . \u00c9 poss\u00edvel configurar o seed do gerador de n\u00fameros aleat\u00f3rios usando a vari\u00e1vel de ambiente SEED . Se ela n\u00e3o for passada assuma SEED=0 A cada troca seu algoritmo dever\u00e1 mostrar na sa\u00edda de erros a seguinte linha: Iter: sat pa1 pa2 pa3 ... pa(n_alunos) Sua implementa\u00e7\u00e3o est\u00e1 correta se obedece a duas condi\u00e7\u00f5es: A solu\u00e7\u00e3o melhora a cada itera\u00e7\u00e3o Ao final do processo n\u00e3o existe nenhuma dupla de alunos que, se trocada, melhoraria a satisfa\u00e7\u00e3o. O programa acima checa essas duas condi\u00e7\u00f5es para v\u00e1rias entradas. Branch and Bound \u00b6 Nosso algoritmo simpl\u00f3rio no item anterior faz v\u00e1rias escolhas recursivas ( branches ) e atualiza a melhor solu\u00e7\u00e3o encontrada at\u00e9 o momento. Imagine a seguinte situa\u00e7\u00e3o: em um certo momento temos uma solu\u00e7\u00e3o com valor 200 200 ainda faltam 3 alunos para serem alocados. a melhor solu\u00e7\u00e3o j\u00e1 encontrada tem valor 300 300 . Note que, mesmo se alocarmos os tr\u00eas alunos para sua primeira op\u00e7\u00e3o ficar\u00edamos com uma solu\u00e7\u00e3o de valor 275 < 300 275 < 300 . Ou seja, n\u00e3o precisamos tentar aloc\u00e1-los para projetos, pois mesmo que fa\u00e7amos o melhor poss\u00edvel ainda n\u00e3o conseguiremos superar a melhor solu\u00e7\u00e3o atual! Um bound \u00e9 uma estimativa otimista para o valor final de uma solu\u00e7\u00e3o parcial. Ou seja, dado que falta ainda alocar X alunos e tenho uma solu\u00e7\u00e3o de valor Y , uma estimativa otimista seria supor que todos ser\u00e3o alocados em sua primeira op\u00e7\u00e3o (solu\u00e7\u00e3o final com valor < Y + 25X < Y + 25X ). Warning Um bound \u00e9 uma estimativa otimista . Ou seja, pode n\u00e3o existir uma solu\u00e7\u00e3o com este valor! Um algoritmo branch and bound leva em conta essas estimativas em seu funcionamento: se o bound da solu\u00e7\u00e3o atual for pior que a solu\u00e7\u00e3o \u00f3tima atual, retorna continue a recurs\u00e3o caso contr\u00e1rio Esta t\u00e9cnica evita que nossa recurs\u00e3o entre em branches que n\u00e3o tem chance nenhuma de descobrir a melhor solu\u00e7\u00e3o (pois eles j\u00e1 s\u00e3o piores que uma solu\u00e7\u00e3o v\u00e1lida conhecida). Heur\u00edsticas de busca \u00b6 O algoritmo recursivo implementado em Python testa todas as possibilidades de maneira bastante inocente. Ele n\u00e3o leva em conta, por exemplo, as prefer\u00eancia dos alunos ou o fato de alocar um aluno em uma op\u00e7\u00e3o com satisfa\u00e7\u00e3o 0 n\u00e3o mudar o valor global da solu\u00e7\u00e3o. Este item envolve modificar a ordem que as solu\u00e7\u00f5es s\u00e3o analisadas de maneira a tentar encontrar primeiro as solu\u00e7\u00f5es de maior satisfa\u00e7\u00e3o global. Combinada com o item anterior, est\u00e1 estrat\u00e9gia pode diminuir consideravelmente o tempo de execu\u00e7\u00e3o. Ser\u00e1 obrigat\u00f3rio implementar este item em cima do branch and bound. \u2192","title":"Algoritmos para problemas NP-completo"},{"location":"projetos/projeto-algoritmos/#algoritmos-para-problemas-np-completo","text":"Na primeira etapa do projeto nos concentraremos na resolu\u00e7\u00e3o do problema proposto de maneira eficiente. O arquivo solucao-ingenua.py cont\u00e9m uma solu\u00e7\u00e3o simplista escrita em Python. Este programa sempre encontra a melhor solu\u00e7\u00e3o, mas \u00e9 extremamente ing\u00eanuo . Por isso, ele tamb\u00e9m \u00e9 extremamente lento .","title":"Algoritmos para problemas NP-completo"},{"location":"projetos/projeto-algoritmos/#implementacao-em-c","text":"Nosso primeiro passo ser\u00e1 implementar esse mesmo programa em C++. O objetivo desta parte \u00e9 compreender o efeito da linguagem de programa\u00e7\u00e3o escolhida no desempenho da solu\u00e7\u00e3o. Sua implementa\u00e7\u00e3o dever\u00e1 se chamar busca_exaustiva_seq . Al\u00e9m de devolver a sa\u00edda no formato indicado no enunciado , seu programa tamb\u00e9m dever\u00e1 mostrar informa\u00e7\u00f5es de debug na sa\u00edda de erros. Sempre que for encontrada uma solu\u00e7\u00e3o melhor que a atual seu programa dever\u00e1 mostrar uma linha como a abaixo na sa\u00edda de erros: Melhor: sat pa1 pa2 pa3 ... pa(n_alunos) sat \u00e9 a satisfa\u00e7\u00e3o da solu\u00e7\u00e3o encontrada. pa1 at\u00e9 pa(n_alunos) \u00e9 o vetor contendo o projeto atribu\u00eddo a cada aluno. Seu programa dever\u00e1 encontrar exatamente as mesmas solu\u00e7\u00f5es que o programa em Python, pois ele \u00e9 uma tradu\u00e7\u00e3o fiel do algoritmo utilizado e deveria percorrer as solu\u00e7\u00f5es poss\u00edveis na mesma ordem.","title":"Implementa\u00e7\u00e3o em C++"},{"location":"projetos/projeto-algoritmos/#validacao","text":"Para validar sua implementa\u00e7\u00e3o deste item voc\u00ea dever\u00e1 usar o script code/projeto-validacao/validacao-exaustivo.py . Este script recebe o seu execut\u00e1vel e roda uma s\u00e9rie de testes, verificando tanto a sa\u00edda esperada quanto as informa\u00e7\u00f5es de diagn\u00f3stico mostradas na sa\u00edda de erros. As entradas usadas est\u00e3o na pasta entradas .","title":"Valida\u00e7\u00e3o"},{"location":"projetos/projeto-algoritmos/#busca-local","text":"A estrat\u00e9gia de busca local visa encontrar boas solu\u00e7\u00f5es em um processo de melhora iterativa. A partir de uma solu\u00e7\u00e3o inicial (que pode ser aleat\u00f3ria), tentamos aplicar uma heur\u00edstica (truque) que pode melhorar a solu\u00e7\u00e3o (mas nunca piorar). Note que isto somente garante que a solu\u00e7\u00e3o ir\u00e1 melhorar iterativamente, por\u00e9m n\u00e3o garante que eventualmente chegaremos na melhor solu\u00e7\u00e3o poss\u00edvel. Al\u00e9m disto, a solu\u00e7\u00e3o encontrada muda conforme a solu\u00e7\u00e3o inicial nem todas as solu\u00e7\u00f5es s\u00e3o poss\u00edveis de serem encontradas. Uma boa heur\u00edstica geralmente \u00e9 baseada em alguma caracter\u00edstica da solu\u00e7\u00e3o \u00f3tima. Para este problema usaremos a seguinte propriedade n\u00e3o existe nenhuma dupla de alunos que, se for trocada de projeto, melhora a satisfa\u00e7\u00e3o global. Claramente se a solu\u00e7\u00e3o \u00e9 a melhor poss\u00edvel ent\u00e3o isto n\u00e3o pode acontecer. Nosso algoritmo ser\u00e1 escolha uma atribui\u00e7\u00e3o aluno-projeto v\u00e1lida aleatoriamente verifique se existe um par de alunos cuja troca de projeto melhore a satisfa\u00e7\u00e3o global se existir fa\u00e7a a troca e repita o teste acima se n\u00e3o existir retorne a solu\u00e7\u00e3o atual Ao repertirmos este algoritmo conseguimos solu\u00e7\u00f5es razo\u00e1veis muito rapidamente. Ele \u00e9 uma busca local pois \u00e9 feita usando apenas informa\u00e7\u00f5es de dois alunos. Ou seja, n\u00e3o \u00e9 poss\u00edvel garantir que essas solu\u00e7\u00f5es ir\u00e3o resultar na maior atribui\u00e7\u00e3o poss\u00edvel. Apenas que ao realizar trocas \u00e9 poss\u00edvel encontrar uma solu\u00e7\u00e3o melhor que a atual.","title":"Busca local"},{"location":"projetos/projeto-algoritmos/#validacao_1","text":"O programa code/projeto-validacao/validacao-busca-local.py recebe sua implementa\u00e7\u00e3o e roda uma sequ\u00eancia de testes automatizados. Para funcionar ele espera que seu programa tenha o seguinte comportamento: \u00c9 poss\u00edvel configurar o n\u00famero de itera\u00e7\u00f5es que a busca local rodar\u00e1 usando a vari\u00e1vel de ambiente ITER . Se ela n\u00e3o for passada assuma ITER=100 000 . \u00c9 poss\u00edvel configurar o seed do gerador de n\u00fameros aleat\u00f3rios usando a vari\u00e1vel de ambiente SEED . Se ela n\u00e3o for passada assuma SEED=0 A cada troca seu algoritmo dever\u00e1 mostrar na sa\u00edda de erros a seguinte linha: Iter: sat pa1 pa2 pa3 ... pa(n_alunos) Sua implementa\u00e7\u00e3o est\u00e1 correta se obedece a duas condi\u00e7\u00f5es: A solu\u00e7\u00e3o melhora a cada itera\u00e7\u00e3o Ao final do processo n\u00e3o existe nenhuma dupla de alunos que, se trocada, melhoraria a satisfa\u00e7\u00e3o. O programa acima checa essas duas condi\u00e7\u00f5es para v\u00e1rias entradas.","title":"Valida\u00e7\u00e3o"},{"location":"projetos/projeto-algoritmos/#branch-and-bound","text":"Nosso algoritmo simpl\u00f3rio no item anterior faz v\u00e1rias escolhas recursivas ( branches ) e atualiza a melhor solu\u00e7\u00e3o encontrada at\u00e9 o momento. Imagine a seguinte situa\u00e7\u00e3o: em um certo momento temos uma solu\u00e7\u00e3o com valor 200 200 ainda faltam 3 alunos para serem alocados. a melhor solu\u00e7\u00e3o j\u00e1 encontrada tem valor 300 300 . Note que, mesmo se alocarmos os tr\u00eas alunos para sua primeira op\u00e7\u00e3o ficar\u00edamos com uma solu\u00e7\u00e3o de valor 275 < 300 275 < 300 . Ou seja, n\u00e3o precisamos tentar aloc\u00e1-los para projetos, pois mesmo que fa\u00e7amos o melhor poss\u00edvel ainda n\u00e3o conseguiremos superar a melhor solu\u00e7\u00e3o atual! Um bound \u00e9 uma estimativa otimista para o valor final de uma solu\u00e7\u00e3o parcial. Ou seja, dado que falta ainda alocar X alunos e tenho uma solu\u00e7\u00e3o de valor Y , uma estimativa otimista seria supor que todos ser\u00e3o alocados em sua primeira op\u00e7\u00e3o (solu\u00e7\u00e3o final com valor < Y + 25X < Y + 25X ). Warning Um bound \u00e9 uma estimativa otimista . Ou seja, pode n\u00e3o existir uma solu\u00e7\u00e3o com este valor! Um algoritmo branch and bound leva em conta essas estimativas em seu funcionamento: se o bound da solu\u00e7\u00e3o atual for pior que a solu\u00e7\u00e3o \u00f3tima atual, retorna continue a recurs\u00e3o caso contr\u00e1rio Esta t\u00e9cnica evita que nossa recurs\u00e3o entre em branches que n\u00e3o tem chance nenhuma de descobrir a melhor solu\u00e7\u00e3o (pois eles j\u00e1 s\u00e3o piores que uma solu\u00e7\u00e3o v\u00e1lida conhecida).","title":"Branch and Bound"},{"location":"projetos/projeto-algoritmos/#heuristicas-de-busca","text":"O algoritmo recursivo implementado em Python testa todas as possibilidades de maneira bastante inocente. Ele n\u00e3o leva em conta, por exemplo, as prefer\u00eancia dos alunos ou o fato de alocar um aluno em uma op\u00e7\u00e3o com satisfa\u00e7\u00e3o 0 n\u00e3o mudar o valor global da solu\u00e7\u00e3o. Este item envolve modificar a ordem que as solu\u00e7\u00f5es s\u00e3o analisadas de maneira a tentar encontrar primeiro as solu\u00e7\u00f5es de maior satisfa\u00e7\u00e3o global. Combinada com o item anterior, est\u00e1 estrat\u00e9gia pode diminuir consideravelmente o tempo de execu\u00e7\u00e3o. Ser\u00e1 obrigat\u00f3rio implementar este item em cima do branch and bound. \u2192","title":"Heur\u00edsticas de busca"},{"location":"projetos/projeto-multi-core/","text":"Multi-core usando OpenMP \u00b6 O primeiro projeto consiste em implementar uma solu\u00e7\u00e3o multi-core para o problema da Aloca\u00e7\u00e3o de alunos do PFE . Para facilitar sua ele ser\u00e1 dividido em duas partes. Os algoritmos ser\u00e3o constru\u00eddos em cima da primeira parte , que tratou de estrat\u00e9gias eficientes de resolu\u00e7\u00e3o do problema. Avalia\u00e7\u00e3o \u00b6 Requisitos b\u00e1sicos cumpridos Relat\u00f3rio comparando desempenho Python vs C++ A entrega final ser\u00e1 dividida em duas partes: estrat\u00e9gias de paraleliza\u00e7\u00e3o (55%) e relat\u00f3rio de desempenho (45%). Requisitos b\u00e1sicos de projeto Caso os requisitos b\u00e1sicos de projeto n\u00e3o sejam cumpridos sua nota ser\u00e1 limitada a D . Estrat\u00e9gias de paraleliza\u00e7\u00e3o \u00b6 Cada funcionalidade do projeto corretamente implementada de maneira sequencia E paralela corresponde a um conceito neste item. Conceito D : implementou a busca local e mostrou ganhos de desempenho proporcionais ao n\u00famero de processadores dispon\u00edveis. Voc\u00ea dever\u00e1 produzir execut\u00e1veis nomeados busca_local_seq e busca_local_par . Conceito C : implementou o algoritmo recursivo ing\u00eanuo, mostrando ganhos de desempenho proporcionais ao n\u00famero de processadores dispon\u00edveis. Voc\u00ea dever\u00e1 produzir execut\u00e1veis nomeados busca_exaustiva_seq e busca_exaustiva_par . Conceito B : implementou o Branch and Bound usando a fun\u00e7\u00e3o de bound mostrada no enunciado e compartilhando a melhor solu\u00e7\u00e3o entre as threads. Voc\u00ea dever\u00e1 produzir execut\u00e1veis nomeados branch_bound_seq e branch_bound_par . Conceito B+ : implementou uma heur\u00edstica de busca no algoritmo sequencial e no paralelo e mostrou que h\u00e1 grandes ganhos de desempenho em seu uso. Voc\u00ea dever\u00e1 produzir execut\u00e1veis nomeados branch_bound_heuristico_seq e branch_bound_heuristico_par . Conceito A+ : implementou uma solu\u00e7\u00e3o h\u00edbrida, com uma thread rodando busca local e as restantes executando o Branch and Bound . Voc\u00ea dever\u00e1 produzir execut\u00e1veis nomeados branch_bound_hibrido_seq e branch_bound_hibrido_par . Os conceitos acima est\u00e3o apresentados em ordem de dificuldade. Em geral, a implementa\u00e7\u00e3o de um conceito se apoia nas implementa\u00e7\u00f5es dos conceitos anteriores. Relat\u00f3rio \u00b6 Voc\u00ea dever\u00e1 produzir um relat\u00f3rio de desempenho seguindo os moldes do Projeto 1. Ele ser\u00e1 avaliado de acordo com a rubrica de relat\u00f3rios da disciplina Os testes de seu projeto poder\u00e3o ser limitados por tempo. Voc\u00ea pode limitar seu programa para rodar at\u00e9 no m\u00e1ximo 20 minutos. O objetivo \u00e9 rodar entradas o maiores poss\u00edvel dentre","title":"Multi-core usando OpenMP"},{"location":"projetos/projeto-multi-core/#multi-core-usando-openmp","text":"O primeiro projeto consiste em implementar uma solu\u00e7\u00e3o multi-core para o problema da Aloca\u00e7\u00e3o de alunos do PFE . Para facilitar sua ele ser\u00e1 dividido em duas partes. Os algoritmos ser\u00e3o constru\u00eddos em cima da primeira parte , que tratou de estrat\u00e9gias eficientes de resolu\u00e7\u00e3o do problema.","title":"Multi-core usando OpenMP"},{"location":"projetos/projeto-multi-core/#avaliacao","text":"Requisitos b\u00e1sicos cumpridos Relat\u00f3rio comparando desempenho Python vs C++ A entrega final ser\u00e1 dividida em duas partes: estrat\u00e9gias de paraleliza\u00e7\u00e3o (55%) e relat\u00f3rio de desempenho (45%). Requisitos b\u00e1sicos de projeto Caso os requisitos b\u00e1sicos de projeto n\u00e3o sejam cumpridos sua nota ser\u00e1 limitada a D .","title":"Avalia\u00e7\u00e3o"},{"location":"projetos/projeto-multi-core/#estrategias-de-paralelizacao","text":"Cada funcionalidade do projeto corretamente implementada de maneira sequencia E paralela corresponde a um conceito neste item. Conceito D : implementou a busca local e mostrou ganhos de desempenho proporcionais ao n\u00famero de processadores dispon\u00edveis. Voc\u00ea dever\u00e1 produzir execut\u00e1veis nomeados busca_local_seq e busca_local_par . Conceito C : implementou o algoritmo recursivo ing\u00eanuo, mostrando ganhos de desempenho proporcionais ao n\u00famero de processadores dispon\u00edveis. Voc\u00ea dever\u00e1 produzir execut\u00e1veis nomeados busca_exaustiva_seq e busca_exaustiva_par . Conceito B : implementou o Branch and Bound usando a fun\u00e7\u00e3o de bound mostrada no enunciado e compartilhando a melhor solu\u00e7\u00e3o entre as threads. Voc\u00ea dever\u00e1 produzir execut\u00e1veis nomeados branch_bound_seq e branch_bound_par . Conceito B+ : implementou uma heur\u00edstica de busca no algoritmo sequencial e no paralelo e mostrou que h\u00e1 grandes ganhos de desempenho em seu uso. Voc\u00ea dever\u00e1 produzir execut\u00e1veis nomeados branch_bound_heuristico_seq e branch_bound_heuristico_par . Conceito A+ : implementou uma solu\u00e7\u00e3o h\u00edbrida, com uma thread rodando busca local e as restantes executando o Branch and Bound . Voc\u00ea dever\u00e1 produzir execut\u00e1veis nomeados branch_bound_hibrido_seq e branch_bound_hibrido_par . Os conceitos acima est\u00e3o apresentados em ordem de dificuldade. Em geral, a implementa\u00e7\u00e3o de um conceito se apoia nas implementa\u00e7\u00f5es dos conceitos anteriores.","title":"Estrat\u00e9gias de paraleliza\u00e7\u00e3o"},{"location":"projetos/projeto-multi-core/#relatorio","text":"Voc\u00ea dever\u00e1 produzir um relat\u00f3rio de desempenho seguindo os moldes do Projeto 1. Ele ser\u00e1 avaliado de acordo com a rubrica de relat\u00f3rios da disciplina Os testes de seu projeto poder\u00e3o ser limitados por tempo. Voc\u00ea pode limitar seu programa para rodar at\u00e9 no m\u00e1ximo 20 minutos. O objetivo \u00e9 rodar entradas o maiores poss\u00edvel dentre","title":"Relat\u00f3rio"},{"location":"projetos/projeto-pfe/","text":"Aloca\u00e7\u00e3o de alunos para o PFE \u00b6 Neste semeste trabalharemos com um problema bastante familiar para os alunos do 8/9 semestre: a atribui\u00e7\u00e3o de alunos a projetos no Projeto Final de Engenharia. Cada aluno escolhe cinco op\u00e7\u00f5es de projetos de acordo com sua prefer\u00eancia. Cada projeto receber\u00e1 exatamente tr\u00eas alunos. Uma solu\u00e7\u00e3o para este problema \u00e9 uma atribui\u00e7\u00e3o de tr\u00eas alunos para cada projeto. Claramente algumas solu\u00e7\u00f5es s\u00e3o melhores pois maior quantidade de alunos est\u00e1 alocada em projetos que tem maior prefer\u00eancia. Para quantificar esta qualidade de cada solu\u00e7\u00e3o vamos adotar a seguinte estrat\u00e9gia: 5^2 = 25 5^2 = 25 se foi colocado na primeira op\u00e7\u00e3o .... 2^2 = 4 2^2 = 4 se foi colocado em sua quarta op\u00e7\u00e3o 1 1 se foi colocado em sua \u00faltima op\u00e7\u00e3o 0 0 se n\u00e3o foi poss\u00edvel coloc\u00e1-lo em nenhuma de suas op\u00e7\u00f5es. a satisfa\u00e7\u00e3o \"global\" de uma solu\u00e7\u00e3o \u00e9 a soma da satisfa\u00e7\u00e3o individual de todos alunos. Desta maneira, gostar\u00edamos de encontrar a melhor solu\u00e7\u00e3o (a que possui maior satisfa\u00e7\u00e3o global) dados o n\u00famero de alunos, o n\u00famero de projetos e at\u00e9 5 op\u00e7\u00f5es de projetos em ordem de prefer\u00eancia para cada aluno. Justificativa \u00b6 Apesar de parecer simples, este problema \u00e9 NP-completo : n\u00e3o existe um m\u00e9todo que encontra a solu\u00e7\u00e3o com maior satisfa\u00e7\u00e3o global em tempo polinomial. Al\u00e9m disso, n\u00e3o existe uma maneira que verifique se uma solu\u00e7\u00e3o \u00e9 a melhor poss\u00edvel em tempo polinomial. Ou seja, trabalhar com este problema invariavelmente envolver\u00e1 enumerar todas as possibilidades. Claramente este \u00e9 um problema onde SuperComputa\u00e7\u00e3o \u00e9 necess\u00e1ria! Veremos que t\u00e9cnicas de computa\u00e7\u00e3o paralela podem diminuir consideravelmente o tempo de execu\u00e7\u00e3o de nosso programa. Outra fonte de ideias para acelerar a resolu\u00e7\u00e3o deste problema \u00e9 a utiliza\u00e7\u00e3o de t\u00e9cnicas de otimiza\u00e7\u00e3o discreta, que s\u00e3o nada mais do que explorar alguma caracter\u00edstica do problema que estamos tratando para melhorar nossas solu\u00e7\u00f5es. Podemos us\u00e1-las para encontrar boas solu\u00e7\u00f5es sem enumerar todas ou para evitar enumerar solu\u00e7\u00f5es que com certeza n\u00e3o s\u00e3o as \u00f3timas. Por\u00e9m, nem sempre \u00e9 f\u00e1cil paralelizar estas t\u00e9cnicas e este ser\u00e1 um dos desafios dos projetos deste semestre. Entrada e sa\u00edda \u00b6 O formato de entrada do programa estar\u00e1 no formato abaixo. n_alunos n_projetos n_choices p(1) p(2) ... p(n_choices) ..... # repetido n_alunos vezes n_alunos \u00e9 o n\u00famero de alunos n_projetos \u00e9 o n\u00famero de projetos existentes cada linha seguinte representa as cinco prioridades de um aluno. p(1), ..., p(n_choices) \u00e9 um n\u00famero entre 0 e n_projetos-1 , sem repeti\u00e7\u00f5es A sa\u00edda do programa dever\u00e1 estar no formato abaixo. satisfacao opt pa1 pa2 pa3 ... pa(n_alunos) satisfacao opt \u00e9 1 se a solu\u00e7\u00e3o encontrada \u00e9 a melhor poss\u00edvel, 0 caso contr\u00e1rio pa(i) cont\u00e9m a qual projeto o aluno i foi atribu\u00eddo A pasta code/projeto cont\u00e9m exemplos de entradas e sa\u00edda esperadas. Seu programa dever\u00e1 funcionar com estas entradas e produzir sa\u00eddas exatamente neste formato. Avisos Se existirem duas solu\u00e7\u00f5es com mesma satisfa\u00e7\u00e3o qualquer uma pode ser retornada. Informa\u00e7\u00f5es de debug devem ser enviadas para a sa\u00edda de erros ( std::cerr ). A sa\u00edda de seu programa dever\u00e1 estar exatamente no formato mostrado na se\u00e7\u00e3o anterior. Simplifica\u00e7\u00f5es: \u00b6 Seu programa pode assumir o seguinte: n_alunos \u00e9 divis\u00edvel por 3 n_projetos \u00e9 exatamente n_alunos/3 Isto facilita muito o problema, pois nunca conseguimos montar uma solu\u00e7\u00e3o inv\u00e1lida nem precisamos levar em conta a distribui\u00e7\u00e3o de alunos ao criar solu\u00e7\u00f5es. Entregas \u00b6 Os projetos da disciplina envolver\u00e3o resolver este problema usando diferentes tecnologias e iremos comparar os desempenhos obtidos com cada uma.","title":"Aloca\u00e7\u00e3o de alunos para o PFE"},{"location":"projetos/projeto-pfe/#alocacao-de-alunos-para-o-pfe","text":"Neste semeste trabalharemos com um problema bastante familiar para os alunos do 8/9 semestre: a atribui\u00e7\u00e3o de alunos a projetos no Projeto Final de Engenharia. Cada aluno escolhe cinco op\u00e7\u00f5es de projetos de acordo com sua prefer\u00eancia. Cada projeto receber\u00e1 exatamente tr\u00eas alunos. Uma solu\u00e7\u00e3o para este problema \u00e9 uma atribui\u00e7\u00e3o de tr\u00eas alunos para cada projeto. Claramente algumas solu\u00e7\u00f5es s\u00e3o melhores pois maior quantidade de alunos est\u00e1 alocada em projetos que tem maior prefer\u00eancia. Para quantificar esta qualidade de cada solu\u00e7\u00e3o vamos adotar a seguinte estrat\u00e9gia: 5^2 = 25 5^2 = 25 se foi colocado na primeira op\u00e7\u00e3o .... 2^2 = 4 2^2 = 4 se foi colocado em sua quarta op\u00e7\u00e3o 1 1 se foi colocado em sua \u00faltima op\u00e7\u00e3o 0 0 se n\u00e3o foi poss\u00edvel coloc\u00e1-lo em nenhuma de suas op\u00e7\u00f5es. a satisfa\u00e7\u00e3o \"global\" de uma solu\u00e7\u00e3o \u00e9 a soma da satisfa\u00e7\u00e3o individual de todos alunos. Desta maneira, gostar\u00edamos de encontrar a melhor solu\u00e7\u00e3o (a que possui maior satisfa\u00e7\u00e3o global) dados o n\u00famero de alunos, o n\u00famero de projetos e at\u00e9 5 op\u00e7\u00f5es de projetos em ordem de prefer\u00eancia para cada aluno.","title":"Aloca\u00e7\u00e3o de alunos para o PFE"},{"location":"projetos/projeto-pfe/#justificativa","text":"Apesar de parecer simples, este problema \u00e9 NP-completo : n\u00e3o existe um m\u00e9todo que encontra a solu\u00e7\u00e3o com maior satisfa\u00e7\u00e3o global em tempo polinomial. Al\u00e9m disso, n\u00e3o existe uma maneira que verifique se uma solu\u00e7\u00e3o \u00e9 a melhor poss\u00edvel em tempo polinomial. Ou seja, trabalhar com este problema invariavelmente envolver\u00e1 enumerar todas as possibilidades. Claramente este \u00e9 um problema onde SuperComputa\u00e7\u00e3o \u00e9 necess\u00e1ria! Veremos que t\u00e9cnicas de computa\u00e7\u00e3o paralela podem diminuir consideravelmente o tempo de execu\u00e7\u00e3o de nosso programa. Outra fonte de ideias para acelerar a resolu\u00e7\u00e3o deste problema \u00e9 a utiliza\u00e7\u00e3o de t\u00e9cnicas de otimiza\u00e7\u00e3o discreta, que s\u00e3o nada mais do que explorar alguma caracter\u00edstica do problema que estamos tratando para melhorar nossas solu\u00e7\u00f5es. Podemos us\u00e1-las para encontrar boas solu\u00e7\u00f5es sem enumerar todas ou para evitar enumerar solu\u00e7\u00f5es que com certeza n\u00e3o s\u00e3o as \u00f3timas. Por\u00e9m, nem sempre \u00e9 f\u00e1cil paralelizar estas t\u00e9cnicas e este ser\u00e1 um dos desafios dos projetos deste semestre.","title":"Justificativa"},{"location":"projetos/projeto-pfe/#entrada-e-saida","text":"O formato de entrada do programa estar\u00e1 no formato abaixo. n_alunos n_projetos n_choices p(1) p(2) ... p(n_choices) ..... # repetido n_alunos vezes n_alunos \u00e9 o n\u00famero de alunos n_projetos \u00e9 o n\u00famero de projetos existentes cada linha seguinte representa as cinco prioridades de um aluno. p(1), ..., p(n_choices) \u00e9 um n\u00famero entre 0 e n_projetos-1 , sem repeti\u00e7\u00f5es A sa\u00edda do programa dever\u00e1 estar no formato abaixo. satisfacao opt pa1 pa2 pa3 ... pa(n_alunos) satisfacao opt \u00e9 1 se a solu\u00e7\u00e3o encontrada \u00e9 a melhor poss\u00edvel, 0 caso contr\u00e1rio pa(i) cont\u00e9m a qual projeto o aluno i foi atribu\u00eddo A pasta code/projeto cont\u00e9m exemplos de entradas e sa\u00edda esperadas. Seu programa dever\u00e1 funcionar com estas entradas e produzir sa\u00eddas exatamente neste formato. Avisos Se existirem duas solu\u00e7\u00f5es com mesma satisfa\u00e7\u00e3o qualquer uma pode ser retornada. Informa\u00e7\u00f5es de debug devem ser enviadas para a sa\u00edda de erros ( std::cerr ). A sa\u00edda de seu programa dever\u00e1 estar exatamente no formato mostrado na se\u00e7\u00e3o anterior.","title":"Entrada e sa\u00edda"},{"location":"projetos/projeto-pfe/#simplificacoes","text":"Seu programa pode assumir o seguinte: n_alunos \u00e9 divis\u00edvel por 3 n_projetos \u00e9 exatamente n_alunos/3 Isto facilita muito o problema, pois nunca conseguimos montar uma solu\u00e7\u00e3o inv\u00e1lida nem precisamos levar em conta a distribui\u00e7\u00e3o de alunos ao criar solu\u00e7\u00f5es.","title":"Simplifica\u00e7\u00f5es:"},{"location":"projetos/projeto-pfe/#entregas","text":"Os projetos da disciplina envolver\u00e3o resolver este problema usando diferentes tecnologias e iremos comparar os desempenhos obtidos com cada uma.","title":"Entregas"}]}