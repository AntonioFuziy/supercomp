{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SuperComputa\u00e7\u00e3o \u00b6 Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2020/1. Professor : Igor Montagner Monitores : Leonardo Pereira Medeiros Raphael Marques da Costa Objetivos \u00b6 Ao final da disciplina o aluno ser\u00e1 capaz de: Desenvolver algoritmos usando recursos de computa\u00e7\u00e3o paralela/distribu\u00edda para ganhos de desempenho da aplica\u00e7\u00e3o final; Aplicar estrutura l\u00f3gica de computa\u00e7\u00e3o distribu\u00edda para o desenvolvimento de algoritmos multitarefas; Usar GPGPU para computa\u00e7\u00e3o num\u00e9rica e comparar com solu\u00e7\u00f5es baseadas em CPU Planejar e projetar sistemas de computa\u00e7\u00e3o de alto desempenho; Analisar a complexidade dos algoritmos paralelos e a efici\u00eancia de uma implementa\u00e7\u00e3o particular, identificando as medidas de desempenho mais adequadas para esta tarefa; Aplicar recursos espec\u00edfico de sistemas operacionais para melhorar o desempenho de algoritmos; Desenvolver aplica\u00e7\u00f5es que utilizam protocolos otimizados para paraleliza\u00e7\u00e3o. Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os projetos ter\u00e3o dura\u00e7\u00e3o de duas semanas e ser\u00e3o incrementais com os seguintes pesos para m\u00e9dia de projetos: Projeto 0 - revis\u00e3o de C++ (10%) Projeto 1 - multi core (30%) Projeto 2 - GPU (30%) Projeto 3 - MPI (30%) Atividades de acompanhamento ser\u00e3o disponibilizadas durante o semestre. Estas atividades ter\u00e3o corre\u00e7\u00e3o autom\u00e1tica e sua realiza\u00e7\u00e3o \u00e9 opcional. Entregas atrasadas n\u00e3o ser\u00e3o aceitas para nota . A m\u00e9dia final \u00e9 dada por \\max \\begin{cases}0,4 \\times MP + 0,5\\times MProj + 0,1\\times AT \\\\ 0,5 \\times MP + 0,5 \\times MProj \\end{cases} \\max \\begin{cases}0,4 \\times MP + 0,5\\times MProj + 0,1\\times AT \\\\ 0,5 \\times MP + 0,5 \\times MProj \\end{cases} Condi\u00e7\u00f5es de barreira Caso as seguintes condi\u00e7\u00f5es n\u00e3o sejam cumpridas, a nota final ser\u00e1 D (4,0): Todos os projetos foram entregues MP \\geq 4,5 MP \\geq 4,5 Se um projeto receber nota \\leq 5 \\leq 5 , ele dever\u00e1 ser reentregue at\u00e9 o fim do semestre com as corre\u00e7\u00f5es solicitadas. Se tudo estiver OK a nota deste projeto ser\u00e1 D Se um projeto for entregue atrasado sua nota final ser\u00e1 D Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Home"},{"location":"#supercomputacao","text":"Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2020/1. Professor : Igor Montagner Monitores : Leonardo Pereira Medeiros Raphael Marques da Costa","title":"SuperComputa\u00e7\u00e3o"},{"location":"#objetivos","text":"Ao final da disciplina o aluno ser\u00e1 capaz de: Desenvolver algoritmos usando recursos de computa\u00e7\u00e3o paralela/distribu\u00edda para ganhos de desempenho da aplica\u00e7\u00e3o final; Aplicar estrutura l\u00f3gica de computa\u00e7\u00e3o distribu\u00edda para o desenvolvimento de algoritmos multitarefas; Usar GPGPU para computa\u00e7\u00e3o num\u00e9rica e comparar com solu\u00e7\u00f5es baseadas em CPU Planejar e projetar sistemas de computa\u00e7\u00e3o de alto desempenho; Analisar a complexidade dos algoritmos paralelos e a efici\u00eancia de uma implementa\u00e7\u00e3o particular, identificando as medidas de desempenho mais adequadas para esta tarefa; Aplicar recursos espec\u00edfico de sistemas operacionais para melhorar o desempenho de algoritmos; Desenvolver aplica\u00e7\u00f5es que utilizam protocolos otimizados para paraleliza\u00e7\u00e3o.","title":"Objetivos"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os projetos ter\u00e3o dura\u00e7\u00e3o de duas semanas e ser\u00e3o incrementais com os seguintes pesos para m\u00e9dia de projetos: Projeto 0 - revis\u00e3o de C++ (10%) Projeto 1 - multi core (30%) Projeto 2 - GPU (30%) Projeto 3 - MPI (30%) Atividades de acompanhamento ser\u00e3o disponibilizadas durante o semestre. Estas atividades ter\u00e3o corre\u00e7\u00e3o autom\u00e1tica e sua realiza\u00e7\u00e3o \u00e9 opcional. Entregas atrasadas n\u00e3o ser\u00e3o aceitas para nota . A m\u00e9dia final \u00e9 dada por \\max \\begin{cases}0,4 \\times MP + 0,5\\times MProj + 0,1\\times AT \\\\ 0,5 \\times MP + 0,5 \\times MProj \\end{cases} \\max \\begin{cases}0,4 \\times MP + 0,5\\times MProj + 0,1\\times AT \\\\ 0,5 \\times MP + 0,5 \\times MProj \\end{cases} Condi\u00e7\u00f5es de barreira Caso as seguintes condi\u00e7\u00f5es n\u00e3o sejam cumpridas, a nota final ser\u00e1 D (4,0): Todos os projetos foram entregues MP \\geq 4,5 MP \\geq 4,5 Se um projeto receber nota \\leq 5 \\leq 5 , ele dever\u00e1 ser reentregue at\u00e9 o fim do semestre com as corre\u00e7\u00f5es solicitadas. Se tudo estiver OK a nota deste projeto ser\u00e1 D Se um projeto for entregue atrasado sua nota final ser\u00e1 D Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Avalia\u00e7\u00e3o"},{"location":"sobre/","text":"Burocracias \u00b6 Turma 1 \u00b6 TER 09:45 - 11:45 SEX 07:30 - 09:30 Atendimento: Plano de aulas \u00b6 Data Quest\u00e3o/Problema Conte\u00fado/Atividade 11/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Refer\u00eancia: Pacheco Cap 2. 14/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Orienta\u00e7\u00e3o a Objeto em C++; revis\u00e3o de ponteiros e passagem de argumentos por refer\u00eancia e valor 18/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Conteiners STL: vector, string, map 21/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Debug, profiling e compila\u00e7\u00e3o 25/02 FERIADO FERIADO 28/02 Processamento de dados vetorial Instru\u00e7\u00f5es SIMD e compila\u00e7\u00e3o; Refer\u00eancia: Cap 2 Hager, Cap 3 Dubois 03/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas CPU bound; Modelo fork-join; Exemplo com threads C++11; Leitura: Cap 5 Hager 06/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 10/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/03 Cancelamento COVID-19 Cancelamento COVID-19 17/03 Cancelamento COVID-19 Cancelamento COVID-19 20/03 Cancelamento COVID-19 Cancelamento COVID-19 24/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 27/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 31/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Simulado de atividade pr\u00e1tica para prova 03/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 07/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 10/04 FERIADO FERIADO 14/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 17/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 21/04 FERIADO FERIADO 24/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 28/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 01/05 FERIADO FERIADO 05/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 08/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 12/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Otimizando c\u00f3digo Cuda C \u2013 mem\u00f3ria compartilhada; Refer\u00eancia: Cap 4 Kirk 15/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 19/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 22/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Introdu\u00e7\u00e3o a sistemas distribu\u00eddos; Passagem de mensagens; Refer\u00eancia: Parte IV Taurion; Cap 9 Hager 26/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Modelos de divis\u00e3o carga: dados vs tarefas; Refer\u00eancia: Cap 9 Hager 29/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Custos de comunica\u00e7\u00e3o e processamento; mensagens ass\u00edncronas; Refer\u00eancia: Cap 10 Hager, Leitura: \u201cA survey of high-performance computing scaling challenges\u201d 02/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Comunica\u00e7\u00e3o coletiva; Refer\u00eancia: Cap 13 Reinders, Cap 10 Hager 05/06 Simulado de atividade pr\u00e1tica para prova Simulado de atividade pr\u00e1tica para prova 09/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 12/06 FERIADO FERIADO 16/06 Prova Final Prova Final 19/06 Prova Final Prova Final Turma 2 \u00b6 QUA 13:30 - 15:30 SEX 13:30 - 15:30 Atendimento: Plano de aulas \u00b6 Data Quest\u00e3o/Problema Conte\u00fado/Atividade 12/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Refer\u00eancia: Pacheco Cap 2. 14/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Orienta\u00e7\u00e3o a Objeto em C++; revis\u00e3o de ponteiros e passagem de argumentos por refer\u00eancia e valor 19/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Conteiners STL: vector, string, map 21/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Debug, profiling e compila\u00e7\u00e3o 26/02 FERIADO FERIADO 28/02 Processamento de dados vetorial Instru\u00e7\u00f5es SIMD e compila\u00e7\u00e3o; Refer\u00eancia: Cap 2 Hager, Cap 3 Dubois 04/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas CPU bound; Modelo fork-join; Exemplo com threads C++11; Leitura: Cap 5 Hager 06/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 11/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/03 Cancelamento COVID-19 Cancelamento COVID-19 18/03 Cancelamento COVID-19 Cancelamento COVID-19 20/03 Cancelamento COVID-19 Cancelamento COVID-19 25/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 27/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 01/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Simulado de atividade pr\u00e1tica para prova 03/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 08/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 10/04 FERIADO FERIADO 15/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 17/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 22/04 FERIADO FERIADO 24/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 29/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 01/05 FERIADO FERIADO 06/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 08/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 13/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Otimizando c\u00f3digo Cuda C \u2013 mem\u00f3ria compartilhada; Refer\u00eancia: Cap 4 Kirk 15/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 20/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 22/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Introdu\u00e7\u00e3o a sistemas distribu\u00eddos; Passagem de mensagens; Refer\u00eancia: Parte IV Taurion; Cap 9 Hager 27/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Modelos de divis\u00e3o carga: dados vs tarefas; Refer\u00eancia: Cap 9 Hager 29/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Custos de comunica\u00e7\u00e3o e processamento; mensagens ass\u00edncronas; Refer\u00eancia: Cap 10 Hager, Leitura: \u201cA survey of high-performance computing scaling challenges\u201d 03/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Comunica\u00e7\u00e3o coletiva; Refer\u00eancia: Cap 13 Reinders, Cap 10 Hager 05/06 Simulado de atividade pr\u00e1tica para prova Simulado de atividade pr\u00e1tica para prova 10/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 12/06 FERIADO FERIADO 17/06 Prova Final Prova Final 19/06 Prova Final Prova Final","title":"Sobre"},{"location":"sobre/#burocracias","text":"","title":"Burocracias"},{"location":"sobre/#turma-1","text":"TER 09:45 - 11:45 SEX 07:30 - 09:30 Atendimento:","title":"Turma 1"},{"location":"sobre/#plano-de-aulas","text":"Data Quest\u00e3o/Problema Conte\u00fado/Atividade 11/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Refer\u00eancia: Pacheco Cap 2. 14/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Orienta\u00e7\u00e3o a Objeto em C++; revis\u00e3o de ponteiros e passagem de argumentos por refer\u00eancia e valor 18/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Conteiners STL: vector, string, map 21/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Debug, profiling e compila\u00e7\u00e3o 25/02 FERIADO FERIADO 28/02 Processamento de dados vetorial Instru\u00e7\u00f5es SIMD e compila\u00e7\u00e3o; Refer\u00eancia: Cap 2 Hager, Cap 3 Dubois 03/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas CPU bound; Modelo fork-join; Exemplo com threads C++11; Leitura: Cap 5 Hager 06/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 10/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/03 Cancelamento COVID-19 Cancelamento COVID-19 17/03 Cancelamento COVID-19 Cancelamento COVID-19 20/03 Cancelamento COVID-19 Cancelamento COVID-19 24/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 27/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 31/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Simulado de atividade pr\u00e1tica para prova 03/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 07/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 10/04 FERIADO FERIADO 14/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 17/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 21/04 FERIADO FERIADO 24/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 28/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 01/05 FERIADO FERIADO 05/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 08/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 12/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Otimizando c\u00f3digo Cuda C \u2013 mem\u00f3ria compartilhada; Refer\u00eancia: Cap 4 Kirk 15/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 19/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 22/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Introdu\u00e7\u00e3o a sistemas distribu\u00eddos; Passagem de mensagens; Refer\u00eancia: Parte IV Taurion; Cap 9 Hager 26/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Modelos de divis\u00e3o carga: dados vs tarefas; Refer\u00eancia: Cap 9 Hager 29/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Custos de comunica\u00e7\u00e3o e processamento; mensagens ass\u00edncronas; Refer\u00eancia: Cap 10 Hager, Leitura: \u201cA survey of high-performance computing scaling challenges\u201d 02/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Comunica\u00e7\u00e3o coletiva; Refer\u00eancia: Cap 13 Reinders, Cap 10 Hager 05/06 Simulado de atividade pr\u00e1tica para prova Simulado de atividade pr\u00e1tica para prova 09/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 12/06 FERIADO FERIADO 16/06 Prova Final Prova Final 19/06 Prova Final Prova Final","title":"Plano de aulas"},{"location":"sobre/#turma-2","text":"QUA 13:30 - 15:30 SEX 13:30 - 15:30 Atendimento:","title":"Turma 2"},{"location":"sobre/#plano-de-aulas_1","text":"Data Quest\u00e3o/Problema Conte\u00fado/Atividade 12/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++; Refer\u00eancia: Pacheco Cap 2. 14/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Orienta\u00e7\u00e3o a Objeto em C++; revis\u00e3o de ponteiros e passagem de argumentos por refer\u00eancia e valor 19/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Conteiners STL: vector, string, map 21/02 Revis\u00e3o de programa\u00e7\u00e3o em C mais recursos novos em C++ Debug, profiling e compila\u00e7\u00e3o 26/02 FERIADO FERIADO 28/02 Processamento de dados vetorial Instru\u00e7\u00f5es SIMD e compila\u00e7\u00e3o; Refer\u00eancia: Cap 2 Hager, Cap 3 Dubois 04/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas CPU bound; Modelo fork-join; Exemplo com threads C++11; Leitura: Cap 5 Hager 06/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 11/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Opera\u00e7\u00f5es de redu\u00e7\u00e3o e escopo de vari\u00e1veis; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 13/03 Cancelamento COVID-19 Cancelamento COVID-19 18/03 Cancelamento COVID-19 Cancelamento COVID-19 20/03 Cancelamento COVID-19 Cancelamento COVID-19 25/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safety e reentr\u00e2ncia; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 27/03 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros.; Refer\u00eancia: Cap 5 Pacheco e Cap 7 Sterling 01/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Simulado de atividade pr\u00e1tica para prova 03/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 08/04 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Projeto 2 - vetoriza\u00e7\u00e3o e paraleliza\u00e7\u00e3o 10/04 FERIADO FERIADO 15/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 17/04 Provas Intermedi\u00e1rias Provas Intermedi\u00e1rias 22/04 FERIADO FERIADO 24/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Introdu\u00e7\u00e3o a GPGPU; Refer\u00eancia: Cap 1 Kirk 29/04 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Arquitetura de GPU em baixo n\u00edvel: Grid, Blocos e Threads; Leitura: Cap3 Gaster, Cap 3 Kirk 01/05 FERIADO FERIADO 06/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Processando matrizes com Cuda C, profiling de c\u00f3digo em Cuda.; Refer\u00eancia: Cap 7 Kirk 08/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Exerc\u00edcios de programa\u00e7\u00e3o em GPGPU 13/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Otimizando c\u00f3digo Cuda C \u2013 mem\u00f3ria compartilhada; Refer\u00eancia: Cap 4 Kirk 15/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 20/05 Programa\u00e7\u00e3o em GPU: e problemas que s\u00e3o massivamente paraleliz\u00e1veis? Projeto 3 - paraleliza\u00e7\u00e3o em GPU 22/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Introdu\u00e7\u00e3o a sistemas distribu\u00eddos; Passagem de mensagens; Refer\u00eancia: Parte IV Taurion; Cap 9 Hager 27/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Modelos de divis\u00e3o carga: dados vs tarefas; Refer\u00eancia: Cap 9 Hager 29/05 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Custos de comunica\u00e7\u00e3o e processamento; mensagens ass\u00edncronas; Refer\u00eancia: Cap 10 Hager, Leitura: \u201cA survey of high-performance computing scaling challenges\u201d 03/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Comunica\u00e7\u00e3o coletiva; Refer\u00eancia: Cap 13 Reinders, Cap 10 Hager 05/06 Simulado de atividade pr\u00e1tica para prova Simulado de atividade pr\u00e1tica para prova 10/06 \u00c9 poss\u00edvel ganhar mais? Utilizando v\u00e1rias m\u00e1quinas para acelerar ainda mais sistemas. Projeto 4 - aplica\u00e7\u00f5es distribu\u00eddas 12/06 FERIADO FERIADO 17/06 Prova Final Prova Final 19/06 Prova Final Prova Final","title":"Plano de aulas"},{"location":"aulas/00-organizacao/","text":"Organiza\u00e7\u00e3o do reposit\u00f3rio \u00b6 O material de SuperComputa\u00e7\u00e3o para cada aula do semestre pode ser acessado utilizando o menu no lado esquerdo desta p\u00e1gina. Todos os exemplos de c\u00f3digo est\u00e3o na pasta code na raiz do reposit\u00f3rio e ser\u00e3o tamb\u00e9m lincados em cada aula. Todos os slides est\u00e3o na pasta material/aulas e tamb\u00e9m est\u00e3o lincados na parte pr\u00e1tica de cada aula.","title":"Organiza\u00e7\u00e3o do reposit\u00f3rio"},{"location":"aulas/00-organizacao/#organizacao-do-repositorio","text":"O material de SuperComputa\u00e7\u00e3o para cada aula do semestre pode ser acessado utilizando o menu no lado esquerdo desta p\u00e1gina. Todos os exemplos de c\u00f3digo est\u00e3o na pasta code na raiz do reposit\u00f3rio e ser\u00e3o tamb\u00e9m lincados em cada aula. Todos os slides est\u00e3o na pasta material/aulas e tamb\u00e9m est\u00e3o lincados na parte pr\u00e1tica de cada aula.","title":"Organiza\u00e7\u00e3o do reposit\u00f3rio"},{"location":"aulas/01-intro-cpp/","text":"O principal objetivo deste roteiro \u00e9 retomar a pr\u00e1tica de programa\u00e7\u00e3o em C++ usando exerc\u00edcios simples e que eventualmente sejam \u00fateis para os projetos da disciplina. Os exerc\u00edcios para entrega estar\u00e3o indicados no fim do roteiro. Entrada e sa\u00edda \u00b6 Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream) Para mostrar mensagens no terminal basta \"enviar\" dados para o objeto usando o operador <<. Veja o exemplo abaixo. Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream ) Para mostrar mensagens no terminal basta \"enviar\" dados para o objeto usando o operador << . Veja o exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << a << \";\" << b << \" \\n \" ; Note que n\u00e3o precisamos mais usar a string de formata\u00e7\u00e3o cheia de %d e afins. Basta ir aplicando << aos dados que queremos mostrar. O mesmo vale para a entrada, mas desta vez \"tiramos\" os dados do objeto std::cin . O exemplo abaixo l\u00ea um inteiro e um double do terminal. int a ; double b ; std :: cin >> a >> b ; Example Crie um programa que l\u00ea um n\u00famero inteiro n e mostra em sua sa\u00edda sua divis\u00e3o fracion\u00e1ria por 2. Ou seja, antes de dividir converta n para double . Aloca\u00e7\u00e3o de mem\u00f3ria \u00b6 Em C usamos as fun\u00e7\u00f5es malloc e free para alocar mem\u00f3ria dinamicamente. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m est\u00e3o dispon\u00edveis, mas us\u00e1-las \u00e9 considerado uma m\u00e1 pr\u00e1tica. Ao inv\u00e9s, usamos os operadores new e delete para alocar mem\u00f3ria. point * p ; p = new point (); /* usar p aqui */ delete p ; Tamb\u00e9m podemos criar (e deletar) arrays de tamanho fixo usando new[] e delete[] . int n ; std :: cin >> n ; double * values = new double [ n ]; /* usar values aqui */ delete [] values ; Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Dica : procure por setprecision para configurar as casas decimais do cout . Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas? Contagem de tempo \u00b6 Durante todo o curso iremos trabalhar com medi\u00e7\u00f5es de tempo, especialmente para descobrir quais trechos do nosso c\u00f3digo tem mais impacto no tempo de execu\u00e7\u00e3o. Example Crie um script python que gere uma entrada muito grande ( n=100000 ) para o programa acima. Question Use a ferramenta time para medir o tempo de execu\u00e7\u00e3o do programa. Escreva este valor abaixo. Voc\u00ea consegue dizer quanto tempo o c\u00e1lculo da vari\u00e2ncia leva? Um dos problemas da utiliza\u00e7\u00e3o do comando time \u00e9 que ele n\u00e3o separa o tempo gasto para ler a entrada do programa e o tempo gasto no calculo de cada medida. Felizmente a biblioteca padr\u00e3o de C++ possui diversas classes para medi\u00e7\u00e3o de tempo. O cabe\u00e7alho <chrono> disponibiliza diversas classes e fun\u00e7\u00f5es para medi\u00e7\u00e3o de tempo. Leia sua documenta\u00e7\u00e3o neste link . Question Qual classe voc\u00ea usaria para obter leituras de tempo com a melhor precis\u00e3o poss\u00edvel? Quais m\u00e9todos ou fun\u00e7\u00f5es desta classe seriam \u00fateis? Para que servem as classes time_point e duration ? Example Use as classes acima para medir o tempo de execu\u00e7\u00e3o, separadamente, da m\u00e9dia e da vari\u00e2ncia no exemplo anterior. Escreva abaixo o tempo gasto em milisegundos . Projeto 0 - revis\u00e3o de C++ \u00b6 A parte inicial de nosso curso foca na compreens\u00e3o e implementa\u00e7\u00e3o de fun\u00e7\u00f5es matem\u00e1ticas. Para isso vamos iniciar uma sequ\u00eancia de atividades que far\u00e3o compara\u00e7\u00f5es de desempenho de fun\u00e7\u00f5es do cabe\u00e7alho cmath (que \u00e9 o mesmo math.h que us\u00e1vamos em C , mas agora exportado para usar em C++ ). Warning O projeto 0 \u00e9 individual e dever\u00e1 ser entregue via blackboard. Este projeto n\u00e3o dever\u00e1 estar hospedado no github. Example Cria um arquivo chamado parte0.c contendo uma fun\u00e7\u00e3o gera_vetor que recebe um inteiro n e devolve um vetor de dados aleat\u00f3rio de tamanho n com tipo double . fun\u00e7\u00f5es log , sqrt , pow3 (usando a biblioteca math ) e pow3mult (usando o operador * duas vezes) que computam as opera\u00e7\u00f5es correspondentes em cada elemento do vetor. uma fun\u00e7\u00e3o sum que calcula a soma do vetor um main que cria vetores de tamanho incrementalmente maior e computa o tempo necess\u00e1rio para cada fun\u00e7\u00e3o rodar. Question Para cada fun\u00e7\u00e3o criada, coloque abaixo os tempos colhidos para cada tamanho de vetor. O nome da disciplina \u00e9 SuperComputa\u00e7\u00e3o. Honre esse nome ao escolher tamanhos de vetores.","title":"01 - Introdu\u00e7\u00e3o a C++"},{"location":"aulas/01-intro-cpp/#entrada-e-saida","text":"Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream) Para mostrar mensagens no terminal basta \"enviar\" dados para o objeto usando o operador <<. Veja o exemplo abaixo. Em C usamos as fun\u00e7\u00f5es printf para mostrar dados no terminal e scanf para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos std::cin e std::cout (dispon\u00edveis no cabe\u00e7alho iostream ) Para mostrar mensagens no terminal basta \"enviar\" dados para o objeto usando o operador << . Veja o exemplo abaixo. int a = 10 ; double b = 3.2 ; std :: cout << a << \";\" << b << \" \\n \" ; Note que n\u00e3o precisamos mais usar a string de formata\u00e7\u00e3o cheia de %d e afins. Basta ir aplicando << aos dados que queremos mostrar. O mesmo vale para a entrada, mas desta vez \"tiramos\" os dados do objeto std::cin . O exemplo abaixo l\u00ea um inteiro e um double do terminal. int a ; double b ; std :: cin >> a >> b ; Example Crie um programa que l\u00ea um n\u00famero inteiro n e mostra em sua sa\u00edda sua divis\u00e3o fracion\u00e1ria por 2. Ou seja, antes de dividir converta n para double .","title":"Entrada e sa\u00edda"},{"location":"aulas/01-intro-cpp/#alocacao-de-memoria","text":"Em C usamos as fun\u00e7\u00f5es malloc e free para alocar mem\u00f3ria dinamicamente. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m est\u00e3o dispon\u00edveis, mas us\u00e1-las \u00e9 considerado uma m\u00e1 pr\u00e1tica. Ao inv\u00e9s, usamos os operadores new e delete para alocar mem\u00f3ria. point * p ; p = new point (); /* usar p aqui */ delete p ; Tamb\u00e9m podemos criar (e deletar) arrays de tamanho fixo usando new[] e delete[] . int n ; std :: cin >> n ; double * values = new double [ n ]; /* usar values aqui */ delete [] values ; Example Crie um programa que l\u00ea um n\u00famero inteiro n e depois l\u00ea n n\u00fameros fracion\u00e1rios x_i x_i . Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 Dica : procure por setprecision para configurar as casas decimais do cout . Question Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas?","title":"Aloca\u00e7\u00e3o de mem\u00f3ria"},{"location":"aulas/01-intro-cpp/#contagem-de-tempo","text":"Durante todo o curso iremos trabalhar com medi\u00e7\u00f5es de tempo, especialmente para descobrir quais trechos do nosso c\u00f3digo tem mais impacto no tempo de execu\u00e7\u00e3o. Example Crie um script python que gere uma entrada muito grande ( n=100000 ) para o programa acima. Question Use a ferramenta time para medir o tempo de execu\u00e7\u00e3o do programa. Escreva este valor abaixo. Voc\u00ea consegue dizer quanto tempo o c\u00e1lculo da vari\u00e2ncia leva? Um dos problemas da utiliza\u00e7\u00e3o do comando time \u00e9 que ele n\u00e3o separa o tempo gasto para ler a entrada do programa e o tempo gasto no calculo de cada medida. Felizmente a biblioteca padr\u00e3o de C++ possui diversas classes para medi\u00e7\u00e3o de tempo. O cabe\u00e7alho <chrono> disponibiliza diversas classes e fun\u00e7\u00f5es para medi\u00e7\u00e3o de tempo. Leia sua documenta\u00e7\u00e3o neste link . Question Qual classe voc\u00ea usaria para obter leituras de tempo com a melhor precis\u00e3o poss\u00edvel? Quais m\u00e9todos ou fun\u00e7\u00f5es desta classe seriam \u00fateis? Para que servem as classes time_point e duration ? Example Use as classes acima para medir o tempo de execu\u00e7\u00e3o, separadamente, da m\u00e9dia e da vari\u00e2ncia no exemplo anterior. Escreva abaixo o tempo gasto em milisegundos .","title":"Contagem de tempo"},{"location":"aulas/01-intro-cpp/#projeto-0-revisao-de-c","text":"A parte inicial de nosso curso foca na compreens\u00e3o e implementa\u00e7\u00e3o de fun\u00e7\u00f5es matem\u00e1ticas. Para isso vamos iniciar uma sequ\u00eancia de atividades que far\u00e3o compara\u00e7\u00f5es de desempenho de fun\u00e7\u00f5es do cabe\u00e7alho cmath (que \u00e9 o mesmo math.h que us\u00e1vamos em C , mas agora exportado para usar em C++ ). Warning O projeto 0 \u00e9 individual e dever\u00e1 ser entregue via blackboard. Este projeto n\u00e3o dever\u00e1 estar hospedado no github. Example Cria um arquivo chamado parte0.c contendo uma fun\u00e7\u00e3o gera_vetor que recebe um inteiro n e devolve um vetor de dados aleat\u00f3rio de tamanho n com tipo double . fun\u00e7\u00f5es log , sqrt , pow3 (usando a biblioteca math ) e pow3mult (usando o operador * duas vezes) que computam as opera\u00e7\u00f5es correspondentes em cada elemento do vetor. uma fun\u00e7\u00e3o sum que calcula a soma do vetor um main que cria vetores de tamanho incrementalmente maior e computa o tempo necess\u00e1rio para cada fun\u00e7\u00e3o rodar. Question Para cada fun\u00e7\u00e3o criada, coloque abaixo os tempos colhidos para cada tamanho de vetor. O nome da disciplina \u00e9 SuperComputa\u00e7\u00e3o. Honre esse nome ao escolher tamanhos de vetores.","title":"Projeto 0 - revis\u00e3o de C++"},{"location":"aulas/02-stl/","text":"02 - Templates e STL \u00b6 Esta pr\u00e1tica consiste primariamente em aprender a usar tipos de dados complexos disponibilizados pela STL e pela biblioteca padr\u00e3o de C++. A atividade principal desta pr\u00e1tica consiste em modificar o exerc\u00edcio da aula passada para usar as estruturas de dados e fun\u00e7\u00f5es da STL. Smart Pointers \u00b6 Uma das grandes dificuldades de desenvolver em C++ \u00e9 evitar vazamentos de mem\u00f3ria (memory leaks). Durante o desenvolvimento do programa \u00e9 muito usado o recurso de aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria, contudo da mesma forma que o programador tem a responsabilidade de alocar a mem\u00f3ria, ele tem de desalocar a mem\u00f3ria. Os smart pointers s\u00e3o uma estrat\u00e9gia de evitar que voc\u00ea esque\u00e7a de desalocar e crie um programa devorador de mem\u00f3ria. Os smart pointers percebem que uma mem\u00f3ria alocada n\u00e3o \u00e9 mais acess\u00edvel e desaloca a mem\u00f3ria. unique_ptr : um smart pointer para um \u00fanico objeto com um dono s\u00f3. Ou seja, este smart pointer aponta para um objeto que deve ter s\u00f3 um apontamento de cada vez. Ao realizarmos atribui\u00e7\u00f5es a vari\u00e1vel \"dono\" do objeto muda. shared_ptr : Um smart pointer para um \u00fanico objeto e pode ter v\u00e1rios donos. Ou seja, este smart pointer aponta para um objeto que pode ter v\u00e1rios apontamentos de cada vez. Ao realizarmos atribui\u00e7\u00f5es adicionamos uma nova refer\u00eancia a este dado. Quando n\u00e3o existem mais refer\u00eancias o dado \u00e9 automaticamente liberado usando delete Example O programa abaixo ( tarefa1.cpp ) tem problemas de mem\u00f3ria devido a aloca\u00e7\u00e3o feita na fun\u00e7\u00e3o cria_vetor e n\u00e3o liberada a cada itera\u00e7\u00e3o do for. Conserte o programa usando shared_ptr para que a mem\u00f3ria alocada por cria_vetor seja liberada automaticamente. #include <iostream> #include <memory> #include <vector> double * cria_vetor ( int n ) { double * ptr = new double [ n ]; for ( int i = 0 ; i < n ; i ++ ) { prt [ i ] = 0.0 ; } return ptr ; } void processa ( double * ptr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { ptr [ i ] *= 2 ; } } int main () { std :: cout << \"Hello! \\n \" ; for ( int i = 0 ; i < 10 ; i ++ ) { double * vec = cria_vetor ( 1000 ); processa ( vec , 1000 ); // vetor n\u00e3o \u00e9 deletado no fim do main! } return 0 ; } Strings e Vector \u00b6 Nesta se\u00e7\u00e3o iremos trabalhar com dois conteiners muito usados da STL: string e vector . O objetivo \u00e9 acostum\u00e1-los a consultar a documenta\u00e7\u00e3o de C++ e entend\u00ea-la com autonomia. A STL tem uma quantidade enorme de recursos e aprender a pesquisar como us\u00e1-los \u00e9 importante para sua profici\u00eancia. Example Fa\u00e7a um programa que l\u00ea uma linha de texto (usando std::getline ) e procure nela todas as ocorr\u00eancias da palavra \"hello\". Voc\u00ea dever\u00e1 implementar uma fun\u00e7\u00e3o std::vector<int> find_all(std::string text, std::string term); que devolve um vetor com a posi\u00e7\u00e3o de todas as ocorr\u00eancias de term em text . Sua fun\u00e7\u00e3o main dever\u00e1 mostrar os resultados da busca de maneira bem formatada. Projeto 0 - adicionando STL \u00b6 O c\u00f3digo produzido na \u00faltima aula parece muito com c\u00f3digo C e usa muito pouco dos recursos introduzidos em C++ para tornar nossos programas mais leg\u00edveis e f\u00e1ceis de escrever. Example Modifique sua fun\u00e7\u00e3o gera_vetor para usar std::vector ao inv\u00e9s de arrays puros e para usar o cabe\u00e7alho <random> . A distribui\u00e7\u00e3o usada dever\u00e1 ser uniforme real com limites 5 a 27. Example Modifique todas as fun\u00e7\u00f5es ( log , sqrt , pow3 , pow3mult e sum ) para receber std::vector . Note que voc\u00ea n\u00e3o precisa mais receber como argumento o tamanho do vetor. Question Qual dever\u00e1 ser a assinatura das fun\u00e7\u00f5es acima para evitar que ocorra c\u00f3pia do std::vector ? Example Continuando o exerc\u00edcio acima, use iteradores para percorrer seu std::vector . Para deixar o c\u00f3digo mais leg\u00edvel use auto Vamos agora trabalhar com programa\u00e7\u00e3o funcional em C++ para tornar nosso c\u00f3digo menor: armazenamento de refer\u00eancias para fun\u00e7\u00f5es em vari\u00e1veis e defini\u00e7\u00e3o de fun\u00e7\u00f5es usando lambda . Podemos definir fun\u00e7\u00f5es no meio de nosso programa usando a seguinte sintaxe: [ &|= ] ( argumentos ) -> retorno { corpo da fun\u00e7\u00e3o aqui }; Uma fun\u00e7\u00e3o definida desta maneira pode usar as vari\u00e1veis locais dispon\u00edveis no momento em que ela foi declarada (mesmo que n\u00e3o sejam passadas como argumento). A primeira parte da declara\u00e7\u00e3o define se essas vari\u00e1veis ser\u00e3o copiadas [=] ou se uma refer\u00eancia para elas ser\u00e1 utilizada na fun\u00e7\u00e3o [&] . O restante segue padr\u00f5es normalmente usados em C++ . Podemos inclusive, passar essas fun\u00e7\u00f5es como argumentos e devolv\u00ea-las como resultado de fun\u00e7\u00f5es. Para isto usamos o tipo std::function dispon\u00edvel no cabe\u00e7alho functional . Os exerc\u00edcios abaixo foram extra\u00eddos do arquivo exemplos-lambda.cpp . Fa\u00e7a-os e cheque seus resultados rodando o programa. Se houver d\u00favida chame o professor. Question Qual \u00e9 o resultado do c\u00f3digo abaixo? int c = 2 ; std :: function < double ( int ) > by_two = [ = ]( int n ) { return double ( n ) / c ; }; std :: cout << by_two ( 5 ) << \" \\n \" ; Question Qual \u00e9 o resultado do c\u00f3digo abaixo? int c = 2 ; std :: function < double ( int ) > by_c = [ & ]( int n ) { return double ( n ) / c ; }; std :: cout << by_c ( 7 ) << \" \\n \" ; c = 3 ; std :: cout << by_c ( 7 ) << \" \\n \" ; Question Escreva abaixo o tipo de uma vari\u00e1vel que guarda refer\u00eancia para as fun\u00e7\u00f5es que testamos neste exerc\u00edcio log sqrt pow3 pow3mult sum Example Crie uma fun\u00e7\u00e3o std::vector<double> teste_incremental( tipo aqui ) que recebe um ponteiro para o tipo das fun\u00e7\u00f5es acima e executa a fun\u00e7\u00e3o recebida com tamanhos de vetores incrementalmente maiores. Sua fun\u00e7\u00e3o dever\u00e1 devolver os tempos (em segundos) para todas as execu\u00e7\u00f5es feitas. Ou seja, a fun\u00e7\u00e3o teste_incremental dever\u00e1 funcionar como uma \"casquinha\" que gera vetores, roda as fun\u00e7\u00f5es matem\u00e1ticas testadas e retorna seus tempos de execu\u00e7\u00e3o. Example voc\u00ea deve ter notado que a fun\u00e7\u00e3o sum n\u00e3o possui a mesma assinatura das outras. Use uma fun\u00e7\u00e3o lambda para adaptar os tipos e usar a fun\u00e7\u00e3o acima para testar a fun\u00e7\u00e3o sum tamb\u00e9m.","title":"02 - Templates e STL"},{"location":"aulas/02-stl/#02-templates-e-stl","text":"Esta pr\u00e1tica consiste primariamente em aprender a usar tipos de dados complexos disponibilizados pela STL e pela biblioteca padr\u00e3o de C++. A atividade principal desta pr\u00e1tica consiste em modificar o exerc\u00edcio da aula passada para usar as estruturas de dados e fun\u00e7\u00f5es da STL.","title":"02 - Templates e STL"},{"location":"aulas/02-stl/#smart-pointers","text":"Uma das grandes dificuldades de desenvolver em C++ \u00e9 evitar vazamentos de mem\u00f3ria (memory leaks). Durante o desenvolvimento do programa \u00e9 muito usado o recurso de aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria, contudo da mesma forma que o programador tem a responsabilidade de alocar a mem\u00f3ria, ele tem de desalocar a mem\u00f3ria. Os smart pointers s\u00e3o uma estrat\u00e9gia de evitar que voc\u00ea esque\u00e7a de desalocar e crie um programa devorador de mem\u00f3ria. Os smart pointers percebem que uma mem\u00f3ria alocada n\u00e3o \u00e9 mais acess\u00edvel e desaloca a mem\u00f3ria. unique_ptr : um smart pointer para um \u00fanico objeto com um dono s\u00f3. Ou seja, este smart pointer aponta para um objeto que deve ter s\u00f3 um apontamento de cada vez. Ao realizarmos atribui\u00e7\u00f5es a vari\u00e1vel \"dono\" do objeto muda. shared_ptr : Um smart pointer para um \u00fanico objeto e pode ter v\u00e1rios donos. Ou seja, este smart pointer aponta para um objeto que pode ter v\u00e1rios apontamentos de cada vez. Ao realizarmos atribui\u00e7\u00f5es adicionamos uma nova refer\u00eancia a este dado. Quando n\u00e3o existem mais refer\u00eancias o dado \u00e9 automaticamente liberado usando delete Example O programa abaixo ( tarefa1.cpp ) tem problemas de mem\u00f3ria devido a aloca\u00e7\u00e3o feita na fun\u00e7\u00e3o cria_vetor e n\u00e3o liberada a cada itera\u00e7\u00e3o do for. Conserte o programa usando shared_ptr para que a mem\u00f3ria alocada por cria_vetor seja liberada automaticamente. #include <iostream> #include <memory> #include <vector> double * cria_vetor ( int n ) { double * ptr = new double [ n ]; for ( int i = 0 ; i < n ; i ++ ) { prt [ i ] = 0.0 ; } return ptr ; } void processa ( double * ptr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { ptr [ i ] *= 2 ; } } int main () { std :: cout << \"Hello! \\n \" ; for ( int i = 0 ; i < 10 ; i ++ ) { double * vec = cria_vetor ( 1000 ); processa ( vec , 1000 ); // vetor n\u00e3o \u00e9 deletado no fim do main! } return 0 ; }","title":"Smart Pointers"},{"location":"aulas/02-stl/#strings-e-vector","text":"Nesta se\u00e7\u00e3o iremos trabalhar com dois conteiners muito usados da STL: string e vector . O objetivo \u00e9 acostum\u00e1-los a consultar a documenta\u00e7\u00e3o de C++ e entend\u00ea-la com autonomia. A STL tem uma quantidade enorme de recursos e aprender a pesquisar como us\u00e1-los \u00e9 importante para sua profici\u00eancia. Example Fa\u00e7a um programa que l\u00ea uma linha de texto (usando std::getline ) e procure nela todas as ocorr\u00eancias da palavra \"hello\". Voc\u00ea dever\u00e1 implementar uma fun\u00e7\u00e3o std::vector<int> find_all(std::string text, std::string term); que devolve um vetor com a posi\u00e7\u00e3o de todas as ocorr\u00eancias de term em text . Sua fun\u00e7\u00e3o main dever\u00e1 mostrar os resultados da busca de maneira bem formatada.","title":"Strings e Vector"},{"location":"aulas/02-stl/#projeto-0-adicionando-stl","text":"O c\u00f3digo produzido na \u00faltima aula parece muito com c\u00f3digo C e usa muito pouco dos recursos introduzidos em C++ para tornar nossos programas mais leg\u00edveis e f\u00e1ceis de escrever. Example Modifique sua fun\u00e7\u00e3o gera_vetor para usar std::vector ao inv\u00e9s de arrays puros e para usar o cabe\u00e7alho <random> . A distribui\u00e7\u00e3o usada dever\u00e1 ser uniforme real com limites 5 a 27. Example Modifique todas as fun\u00e7\u00f5es ( log , sqrt , pow3 , pow3mult e sum ) para receber std::vector . Note que voc\u00ea n\u00e3o precisa mais receber como argumento o tamanho do vetor. Question Qual dever\u00e1 ser a assinatura das fun\u00e7\u00f5es acima para evitar que ocorra c\u00f3pia do std::vector ? Example Continuando o exerc\u00edcio acima, use iteradores para percorrer seu std::vector . Para deixar o c\u00f3digo mais leg\u00edvel use auto Vamos agora trabalhar com programa\u00e7\u00e3o funcional em C++ para tornar nosso c\u00f3digo menor: armazenamento de refer\u00eancias para fun\u00e7\u00f5es em vari\u00e1veis e defini\u00e7\u00e3o de fun\u00e7\u00f5es usando lambda . Podemos definir fun\u00e7\u00f5es no meio de nosso programa usando a seguinte sintaxe: [ &|= ] ( argumentos ) -> retorno { corpo da fun\u00e7\u00e3o aqui }; Uma fun\u00e7\u00e3o definida desta maneira pode usar as vari\u00e1veis locais dispon\u00edveis no momento em que ela foi declarada (mesmo que n\u00e3o sejam passadas como argumento). A primeira parte da declara\u00e7\u00e3o define se essas vari\u00e1veis ser\u00e3o copiadas [=] ou se uma refer\u00eancia para elas ser\u00e1 utilizada na fun\u00e7\u00e3o [&] . O restante segue padr\u00f5es normalmente usados em C++ . Podemos inclusive, passar essas fun\u00e7\u00f5es como argumentos e devolv\u00ea-las como resultado de fun\u00e7\u00f5es. Para isto usamos o tipo std::function dispon\u00edvel no cabe\u00e7alho functional . Os exerc\u00edcios abaixo foram extra\u00eddos do arquivo exemplos-lambda.cpp . Fa\u00e7a-os e cheque seus resultados rodando o programa. Se houver d\u00favida chame o professor. Question Qual \u00e9 o resultado do c\u00f3digo abaixo? int c = 2 ; std :: function < double ( int ) > by_two = [ = ]( int n ) { return double ( n ) / c ; }; std :: cout << by_two ( 5 ) << \" \\n \" ; Question Qual \u00e9 o resultado do c\u00f3digo abaixo? int c = 2 ; std :: function < double ( int ) > by_c = [ & ]( int n ) { return double ( n ) / c ; }; std :: cout << by_c ( 7 ) << \" \\n \" ; c = 3 ; std :: cout << by_c ( 7 ) << \" \\n \" ; Question Escreva abaixo o tipo de uma vari\u00e1vel que guarda refer\u00eancia para as fun\u00e7\u00f5es que testamos neste exerc\u00edcio log sqrt pow3 pow3mult sum Example Crie uma fun\u00e7\u00e3o std::vector<double> teste_incremental( tipo aqui ) que recebe um ponteiro para o tipo das fun\u00e7\u00f5es acima e executa a fun\u00e7\u00e3o recebida com tamanhos de vetores incrementalmente maiores. Sua fun\u00e7\u00e3o dever\u00e1 devolver os tempos (em segundos) para todas as execu\u00e7\u00f5es feitas. Ou seja, a fun\u00e7\u00e3o teste_incremental dever\u00e1 funcionar como uma \"casquinha\" que gera vetores, roda as fun\u00e7\u00f5es matem\u00e1ticas testadas e retorna seus tempos de execu\u00e7\u00e3o. Example voc\u00ea deve ter notado que a fun\u00e7\u00e3o sum n\u00e3o possui a mesma assinatura das outras. Use uma fun\u00e7\u00e3o lambda para adaptar os tipos e usar a fun\u00e7\u00e3o acima para testar a fun\u00e7\u00e3o sum tamb\u00e9m.","title":"Projeto 0 - adicionando STL"},{"location":"aulas/03-cmake/","text":"03 - CMake e Debugging no VSCode \u00b6 At\u00e9 o momento todos nossos arquivos eram compilados em uma s\u00f3 linha usando g++ . Conforme projetos ficam maiores e s\u00e3o divididos em v\u00e1rios m\u00f3dulos isto se torna invi\u00e1vel. Neste roteiro iremos usar o CMake, uma ferramenta de gerenciamento de projetos em C++. No fim, iremos configurar o VSCode para abrir projetos CMake. Aten\u00e7\u00e3o Usar ferramentas adequadas aumenta consideravelmente a produtividade e tamb\u00e9m facilita encontrar erros no c\u00f3digo. A partir desta aula ser\u00e1 obrigat\u00f3rio j\u00e1 ter debugado o programa antes de tirar d\u00favidas. Gerenciamento de projetos com CMake \u00b6 O CMake \u00e9 uma das ferramentas mais usadas para gerenciar projetos C/C++. Outras ferramentas comumente usadas s\u00e3o ninja e meson . Em CMake , um projeto \u00e9 definido por um arquivo nomeado CMakeLists.txt . Este arquivo cont\u00e9m defini\u00e7\u00f5es como nome do projeto, quais depend\u00eancias (bibliotecas externas e subprojetos) s\u00e3o usadas e o quais arquivos ser\u00e3o gerados pelo projeto. Cada arquivo gerado \u00e9 chamado de target na nomenclatura usada pelo CMake e pode ser um execut\u00e1vel ou uma biblioteca (est\u00e1tica ou din\u00e2mica). Um arquivo CMakeLists.txt b\u00e1sico pode conter apenas tr\u00eas linhas (pasta 03-cmake ): cmake_minimum_required(VERSION 3.10) project (projeto_basico) add_executable(hello hello.cpp) Este arquivo somente descreve o projeto. Para efetivamente compilarmos o programa precisamos passar pela fase de configura\u00e7\u00e3o , em que o CMake checa se todas as depend\u00eancias foram encontradas e se os compiladores necess\u00e1rios est\u00e3o instalados. Se tudo estiver em ordem podemos gerar um Makefile (para Linux) ou um projeto do Visual Studio (para Windows). Para fazer a configura\u00e7\u00e3o do projeto basta rodar o comando cmake mais o caminho para a pasta do projeto. Voc\u00ea s\u00f3 precisar\u00e1 refazer a configura\u00e7\u00e3o do projeto se modificar o arquivo CMakeLists.txt . \u00c9 boa pr\u00e1tica fazer a compila\u00e7\u00e3o do c\u00f3digo em uma pasta separada, como na sequ\u00eancia de comandos abaixo. mkdir build cd build cmake .. Estes comandos devem ter gerado uma s\u00e9rie de arquivos na pasta build , incluindo um Makefile . Para compilar o projeto basta rodar make E um execut\u00e1vel de nome hello dever\u00e1 aparecer na pasta build . Exerc\u00edcio Crie um arquivo CMakeLists.txt para o projeto 0. Voc\u00ea dever\u00e1 adicionar um target chamado vector_ops . Exerc\u00edcio Separe as fun\u00e7\u00f5es matem\u00e1ticas testadas em arquivos .cpp/h e use-os no seu projeto. A diretiva add_executable aceita v\u00e1rios arquivos .cpp para criar um execut\u00e1vel. Op\u00e7\u00f5es de compila\u00e7\u00e3o \u00b6 Al\u00e9m da cria\u00e7\u00e3o de execut\u00e1veis o CMake tamb\u00e9m permite adicionar op\u00e7\u00f5es de compila\u00e7\u00e3o espec\u00edficas para cada target com a diretiva target_compile_options . No contexto desta mat\u00e9ria isto ser\u00e1 especialmente interessante pois o g++ oferece flags para ativar otimiza\u00e7\u00f5es que podem melhorar significativamente o desempenho de nosso programa. Portanto, podemos facilmente compilar o mesmo programa com e sem otimiza\u00e7\u00f5es no mesmo projeto! O exemplo abaixo ativa a flag O3 no target hello criado no exemplo anterior. target_compile_options(hello PUBLIC -O3) Podemos tamb\u00e9m usar #define para fazer compila\u00e7\u00e3o condicional do nosso c\u00f3digo. Usar a diretiva abaixo equivale e colocar um #define OPT no topo de cada arquivo do target hello . target_compile_definitions(hello PUBLIC OPT) Exerc\u00edcio Modifique seu target vector_ops para que ele use a op\u00e7\u00e3o de compila\u00e7\u00e3o O2 . Exerc\u00edcio Crie um novo target vector_ops_no_opt que compile os mesmos arquivos de vector_ops mas use a op\u00e7\u00e3o de compila\u00e7\u00e3o O0 . Projeto 0 - Benchmarking e compara\u00e7\u00f5es de desempenho \u00b6 Vamos agora fazer um pequeno resumo dos resultados dos experimentos. Este resumo dever\u00e1 conter os seguintes itens e dever\u00e1 ser entregue em formato PDF . uma breve descri\u00e7\u00e3o do programa testado (um par\u00e1grafo); os nomes dos execut\u00e1veis testados e qual a diferen\u00e7a entre eles os tamanhos de entrada usados e a m\u00e1quina usada para seus testes gr\u00e1ficos ilustrando a diferen\u00e7a de desempenho para cada fun\u00e7\u00e3o testada coment\u00e1rios sobre os resultados mostrados nos gr\u00e1ficos Dicas \u00b6 Ferramentas como PWeave ou Jupyter Notebook ajudam muito a criar textos que misturam c\u00f3digo para criar gr\u00e1ficos, rodar programas automaticamente e interpretar sua sa\u00edda. Tente automatizar o m\u00e1ximo poss\u00edvel a gera\u00e7\u00e3o de gr\u00e1ficos de desempenho. Isso facilitar\u00e1 muito sua vida em projetos posteriores. Extra 01 - Debugando seu projeto \u00b6 Agora iremos abrir nosso projeto um ambiente de desenvolvimento em vez de continuar trabalhando na linha de comando. Adotaremos o VSCode como ambiente padr\u00e3o. O VSCode n\u00e3o vem com suporte por padr\u00e3o a projetos CMake, mas a extens\u00e3o Cmake Tools possui um bom suporte. Instale-a e carregue o projeto. A extens\u00e3o possui uma documenta\u00e7\u00e3o tanto para a etapa de configura\u00e7\u00e3o e compila\u00e7\u00e3o quanto para execu\u00e7\u00e3o dos programas e debugging . Para executar os programas voc\u00ea pode usar a op\u00e7\u00e3o \"Run in terminal\" dispon\u00edvel no menu do bot\u00e3o direito de cada target . Supondo que a etapa anterior funcionou, vamos agora rodar o nosso programa usando um debugger. Isto permite parar a execu\u00e7\u00e3o no meio do programa e examinar o valor das vari\u00e1veis. coloque um ou mais breakpoints no c\u00f3digo. Basta clicar ao lado do n\u00famero da linha. Um c\u00edrculo vermelho indica que a execu\u00e7\u00e3o ser\u00e1 interrompida quando chegar nesta linha. bot\u00e3o direito no target -> \"Run with debugger\". quando o programa parar teremos as seguintes op\u00e7\u00f5es: Continue : roda at\u00e9 o pr\u00f3ximo breakpoint Step Over : roda a linha atual e passa para a pr\u00f3xima. Step Into : se a linha atual tem uma chamada de fun\u00e7\u00e3o, continua o debug dentro da fun\u00e7\u00e3o chamada. Step Out : executa at\u00e9 o fim da fun\u00e7\u00e3o atual e para logo ap\u00f3s o retorno. Tamb\u00e9m podemos colocar o mouse em cima de cada vari\u00e1vel para ver seu valor. O explorador de vari\u00e1veis (que mostra todas as v\u00e1lidas na fun\u00e7\u00e3o atual) aparece no painel esquerdo, dentro da view debug . Exerc\u00edcio Abra sua atividade e rode-a com o debugger. Pause a execu\u00e7\u00e3o no meio e verifique os tempos de execu\u00e7\u00e3o.","title":"03 - CMake e Debugging no VSCode"},{"location":"aulas/03-cmake/#03-cmake-e-debugging-no-vscode","text":"At\u00e9 o momento todos nossos arquivos eram compilados em uma s\u00f3 linha usando g++ . Conforme projetos ficam maiores e s\u00e3o divididos em v\u00e1rios m\u00f3dulos isto se torna invi\u00e1vel. Neste roteiro iremos usar o CMake, uma ferramenta de gerenciamento de projetos em C++. No fim, iremos configurar o VSCode para abrir projetos CMake. Aten\u00e7\u00e3o Usar ferramentas adequadas aumenta consideravelmente a produtividade e tamb\u00e9m facilita encontrar erros no c\u00f3digo. A partir desta aula ser\u00e1 obrigat\u00f3rio j\u00e1 ter debugado o programa antes de tirar d\u00favidas.","title":"03 - CMake e Debugging no VSCode"},{"location":"aulas/03-cmake/#gerenciamento-de-projetos-com-cmake","text":"O CMake \u00e9 uma das ferramentas mais usadas para gerenciar projetos C/C++. Outras ferramentas comumente usadas s\u00e3o ninja e meson . Em CMake , um projeto \u00e9 definido por um arquivo nomeado CMakeLists.txt . Este arquivo cont\u00e9m defini\u00e7\u00f5es como nome do projeto, quais depend\u00eancias (bibliotecas externas e subprojetos) s\u00e3o usadas e o quais arquivos ser\u00e3o gerados pelo projeto. Cada arquivo gerado \u00e9 chamado de target na nomenclatura usada pelo CMake e pode ser um execut\u00e1vel ou uma biblioteca (est\u00e1tica ou din\u00e2mica). Um arquivo CMakeLists.txt b\u00e1sico pode conter apenas tr\u00eas linhas (pasta 03-cmake ): cmake_minimum_required(VERSION 3.10) project (projeto_basico) add_executable(hello hello.cpp) Este arquivo somente descreve o projeto. Para efetivamente compilarmos o programa precisamos passar pela fase de configura\u00e7\u00e3o , em que o CMake checa se todas as depend\u00eancias foram encontradas e se os compiladores necess\u00e1rios est\u00e3o instalados. Se tudo estiver em ordem podemos gerar um Makefile (para Linux) ou um projeto do Visual Studio (para Windows). Para fazer a configura\u00e7\u00e3o do projeto basta rodar o comando cmake mais o caminho para a pasta do projeto. Voc\u00ea s\u00f3 precisar\u00e1 refazer a configura\u00e7\u00e3o do projeto se modificar o arquivo CMakeLists.txt . \u00c9 boa pr\u00e1tica fazer a compila\u00e7\u00e3o do c\u00f3digo em uma pasta separada, como na sequ\u00eancia de comandos abaixo. mkdir build cd build cmake .. Estes comandos devem ter gerado uma s\u00e9rie de arquivos na pasta build , incluindo um Makefile . Para compilar o projeto basta rodar make E um execut\u00e1vel de nome hello dever\u00e1 aparecer na pasta build . Exerc\u00edcio Crie um arquivo CMakeLists.txt para o projeto 0. Voc\u00ea dever\u00e1 adicionar um target chamado vector_ops . Exerc\u00edcio Separe as fun\u00e7\u00f5es matem\u00e1ticas testadas em arquivos .cpp/h e use-os no seu projeto. A diretiva add_executable aceita v\u00e1rios arquivos .cpp para criar um execut\u00e1vel.","title":"Gerenciamento de projetos com CMake"},{"location":"aulas/03-cmake/#opcoes-de-compilacao","text":"Al\u00e9m da cria\u00e7\u00e3o de execut\u00e1veis o CMake tamb\u00e9m permite adicionar op\u00e7\u00f5es de compila\u00e7\u00e3o espec\u00edficas para cada target com a diretiva target_compile_options . No contexto desta mat\u00e9ria isto ser\u00e1 especialmente interessante pois o g++ oferece flags para ativar otimiza\u00e7\u00f5es que podem melhorar significativamente o desempenho de nosso programa. Portanto, podemos facilmente compilar o mesmo programa com e sem otimiza\u00e7\u00f5es no mesmo projeto! O exemplo abaixo ativa a flag O3 no target hello criado no exemplo anterior. target_compile_options(hello PUBLIC -O3) Podemos tamb\u00e9m usar #define para fazer compila\u00e7\u00e3o condicional do nosso c\u00f3digo. Usar a diretiva abaixo equivale e colocar um #define OPT no topo de cada arquivo do target hello . target_compile_definitions(hello PUBLIC OPT) Exerc\u00edcio Modifique seu target vector_ops para que ele use a op\u00e7\u00e3o de compila\u00e7\u00e3o O2 . Exerc\u00edcio Crie um novo target vector_ops_no_opt que compile os mesmos arquivos de vector_ops mas use a op\u00e7\u00e3o de compila\u00e7\u00e3o O0 .","title":"Op\u00e7\u00f5es de compila\u00e7\u00e3o"},{"location":"aulas/03-cmake/#projeto-0-benchmarking-e-comparacoes-de-desempenho","text":"Vamos agora fazer um pequeno resumo dos resultados dos experimentos. Este resumo dever\u00e1 conter os seguintes itens e dever\u00e1 ser entregue em formato PDF . uma breve descri\u00e7\u00e3o do programa testado (um par\u00e1grafo); os nomes dos execut\u00e1veis testados e qual a diferen\u00e7a entre eles os tamanhos de entrada usados e a m\u00e1quina usada para seus testes gr\u00e1ficos ilustrando a diferen\u00e7a de desempenho para cada fun\u00e7\u00e3o testada coment\u00e1rios sobre os resultados mostrados nos gr\u00e1ficos","title":"Projeto 0 - Benchmarking e compara\u00e7\u00f5es de desempenho"},{"location":"aulas/03-cmake/#dicas","text":"Ferramentas como PWeave ou Jupyter Notebook ajudam muito a criar textos que misturam c\u00f3digo para criar gr\u00e1ficos, rodar programas automaticamente e interpretar sua sa\u00edda. Tente automatizar o m\u00e1ximo poss\u00edvel a gera\u00e7\u00e3o de gr\u00e1ficos de desempenho. Isso facilitar\u00e1 muito sua vida em projetos posteriores.","title":"Dicas"},{"location":"aulas/03-cmake/#extra-01-debugando-seu-projeto","text":"Agora iremos abrir nosso projeto um ambiente de desenvolvimento em vez de continuar trabalhando na linha de comando. Adotaremos o VSCode como ambiente padr\u00e3o. O VSCode n\u00e3o vem com suporte por padr\u00e3o a projetos CMake, mas a extens\u00e3o Cmake Tools possui um bom suporte. Instale-a e carregue o projeto. A extens\u00e3o possui uma documenta\u00e7\u00e3o tanto para a etapa de configura\u00e7\u00e3o e compila\u00e7\u00e3o quanto para execu\u00e7\u00e3o dos programas e debugging . Para executar os programas voc\u00ea pode usar a op\u00e7\u00e3o \"Run in terminal\" dispon\u00edvel no menu do bot\u00e3o direito de cada target . Supondo que a etapa anterior funcionou, vamos agora rodar o nosso programa usando um debugger. Isto permite parar a execu\u00e7\u00e3o no meio do programa e examinar o valor das vari\u00e1veis. coloque um ou mais breakpoints no c\u00f3digo. Basta clicar ao lado do n\u00famero da linha. Um c\u00edrculo vermelho indica que a execu\u00e7\u00e3o ser\u00e1 interrompida quando chegar nesta linha. bot\u00e3o direito no target -> \"Run with debugger\". quando o programa parar teremos as seguintes op\u00e7\u00f5es: Continue : roda at\u00e9 o pr\u00f3ximo breakpoint Step Over : roda a linha atual e passa para a pr\u00f3xima. Step Into : se a linha atual tem uma chamada de fun\u00e7\u00e3o, continua o debug dentro da fun\u00e7\u00e3o chamada. Step Out : executa at\u00e9 o fim da fun\u00e7\u00e3o atual e para logo ap\u00f3s o retorno. Tamb\u00e9m podemos colocar o mouse em cima de cada vari\u00e1vel para ver seu valor. O explorador de vari\u00e1veis (que mostra todas as v\u00e1lidas na fun\u00e7\u00e3o atual) aparece no painel esquerdo, dentro da view debug . Exerc\u00edcio Abra sua atividade e rode-a com o debugger. Pause a execu\u00e7\u00e3o no meio e verifique os tempos de execu\u00e7\u00e3o.","title":"Extra 01 - Debugando seu projeto"},{"location":"aulas/04-autovec/","text":"04 - SIMD: Autovetoriza\u00e7\u00e3o \u00b6 Programas de fazer c\u00e1lculos podem ser acelerados significativamente por instru\u00e7\u00f5es SIMD ( Single Instruction Multiple Data ). Neste contexto, a utiliza\u00e7\u00e3o de compiladores com op\u00e7\u00e3o de autovetoriza\u00e7\u00e3o \u00e9 muito conveniente: se o c\u00f3digo compilado tiver algumas caracter\u00edsticas o compilador \u00e9 capaz utilizar estas instru\u00e7\u00f5es automaticamente e melhorar muito o desempenho sem que um programador precise modificar c\u00f3digo. Um guia para autovetoriza\u00e7\u00e3o usando gcc pode ser encontrado em sua documenta\u00e7\u00e3o . Info Os exerc\u00edcios de aula podem ser feitos em dupla. Capacidade dos registradores \u00b6 Question Levando em conta que a arquitetura AVX armazena dados em registradores de 128 bits , podemos armazenar em um \u00fanico registrador at\u00e9: ____ chars; ____ shorts; ____ ints; ____ longs; ____ floats; ____ doubles; Question A arquitetura AVX2 suporta registradores de 256 bits . Isto significa que c\u00f3digo autovetorizado com instru\u00e7\u00f5es AVX2 pode ser at\u00e9 ____ vezes mais r\u00e1pido do que c\u00f3digo vetorizado com AVX Question Toda instru\u00e7\u00e3o SIMD opera sobre todos os elementos guardados ao mesmo tempo. Ou seja, ao executar uma instru\u00e7\u00e3o SIMD de soma de vari\u00e1veis int no registrador %xmm0 estarei somando ____ vari\u00e1veis em uma s\u00f3 instru\u00e7\u00e3o. Instru\u00e7\u00f5es vetoriais \u00b6 Vamos agora compilar alguns c\u00f3digos em C++ para Assembly usando as op\u00e7\u00f5es -ffast-math -ftree-vectorize -mavx do gcc . Estas op\u00e7\u00f5es habilitam a autovetoriza\u00e7\u00e3o de c\u00f3digo. Ou sejam elas analisam o c\u00f3digo e procuram substituir loops e acessos sequenciais a vetores por instru\u00e7\u00f5es SIMD que fa\u00e7am o mesmo trabalho. A flag -mavx indica que o c\u00f3digo de m\u00e1quina gerado pode utilizar instru\u00e7\u00f5es SIMD da arquitetura AVX (e de sua predecessora, SSE), que usa registradores de 128 bits nomeados %xmm0 at\u00e9 %xmm7 e de 256 bits nomeados %ymm0 at\u00e9 %ymm15 . Vamos agora analisar o c\u00f3digo Assembly de uma fun\u00e7\u00e3o simples que soma todos elementos de um vetor. // Original: Nicolas Brailovsky #define SIZE (400) long sum ( long v [ SIZE ]) { long s = 0 ; for ( long i = 0 ; i < SIZE ; i ++ ) s += v [ i ]; return s ; } Example Compile este c\u00f3digo com otimiza\u00e7\u00f5es b\u00e1sicas ( -O2 ) $ g++ -S -c -O2 tarefa1.cpp -o /dev/stdout | c++filt Agora adicione autovetoriza\u00e7\u00e3o (com as flags listadas acima) $ g++ -S -c -O2 -ffast-math -ftree-vectorize -mavx tarefa1.cpp -o /dev/stdout | c++filt Question Compare as instru\u00e7\u00f5es Assembly geradas acima e escreva abaixo as diferen\u00e7as percebidas. Voc\u00ea consegue explicar seu funcionamento? Aplicando autovetoriza\u00e7\u00e3o \u00b6 Nesta tarefa iremos trabalhar com as op\u00e7\u00f5es de autovetoriza\u00e7\u00e3o do gcc para entender como escrever c\u00f3digo que possa ser otimizado automaticamente. Example Escreva uma fun\u00e7\u00e3o main que gera um vetor de tamanho 10.000.000 contendo n\u00fameros aleat\u00f3rios uniformemente distribu\u00eddos entre -10 e 10 . Use as fun\u00e7\u00f5es do cabe\u00e7alho <random> . Example Escreva uma fun\u00e7\u00e3o double soma_positivos1(double *a, int n) que soma todos os n\u00fameros positivos do vetor a . Adicione uma chamada a esta fun\u00e7\u00e3o no seu main e use as fun\u00e7\u00f5es do cabe\u00e7alho <chrono> para medir o tempo de execu\u00e7\u00e3o da sua fun\u00e7\u00e3o. Neste exerc\u00edcio voc\u00ea dever\u00e1 usar um if para checar se os n\u00fameros s\u00e3o positivos. Question Compile com e sem as otimiza\u00e7\u00f5es SIMD e escreva abaixo os tempos de execu\u00e7\u00e3o. O auto vetorizador suporta uma s\u00e9rie de padr\u00f5es de codifica\u00e7\u00e3o relativamente abrangente ( lista completa ). Por\u00e9m, c\u00f3digos que s\u00e3o vetorizados de maneira id\u00eantica podem possuir desempenho bastante diferente quanto a vetoriza\u00e7\u00e3o n\u00e3o est\u00e1 habilitada. Example Fa\u00e7a uma fun\u00e7\u00e3o double soma_positivos2(double *a, int n) que faz o mesmo que a fun\u00e7\u00e3o anterior, mas usando agora o operador tern\u00e1rio (cond)?expr_true:expr_false ao inv\u00e9s de um if . (Se voc\u00ea fez com o operador tern\u00e1rio acima fa\u00e7a com if ). Houve diferen\u00e7a de desempenho na vers\u00e3o SIMD? E na vers\u00e3o sem SIMD? Question Complete a tabela abaixo com os tempos obtidos - SIMD sem SIMD if-else tern\u00e1rio Exerc\u00edcio Qual vers\u00e3o da fun\u00e7\u00e3o anterior voc\u00ea usaria se seu c\u00f3digo fosse executado em processadores de baixo custo (Intel Celeron) ou muito antigos (mais de 5 anos)? E se o plano for executar em processadores novos? Projeto 0 - aplicando autovetoriza\u00e7\u00e3o \u00b6 Warning Os exerc\u00edcios do Projeto 0 s\u00e3o individuais. Nas \u00faltimas duas tarefas vimos como usar as op\u00e7\u00f5es do compilador para gerar instru\u00e7\u00f5es SIMD, tornando nossos programas mais eficientes. Agora vamos aplic\u00e1-las ao nosso exemplo dos experimentos. Voc\u00ea dever\u00e1 criar um novo target vector_ops_simd com as op\u00e7\u00f5es de compila\u00e7\u00e3o SIMD e a flag de otimiza\u00e7\u00e3o O3 atualizar seus gr\u00e1ficos de desempenho com o novo experimento comentar os novos resultados, respondendo \u00e0s seguintes perguntas: A partir de qual tamanho de array o c\u00f3digo vetorizado mostra ganhos de desempenho expressivos? Qual \u00e9 o ganho de desempenho esperado? Leve em conta a arquitetura usada e o tipo de dados usado. Os ganhos de desempenho s\u00e3o consistentes com o esperado?","title":"04 - SIMD: Autovetoriza\u00e7\u00e3o"},{"location":"aulas/04-autovec/#04-simd-autovetorizacao","text":"Programas de fazer c\u00e1lculos podem ser acelerados significativamente por instru\u00e7\u00f5es SIMD ( Single Instruction Multiple Data ). Neste contexto, a utiliza\u00e7\u00e3o de compiladores com op\u00e7\u00e3o de autovetoriza\u00e7\u00e3o \u00e9 muito conveniente: se o c\u00f3digo compilado tiver algumas caracter\u00edsticas o compilador \u00e9 capaz utilizar estas instru\u00e7\u00f5es automaticamente e melhorar muito o desempenho sem que um programador precise modificar c\u00f3digo. Um guia para autovetoriza\u00e7\u00e3o usando gcc pode ser encontrado em sua documenta\u00e7\u00e3o . Info Os exerc\u00edcios de aula podem ser feitos em dupla.","title":"04 - SIMD: Autovetoriza\u00e7\u00e3o"},{"location":"aulas/04-autovec/#capacidade-dos-registradores","text":"Question Levando em conta que a arquitetura AVX armazena dados em registradores de 128 bits , podemos armazenar em um \u00fanico registrador at\u00e9: ____ chars; ____ shorts; ____ ints; ____ longs; ____ floats; ____ doubles; Question A arquitetura AVX2 suporta registradores de 256 bits . Isto significa que c\u00f3digo autovetorizado com instru\u00e7\u00f5es AVX2 pode ser at\u00e9 ____ vezes mais r\u00e1pido do que c\u00f3digo vetorizado com AVX Question Toda instru\u00e7\u00e3o SIMD opera sobre todos os elementos guardados ao mesmo tempo. Ou seja, ao executar uma instru\u00e7\u00e3o SIMD de soma de vari\u00e1veis int no registrador %xmm0 estarei somando ____ vari\u00e1veis em uma s\u00f3 instru\u00e7\u00e3o.","title":"Capacidade dos registradores"},{"location":"aulas/04-autovec/#instrucoes-vetoriais","text":"Vamos agora compilar alguns c\u00f3digos em C++ para Assembly usando as op\u00e7\u00f5es -ffast-math -ftree-vectorize -mavx do gcc . Estas op\u00e7\u00f5es habilitam a autovetoriza\u00e7\u00e3o de c\u00f3digo. Ou sejam elas analisam o c\u00f3digo e procuram substituir loops e acessos sequenciais a vetores por instru\u00e7\u00f5es SIMD que fa\u00e7am o mesmo trabalho. A flag -mavx indica que o c\u00f3digo de m\u00e1quina gerado pode utilizar instru\u00e7\u00f5es SIMD da arquitetura AVX (e de sua predecessora, SSE), que usa registradores de 128 bits nomeados %xmm0 at\u00e9 %xmm7 e de 256 bits nomeados %ymm0 at\u00e9 %ymm15 . Vamos agora analisar o c\u00f3digo Assembly de uma fun\u00e7\u00e3o simples que soma todos elementos de um vetor. // Original: Nicolas Brailovsky #define SIZE (400) long sum ( long v [ SIZE ]) { long s = 0 ; for ( long i = 0 ; i < SIZE ; i ++ ) s += v [ i ]; return s ; } Example Compile este c\u00f3digo com otimiza\u00e7\u00f5es b\u00e1sicas ( -O2 ) $ g++ -S -c -O2 tarefa1.cpp -o /dev/stdout | c++filt Agora adicione autovetoriza\u00e7\u00e3o (com as flags listadas acima) $ g++ -S -c -O2 -ffast-math -ftree-vectorize -mavx tarefa1.cpp -o /dev/stdout | c++filt Question Compare as instru\u00e7\u00f5es Assembly geradas acima e escreva abaixo as diferen\u00e7as percebidas. Voc\u00ea consegue explicar seu funcionamento?","title":"Instru\u00e7\u00f5es vetoriais"},{"location":"aulas/04-autovec/#aplicando-autovetorizacao","text":"Nesta tarefa iremos trabalhar com as op\u00e7\u00f5es de autovetoriza\u00e7\u00e3o do gcc para entender como escrever c\u00f3digo que possa ser otimizado automaticamente. Example Escreva uma fun\u00e7\u00e3o main que gera um vetor de tamanho 10.000.000 contendo n\u00fameros aleat\u00f3rios uniformemente distribu\u00eddos entre -10 e 10 . Use as fun\u00e7\u00f5es do cabe\u00e7alho <random> . Example Escreva uma fun\u00e7\u00e3o double soma_positivos1(double *a, int n) que soma todos os n\u00fameros positivos do vetor a . Adicione uma chamada a esta fun\u00e7\u00e3o no seu main e use as fun\u00e7\u00f5es do cabe\u00e7alho <chrono> para medir o tempo de execu\u00e7\u00e3o da sua fun\u00e7\u00e3o. Neste exerc\u00edcio voc\u00ea dever\u00e1 usar um if para checar se os n\u00fameros s\u00e3o positivos. Question Compile com e sem as otimiza\u00e7\u00f5es SIMD e escreva abaixo os tempos de execu\u00e7\u00e3o. O auto vetorizador suporta uma s\u00e9rie de padr\u00f5es de codifica\u00e7\u00e3o relativamente abrangente ( lista completa ). Por\u00e9m, c\u00f3digos que s\u00e3o vetorizados de maneira id\u00eantica podem possuir desempenho bastante diferente quanto a vetoriza\u00e7\u00e3o n\u00e3o est\u00e1 habilitada. Example Fa\u00e7a uma fun\u00e7\u00e3o double soma_positivos2(double *a, int n) que faz o mesmo que a fun\u00e7\u00e3o anterior, mas usando agora o operador tern\u00e1rio (cond)?expr_true:expr_false ao inv\u00e9s de um if . (Se voc\u00ea fez com o operador tern\u00e1rio acima fa\u00e7a com if ). Houve diferen\u00e7a de desempenho na vers\u00e3o SIMD? E na vers\u00e3o sem SIMD? Question Complete a tabela abaixo com os tempos obtidos - SIMD sem SIMD if-else tern\u00e1rio Exerc\u00edcio Qual vers\u00e3o da fun\u00e7\u00e3o anterior voc\u00ea usaria se seu c\u00f3digo fosse executado em processadores de baixo custo (Intel Celeron) ou muito antigos (mais de 5 anos)? E se o plano for executar em processadores novos?","title":"Aplicando autovetoriza\u00e7\u00e3o"},{"location":"aulas/04-autovec/#projeto-0-aplicando-autovetorizacao","text":"Warning Os exerc\u00edcios do Projeto 0 s\u00e3o individuais. Nas \u00faltimas duas tarefas vimos como usar as op\u00e7\u00f5es do compilador para gerar instru\u00e7\u00f5es SIMD, tornando nossos programas mais eficientes. Agora vamos aplic\u00e1-las ao nosso exemplo dos experimentos. Voc\u00ea dever\u00e1 criar um novo target vector_ops_simd com as op\u00e7\u00f5es de compila\u00e7\u00e3o SIMD e a flag de otimiza\u00e7\u00e3o O3 atualizar seus gr\u00e1ficos de desempenho com o novo experimento comentar os novos resultados, respondendo \u00e0s seguintes perguntas: A partir de qual tamanho de array o c\u00f3digo vetorizado mostra ganhos de desempenho expressivos? Qual \u00e9 o ganho de desempenho esperado? Leve em conta a arquitetura usada e o tipo de dados usado. Os ganhos de desempenho s\u00e3o consistentes com o esperado?","title":"Projeto 0 - aplicando autovetoriza\u00e7\u00e3o"},{"location":"aulas/05-intro-multi-core/","text":"05 - Introdu\u00e7\u00e3o a multi-core \u00b6 Fonte: https://en.wikipedia.org/wiki/File:Fork_join.svg Como visto em aula, o modelo fork-join segue tr\u00eas passos b\u00e1sicos: Dividir o problema em peda\u00e7os Resolver cada peda\u00e7o individualmente Juntar as respostas parciais em um resultado final Vamos criar uma implementa\u00e7\u00e3o raiz desse modelo usando threads em C++11. Parte 1 - o cabe\u00e7alho thread \u00b6 Nesta parte iremos aprender a criar threads e esperar sua finaliza\u00e7\u00e3o usando C++11 std::threads . Veja abaixo um exemplo com as fun\u00e7\u00f5es que precisaremos usar (arquivo exemplo1-threads.cpp ). #include <thread> #include <iostream> void funcao_rodando_em_paralelo ( int a , int * b ) { std :: cout << \"a=\" << a << std :: endl ; * b = 5 ; } int main () { int b = 10 ; // Cria thread e a executa. // Primeiro argumento \u00e9 a fun\u00e7\u00e3o a ser executada. // Os argumentos em seguida s\u00e3o passados diretamente // para a fun\u00e7\u00e3o passada no primeiro argumento. std :: thread t1 ( funcao_rodando_em_paralelo , 15 , & b ); std :: cout << \"Antes do join b=\" << b << std :: endl ; // Espera at\u00e9 que a fun\u00e7\u00e3o acabe de executar. t1 . join (); std :: cout << \"Depois do join b=\" << b << std :: endl ; } Example Compile e roda o programa acima. Voc\u00ea precisar\u00e1 passar a flag -pthread para o g++ . O resultado \u00e9 o esperado? Example Modifique o programa acima para criar 4 threads e atribuir a cada uma um id de 0 a 3. Cada thread deve executar uma fun\u00e7\u00e3o que imprime \"Thread: \" + id. (Voc\u00ea precisa ainda da vari\u00e1vel int *b ?) Question Pesquise como detectar o m\u00e1ximo de threads de hardware e incorpore esta informa\u00e7\u00e3o no seu programa acima. Ele dever\u00e1 criar este n\u00famero de threads. Escreva a chamada usada abaixo. Example Modifique seu programa acima para retornar um o id da thread ao quadrado. Como voc\u00ea faria isto? Como voc\u00ea guardaria essa informa\u00e7\u00e3o no main ? Dica : exemplo1-threads.cpp faz isso com a vari\u00e1vel b . Example Fa\u00e7a sua fun\u00e7\u00e3o main mostrar a soma dos quadrados dos valores recebidos no item anterior. Parte 2 - paralelizando uma opera\u00e7\u00e3o de complexa \u00b6 Vamos agora paralelizar um problema mais complexo: o c\u00e1lculo do pi . O arquivo pi-numeric-integration.cpp cont\u00e9m uma implementa\u00e7\u00e3o sequencial usando a t\u00e9cnica de integra\u00e7\u00e3o num\u00e9rica vista nos slides. Seu trabalho ser\u00e1: dividir o trabalho desta fun\u00e7\u00e3o em 4 threads, cada uma computando uma parte da sequ\u00eancia salvar os resultados parciais de cada thread em um elemento de um vetor criado no main somar os resultados parciais. Seu programa dever\u00e1 apresentar resultado similar ao programa sequencial, mas funcionar em aproximadamente um quarto do tempo. Warning Este trabalho est\u00e1 com uma descri\u00e7\u00e3o vaga de prop\u00f3sito. \u00c9 parte dos objetivos entender o c\u00f3digo sequencial dado como exemplo e como dividir os trabalhos entre as threads.","title":"05 - Introdu\u00e7\u00e3o a multi-core"},{"location":"aulas/05-intro-multi-core/#05-introducao-a-multi-core","text":"Fonte: https://en.wikipedia.org/wiki/File:Fork_join.svg Como visto em aula, o modelo fork-join segue tr\u00eas passos b\u00e1sicos: Dividir o problema em peda\u00e7os Resolver cada peda\u00e7o individualmente Juntar as respostas parciais em um resultado final Vamos criar uma implementa\u00e7\u00e3o raiz desse modelo usando threads em C++11.","title":"05 - Introdu\u00e7\u00e3o a multi-core"},{"location":"aulas/05-intro-multi-core/#parte-1-o-cabecalho-thread","text":"Nesta parte iremos aprender a criar threads e esperar sua finaliza\u00e7\u00e3o usando C++11 std::threads . Veja abaixo um exemplo com as fun\u00e7\u00f5es que precisaremos usar (arquivo exemplo1-threads.cpp ). #include <thread> #include <iostream> void funcao_rodando_em_paralelo ( int a , int * b ) { std :: cout << \"a=\" << a << std :: endl ; * b = 5 ; } int main () { int b = 10 ; // Cria thread e a executa. // Primeiro argumento \u00e9 a fun\u00e7\u00e3o a ser executada. // Os argumentos em seguida s\u00e3o passados diretamente // para a fun\u00e7\u00e3o passada no primeiro argumento. std :: thread t1 ( funcao_rodando_em_paralelo , 15 , & b ); std :: cout << \"Antes do join b=\" << b << std :: endl ; // Espera at\u00e9 que a fun\u00e7\u00e3o acabe de executar. t1 . join (); std :: cout << \"Depois do join b=\" << b << std :: endl ; } Example Compile e roda o programa acima. Voc\u00ea precisar\u00e1 passar a flag -pthread para o g++ . O resultado \u00e9 o esperado? Example Modifique o programa acima para criar 4 threads e atribuir a cada uma um id de 0 a 3. Cada thread deve executar uma fun\u00e7\u00e3o que imprime \"Thread: \" + id. (Voc\u00ea precisa ainda da vari\u00e1vel int *b ?) Question Pesquise como detectar o m\u00e1ximo de threads de hardware e incorpore esta informa\u00e7\u00e3o no seu programa acima. Ele dever\u00e1 criar este n\u00famero de threads. Escreva a chamada usada abaixo. Example Modifique seu programa acima para retornar um o id da thread ao quadrado. Como voc\u00ea faria isto? Como voc\u00ea guardaria essa informa\u00e7\u00e3o no main ? Dica : exemplo1-threads.cpp faz isso com a vari\u00e1vel b . Example Fa\u00e7a sua fun\u00e7\u00e3o main mostrar a soma dos quadrados dos valores recebidos no item anterior.","title":"Parte 1 - o cabe\u00e7alho thread"},{"location":"aulas/05-intro-multi-core/#parte-2-paralelizando-uma-operacao-de-complexa","text":"Vamos agora paralelizar um problema mais complexo: o c\u00e1lculo do pi . O arquivo pi-numeric-integration.cpp cont\u00e9m uma implementa\u00e7\u00e3o sequencial usando a t\u00e9cnica de integra\u00e7\u00e3o num\u00e9rica vista nos slides. Seu trabalho ser\u00e1: dividir o trabalho desta fun\u00e7\u00e3o em 4 threads, cada uma computando uma parte da sequ\u00eancia salvar os resultados parciais de cada thread em um elemento de um vetor criado no main somar os resultados parciais. Seu programa dever\u00e1 apresentar resultado similar ao programa sequencial, mas funcionar em aproximadamente um quarto do tempo. Warning Este trabalho est\u00e1 com uma descri\u00e7\u00e3o vaga de prop\u00f3sito. \u00c9 parte dos objetivos entender o c\u00f3digo sequencial dado como exemplo e como dividir os trabalhos entre as threads.","title":"Parte 2 - paralelizando uma opera\u00e7\u00e3o de complexa"},{"location":"aulas/06-intro-openmp/","text":"06 - Introdu\u00e7\u00e3o a OpenMP \u00b6 OpenMP \u00e9 uma tecnologia de computa\u00e7\u00e3o multi-core usada para paralelizar programas de modo facilitado. Ele \u00e9 ideal para programar programas que usem o modelo fork-join que estudaremos nesta primeira parte do curso. Fonte: https://en.wikipedia.org/wiki/File:Fork_join.svg Parte 0 - primeiros usos \u00b6 Nesta parte do roteiro usaremos 4 chamadas do OpenMP para recriar o primeiro exemplo da aula passada. #pragma omp parallel cria um conjunto de threads. Deve ser aplicado acima de um bloco de c\u00f3digo limitado por { } int omp_get_num_threads(); retorna o n\u00famero de threads criadas (dentro de uma regi\u00e3o paralela) int omp_get_max_threads(); retorna o n\u00famero de m\u00e1ximo de threads (fora de uma regi\u00e3o paralela) int omp_get_thread_num(); retorna o id da thread atual (entre 0 e o valor acima, dentro de uma regi\u00e3o paralela) O c\u00f3digo abaixo ( exemplo1.c ) ilustra como utilizar OpenMP para fazer o exercicio 1 do roteiro anterior (criar 4 threads e imprimir um id de 0 a 3). #include <iostream> #include <omp.h> int main () { #pragma omp parallel { std :: cout << \"ID:\" << omp_get_thread_num () << \"/\" << omp_get_num_threads () << \" \\n \" ; } std :: cout << \"Join implicito no fim do bloco!\" << \" \\n \" ; return 0 ; } Perceba que a principal utilidade do OpenMP \u00e9 facilitar a programa\u00e7\u00e3o quando todas as threads rodam o mesmo programa e a cria\u00e7\u00e3o de threads e a jun\u00e7\u00e3o de seus resultados ocorre de maneira frequente no programa. Example Compile o programa abaixo usando a seguinte linha de comando e rode-o. $ g++ -O3 exemplo1.cpp -o exemplo1 -fopenmp Question O OpenMP permite alterar o n\u00famero m\u00e1ximo de threads criados usando a vari\u00e1vel de ambiente OMP_NUM_THREADS . Rode exemplo1 como abaixo. OMP_NUM_THREADS=2 ./exemplo1 Os resultados foram os esperados? Rode agora sem a vari\u00e1vel de ambiente. Qual \u00e9 o valor padr\u00e3o assumido pelo OpenMP? \u00c9 uma boa ideia usar mais threads que o valor padr\u00e3o? A utiliza\u00e7\u00e3o de OMP_NUM_THREADS ajuda a realizar testes de modo a compreender os ganhos de desempenho de um programa conforme mais threads s\u00e3o utilizadas. Parte 1 - funcionalidades do OpenMP \u00b6 Vamos continuar usando o exemplo pi-numeric-integration.cpp neste roteiro. Iremos comparar nosso programa da aula passada com implementa\u00e7\u00f5es usando OpenMP. Example Refatore sua implementa\u00e7\u00e3o da aula passada para que todo seu c\u00f3digo usando threads esteja dispon\u00edvel em um fun\u00e7\u00e3o double_pi_threads_raiz(long steps) e que o c\u00f3digo original esteja em uma fun\u00e7\u00e3o double pi_seq(long steps) . Example Chame ambas fun\u00e7\u00f5es no main e compare seus resultados e o tempo necess\u00e1rio para cada uma rodar. Note Verifique que a vers\u00e3o usando threads demora um quarto do tempo da vers\u00e3o sequencial. Vamos agora fazer um primeiro teste usando OpenMP. No exerc\u00edcio abaixo vamos somente substituir a cria\u00e7\u00e3o das threads usando <threads> pela cria\u00e7\u00e3o usando diretivas do OpenMP. Example Crie uma fun\u00e7\u00e3o double pi_omp_parallel(long steps) que fa\u00e7a o c\u00e1lculo do pi de modo paralelo usando #pragma omp parallel . Siga a mesma receita do seu programa usando threads: As itera\u00e7\u00f5es do for s\u00e3o divididas por igual entre as threads; Cada thread acumula seus resultados parciais armazenados em um vetor double sum[] . Para efeitos de exerc\u00edcio, use a constru\u00e7\u00e3o sum[id] += No fim os resultados parciais s\u00e3o usados para o c\u00e1lculo final. Adicione uma chamada a esta fun\u00e7\u00e3o no main e mostre seu resultado e o tempo gasto. J\u00e1 vimos que acessar a mesma vari\u00e1vel (ou posi\u00e7\u00e3o em um vetor) resulta em resultados incorretos. Por quest\u00f5es de cache, escrever em posi\u00e7\u00f5es vizinhas de um vetor resulta em desempenho longe do ideal. Podemos arrumar isto criando uma vari\u00e1vel local para acumular a soma e s\u00f3 escrever seu resultado no vetor double sum[] no fim. Example Crie uma fun\u00e7\u00e3o double pi_omp_parallel_local(long steps) que, ao inv\u00e9s de fazer sum[id] += use uma vari\u00e1vel local para guardar a soma e fa\u00e7a a atribui\u00e7\u00e3o somente no fim da se\u00e7\u00e3o paralela. Como antes, adicione uma chamada ao main e verifique se houve ganho de desempenho. Sincroniza\u00e7\u00e3o \u00b6 O OpenMP nos permite eliminar o vetor double sum[] usando diretivas de sincroniza\u00e7\u00e3o de alto n\u00edvel. As duas mais simples s\u00e3o atomic e critical . A diretiva atomic executa uma atribui\u00e7\u00e3o ou uma opera\u00e7\u00e3o aritm\u00e9tica inplace ( +=, -=, *=, /= ) garantindo que ela ser\u00e1 conclu\u00edda mesmo se outros cores tentarem faz\u00ea-la. Question Como voc\u00ea poderia eliminar o vetor double sum[] usado nos exerc\u00edcios anteriores usando atomic ? Example Fa\u00e7a uma fun\u00e7\u00e3o double pi_omp_parallel_atomic(long steps) usando esta diretiva, adicione-a no main e mostre seu resultado e o tempo gasto. Dever\u00e1 haver ganho de desempenho. A diretiva critical \u00e9 aplicada a um bloco e faz com que ele esteja em execu\u00e7\u00e3o em no m\u00e1ximo 1 das threads. Este nome vem do conceito de se\u00e7\u00e3o cr\u00edtica , que representa uma se\u00e7\u00e3o de uma tarefa que n\u00e3o pode ser paralelizada de jeito algum e obrigatoriamente deve ser executada de modo sequencial. O uso de critical \u00e9 muito perigoso, pois ao for\u00e7ar a execu\u00e7\u00e3o sequencial de um bloco de c\u00f3digo podemos estar efetivamente matando o paralelismo do nosso programa. A constru\u00e7\u00e3o atomic \u00e9 uma se\u00e7\u00e3o cr\u00edtica de apenas uma linha e usa suporte do hardware para rodar. A constru\u00e7\u00e3o critical permite serializar v\u00e1rias linhas de c\u00f3digo, mas exige suporte do Sistema Operacional e \u00e9 bastante lenta. Example Fa\u00e7a uma fun\u00e7\u00e3o double pi_omp_parallel_critical(long steps) usando esta diretiva, adicione-a no main e mostre seu resultado e o tempo gasto. A implementa\u00e7\u00e3o correta dever\u00e1 ficar praticamente igual ao atomic . Example Vamos agora fazer uma implementa\u00e7\u00e3o errada de critical . Na vers\u00e3o anterior usamos uma vari\u00e1vel local para cada armazenar os resultados parciais de cada thread. Troque seu uso para armazenar na vari\u00e1vel de fora da se\u00e7\u00e3o paralela usando critical . Chame esta fun\u00e7\u00e3o de double pi_omp_parallel_critical_errado(long steps) . Adicione-a no main e mostre seu resultado e o tempo gasto. O resultado final dever\u00e1 ser pior que suas outras vers\u00f5es. Neste momento voc\u00ea deve ter obtido um programa com desempenho ao menos cerca de 50% mais r\u00e1pido que o programa original. Mais importante, seu programa agora \u00e9 muito mais simples de ler (e escrever) do que usando diretamente std::thread . Na pr\u00f3xima aula veremos como simplificar ainda mais estes c\u00f3digos usando constru\u00e7\u00f5es de alto n\u00edvel do OpenMP.","title":"06 - Introdu\u00e7\u00e3o a OpenMP"},{"location":"aulas/06-intro-openmp/#06-introducao-a-openmp","text":"OpenMP \u00e9 uma tecnologia de computa\u00e7\u00e3o multi-core usada para paralelizar programas de modo facilitado. Ele \u00e9 ideal para programar programas que usem o modelo fork-join que estudaremos nesta primeira parte do curso. Fonte: https://en.wikipedia.org/wiki/File:Fork_join.svg","title":"06 - Introdu\u00e7\u00e3o a OpenMP"},{"location":"aulas/06-intro-openmp/#parte-0-primeiros-usos","text":"Nesta parte do roteiro usaremos 4 chamadas do OpenMP para recriar o primeiro exemplo da aula passada. #pragma omp parallel cria um conjunto de threads. Deve ser aplicado acima de um bloco de c\u00f3digo limitado por { } int omp_get_num_threads(); retorna o n\u00famero de threads criadas (dentro de uma regi\u00e3o paralela) int omp_get_max_threads(); retorna o n\u00famero de m\u00e1ximo de threads (fora de uma regi\u00e3o paralela) int omp_get_thread_num(); retorna o id da thread atual (entre 0 e o valor acima, dentro de uma regi\u00e3o paralela) O c\u00f3digo abaixo ( exemplo1.c ) ilustra como utilizar OpenMP para fazer o exercicio 1 do roteiro anterior (criar 4 threads e imprimir um id de 0 a 3). #include <iostream> #include <omp.h> int main () { #pragma omp parallel { std :: cout << \"ID:\" << omp_get_thread_num () << \"/\" << omp_get_num_threads () << \" \\n \" ; } std :: cout << \"Join implicito no fim do bloco!\" << \" \\n \" ; return 0 ; } Perceba que a principal utilidade do OpenMP \u00e9 facilitar a programa\u00e7\u00e3o quando todas as threads rodam o mesmo programa e a cria\u00e7\u00e3o de threads e a jun\u00e7\u00e3o de seus resultados ocorre de maneira frequente no programa. Example Compile o programa abaixo usando a seguinte linha de comando e rode-o. $ g++ -O3 exemplo1.cpp -o exemplo1 -fopenmp Question O OpenMP permite alterar o n\u00famero m\u00e1ximo de threads criados usando a vari\u00e1vel de ambiente OMP_NUM_THREADS . Rode exemplo1 como abaixo. OMP_NUM_THREADS=2 ./exemplo1 Os resultados foram os esperados? Rode agora sem a vari\u00e1vel de ambiente. Qual \u00e9 o valor padr\u00e3o assumido pelo OpenMP? \u00c9 uma boa ideia usar mais threads que o valor padr\u00e3o? A utiliza\u00e7\u00e3o de OMP_NUM_THREADS ajuda a realizar testes de modo a compreender os ganhos de desempenho de um programa conforme mais threads s\u00e3o utilizadas.","title":"Parte 0 - primeiros usos"},{"location":"aulas/06-intro-openmp/#parte-1-funcionalidades-do-openmp","text":"Vamos continuar usando o exemplo pi-numeric-integration.cpp neste roteiro. Iremos comparar nosso programa da aula passada com implementa\u00e7\u00f5es usando OpenMP. Example Refatore sua implementa\u00e7\u00e3o da aula passada para que todo seu c\u00f3digo usando threads esteja dispon\u00edvel em um fun\u00e7\u00e3o double_pi_threads_raiz(long steps) e que o c\u00f3digo original esteja em uma fun\u00e7\u00e3o double pi_seq(long steps) . Example Chame ambas fun\u00e7\u00f5es no main e compare seus resultados e o tempo necess\u00e1rio para cada uma rodar. Note Verifique que a vers\u00e3o usando threads demora um quarto do tempo da vers\u00e3o sequencial. Vamos agora fazer um primeiro teste usando OpenMP. No exerc\u00edcio abaixo vamos somente substituir a cria\u00e7\u00e3o das threads usando <threads> pela cria\u00e7\u00e3o usando diretivas do OpenMP. Example Crie uma fun\u00e7\u00e3o double pi_omp_parallel(long steps) que fa\u00e7a o c\u00e1lculo do pi de modo paralelo usando #pragma omp parallel . Siga a mesma receita do seu programa usando threads: As itera\u00e7\u00f5es do for s\u00e3o divididas por igual entre as threads; Cada thread acumula seus resultados parciais armazenados em um vetor double sum[] . Para efeitos de exerc\u00edcio, use a constru\u00e7\u00e3o sum[id] += No fim os resultados parciais s\u00e3o usados para o c\u00e1lculo final. Adicione uma chamada a esta fun\u00e7\u00e3o no main e mostre seu resultado e o tempo gasto. J\u00e1 vimos que acessar a mesma vari\u00e1vel (ou posi\u00e7\u00e3o em um vetor) resulta em resultados incorretos. Por quest\u00f5es de cache, escrever em posi\u00e7\u00f5es vizinhas de um vetor resulta em desempenho longe do ideal. Podemos arrumar isto criando uma vari\u00e1vel local para acumular a soma e s\u00f3 escrever seu resultado no vetor double sum[] no fim. Example Crie uma fun\u00e7\u00e3o double pi_omp_parallel_local(long steps) que, ao inv\u00e9s de fazer sum[id] += use uma vari\u00e1vel local para guardar a soma e fa\u00e7a a atribui\u00e7\u00e3o somente no fim da se\u00e7\u00e3o paralela. Como antes, adicione uma chamada ao main e verifique se houve ganho de desempenho.","title":"Parte 1 - funcionalidades do OpenMP"},{"location":"aulas/06-intro-openmp/#sincronizacao","text":"O OpenMP nos permite eliminar o vetor double sum[] usando diretivas de sincroniza\u00e7\u00e3o de alto n\u00edvel. As duas mais simples s\u00e3o atomic e critical . A diretiva atomic executa uma atribui\u00e7\u00e3o ou uma opera\u00e7\u00e3o aritm\u00e9tica inplace ( +=, -=, *=, /= ) garantindo que ela ser\u00e1 conclu\u00edda mesmo se outros cores tentarem faz\u00ea-la. Question Como voc\u00ea poderia eliminar o vetor double sum[] usado nos exerc\u00edcios anteriores usando atomic ? Example Fa\u00e7a uma fun\u00e7\u00e3o double pi_omp_parallel_atomic(long steps) usando esta diretiva, adicione-a no main e mostre seu resultado e o tempo gasto. Dever\u00e1 haver ganho de desempenho. A diretiva critical \u00e9 aplicada a um bloco e faz com que ele esteja em execu\u00e7\u00e3o em no m\u00e1ximo 1 das threads. Este nome vem do conceito de se\u00e7\u00e3o cr\u00edtica , que representa uma se\u00e7\u00e3o de uma tarefa que n\u00e3o pode ser paralelizada de jeito algum e obrigatoriamente deve ser executada de modo sequencial. O uso de critical \u00e9 muito perigoso, pois ao for\u00e7ar a execu\u00e7\u00e3o sequencial de um bloco de c\u00f3digo podemos estar efetivamente matando o paralelismo do nosso programa. A constru\u00e7\u00e3o atomic \u00e9 uma se\u00e7\u00e3o cr\u00edtica de apenas uma linha e usa suporte do hardware para rodar. A constru\u00e7\u00e3o critical permite serializar v\u00e1rias linhas de c\u00f3digo, mas exige suporte do Sistema Operacional e \u00e9 bastante lenta. Example Fa\u00e7a uma fun\u00e7\u00e3o double pi_omp_parallel_critical(long steps) usando esta diretiva, adicione-a no main e mostre seu resultado e o tempo gasto. A implementa\u00e7\u00e3o correta dever\u00e1 ficar praticamente igual ao atomic . Example Vamos agora fazer uma implementa\u00e7\u00e3o errada de critical . Na vers\u00e3o anterior usamos uma vari\u00e1vel local para cada armazenar os resultados parciais de cada thread. Troque seu uso para armazenar na vari\u00e1vel de fora da se\u00e7\u00e3o paralela usando critical . Chame esta fun\u00e7\u00e3o de double pi_omp_parallel_critical_errado(long steps) . Adicione-a no main e mostre seu resultado e o tempo gasto. O resultado final dever\u00e1 ser pior que suas outras vers\u00f5es. Neste momento voc\u00ea deve ter obtido um programa com desempenho ao menos cerca de 50% mais r\u00e1pido que o programa original. Mais importante, seu programa agora \u00e9 muito mais simples de ler (e escrever) do que usando diretamente std::thread . Na pr\u00f3xima aula veremos como simplificar ainda mais estes c\u00f3digos usando constru\u00e7\u00f5es de alto n\u00edvel do OpenMP.","title":"Sincroniza\u00e7\u00e3o"},{"location":"aulas/07-openmp-for/","text":"07 - OpenMP: Constru\u00e7\u00f5es de alto n\u00edvel \u00b6 Agora que vimos as constru\u00e7\u00f5es de for paralelo e de redu\u00e7\u00e3o iremos aplic\u00e1-las no nosso exerc\u00edcio do c\u00e1lculo do pi. Por tr\u00e1s dos panos essas constru\u00e7\u00f5es fazem o mesmo trabalho dos c\u00f3digos que criamos anteriormente, por\u00e9m n\u00e3o precisamos escrever tanto c\u00f3digo. Example Modifique sua solu\u00e7\u00e3o para usar as constru\u00e7\u00f5es parallel for e reduce . Coloque seu resultado na fun\u00e7\u00e3o double pi_omp_for(long steps) . Seus resultados se mantiveram iguais? Se seu exerc\u00edcio deu certo voc\u00ea deve ter obtido tempos compar\u00e1veis com as melhores implementa\u00e7\u00f5es anteriores, por\u00e9m seu programa atual \u00e9 praticamente igual ao sequencial. Esta \u00e9 a principal vantagem de trabalhar com OpenMP: com poucas modifica\u00e7\u00f5es conseguimos transformar um c\u00f3digo sequencial em um programa paralelo. Paralelizando um programa j\u00e1 existente. \u00b6 A atividade hoje ser\u00e1 debugar um programa paralelo que deu errado! Curiosidade : fractais s\u00e3o estruturas matem\u00e1ticas que s\u00e3o definidas por sua auto-similaridade. Eles s\u00e3o \u00fateis para modelar objetos e fen\u00f4menos que possuem as mesmas caracter\u00edsticas em escalas completamente diferentes, como nuvens, montanhas e compress\u00e3o de arquivos . O arquivo mandel.cpp tem uma implementa\u00e7\u00e3o que calcula a \u00e1rea abaixo do Fractal de Mandelbrot . Foi feita uma tentativa pregui\u00e7osa de paraleliza\u00e7\u00e3o usando OpenMP que est\u00e1 dando resultados muito estranhos. Example Este c\u00f3digo tem problemas de compartilhamento indevido de dados. Voc\u00ea dever\u00e1 modificar o pragma que paraleliza o for para que n\u00e3o haja compartilhamento indevido de vari\u00e1veis. verificar se existe compartilhamento n\u00e3o intencional das vari\u00e1veis globais e arrumar, caso necess\u00e1rio. Voc\u00ea deve modificar o programa o m\u00ednimo poss\u00edvel Teoria - Efeitos colaterais \u00b6 Dizemos que quando uma fun\u00e7\u00e3o escreve/l\u00ea em vari\u00e1veis globais (ou static ) ela possui efeitos colaterais . Ou seja, ap\u00f3s rodar ela modifica o estado do programa. Em compara\u00e7\u00e3o, uma fun\u00e7\u00e3o que s\u00f3 depende dos valores passados nos argumentos e n\u00e3o escreve seu resultado (ou valores intermedi\u00e1rios) em vari\u00e1veis globais \u00e9 dita sem efeitos colaterais . Este tipo de fun\u00e7\u00e3o pode ser chamado por v\u00e1rias threads simult\u00e2neamente e \u00e9 uma boa pr\u00e1tica de programa\u00e7\u00e3o paralela criar fun\u00e7\u00f5es sem efeitos colaterais. Example Apesar do programa agora funcionar, os erros do exerc\u00edcio acima eram causados essencialmente por m\u00e1s pr\u00e1ticas de programa\u00e7\u00e3o. Reestruture o c\u00f3digo para que o resultado de suas fun\u00e7\u00f5es s\u00f3 dependa dos valores passados nos argumentos. Isto costuma implicar na convers\u00e3o de valores lidos/escritos em vari\u00e1veis globais para valores passados nos par\u00e2metros da fun\u00e7\u00e3o. Neste exerc\u00edcio voc\u00ea pode mudar o programa extensamente, desde que os resultados continuem os mesmos.","title":"07 - OpenMP: Constru\u00e7\u00f5es de alto n\u00edvel"},{"location":"aulas/07-openmp-for/#07-openmp-construcoes-de-alto-nivel","text":"Agora que vimos as constru\u00e7\u00f5es de for paralelo e de redu\u00e7\u00e3o iremos aplic\u00e1-las no nosso exerc\u00edcio do c\u00e1lculo do pi. Por tr\u00e1s dos panos essas constru\u00e7\u00f5es fazem o mesmo trabalho dos c\u00f3digos que criamos anteriormente, por\u00e9m n\u00e3o precisamos escrever tanto c\u00f3digo. Example Modifique sua solu\u00e7\u00e3o para usar as constru\u00e7\u00f5es parallel for e reduce . Coloque seu resultado na fun\u00e7\u00e3o double pi_omp_for(long steps) . Seus resultados se mantiveram iguais? Se seu exerc\u00edcio deu certo voc\u00ea deve ter obtido tempos compar\u00e1veis com as melhores implementa\u00e7\u00f5es anteriores, por\u00e9m seu programa atual \u00e9 praticamente igual ao sequencial. Esta \u00e9 a principal vantagem de trabalhar com OpenMP: com poucas modifica\u00e7\u00f5es conseguimos transformar um c\u00f3digo sequencial em um programa paralelo.","title":"07 - OpenMP: Constru\u00e7\u00f5es de alto n\u00edvel"},{"location":"aulas/07-openmp-for/#paralelizando-um-programa-ja-existente","text":"A atividade hoje ser\u00e1 debugar um programa paralelo que deu errado! Curiosidade : fractais s\u00e3o estruturas matem\u00e1ticas que s\u00e3o definidas por sua auto-similaridade. Eles s\u00e3o \u00fateis para modelar objetos e fen\u00f4menos que possuem as mesmas caracter\u00edsticas em escalas completamente diferentes, como nuvens, montanhas e compress\u00e3o de arquivos . O arquivo mandel.cpp tem uma implementa\u00e7\u00e3o que calcula a \u00e1rea abaixo do Fractal de Mandelbrot . Foi feita uma tentativa pregui\u00e7osa de paraleliza\u00e7\u00e3o usando OpenMP que est\u00e1 dando resultados muito estranhos. Example Este c\u00f3digo tem problemas de compartilhamento indevido de dados. Voc\u00ea dever\u00e1 modificar o pragma que paraleliza o for para que n\u00e3o haja compartilhamento indevido de vari\u00e1veis. verificar se existe compartilhamento n\u00e3o intencional das vari\u00e1veis globais e arrumar, caso necess\u00e1rio. Voc\u00ea deve modificar o programa o m\u00ednimo poss\u00edvel","title":"Paralelizando um programa j\u00e1 existente."},{"location":"aulas/07-openmp-for/#teoria-efeitos-colaterais","text":"Dizemos que quando uma fun\u00e7\u00e3o escreve/l\u00ea em vari\u00e1veis globais (ou static ) ela possui efeitos colaterais . Ou seja, ap\u00f3s rodar ela modifica o estado do programa. Em compara\u00e7\u00e3o, uma fun\u00e7\u00e3o que s\u00f3 depende dos valores passados nos argumentos e n\u00e3o escreve seu resultado (ou valores intermedi\u00e1rios) em vari\u00e1veis globais \u00e9 dita sem efeitos colaterais . Este tipo de fun\u00e7\u00e3o pode ser chamado por v\u00e1rias threads simult\u00e2neamente e \u00e9 uma boa pr\u00e1tica de programa\u00e7\u00e3o paralela criar fun\u00e7\u00f5es sem efeitos colaterais. Example Apesar do programa agora funcionar, os erros do exerc\u00edcio acima eram causados essencialmente por m\u00e1s pr\u00e1ticas de programa\u00e7\u00e3o. Reestruture o c\u00f3digo para que o resultado de suas fun\u00e7\u00f5es s\u00f3 dependa dos valores passados nos argumentos. Isto costuma implicar na convers\u00e3o de valores lidos/escritos em vari\u00e1veis globais para valores passados nos par\u00e2metros da fun\u00e7\u00e3o. Neste exerc\u00edcio voc\u00ea pode mudar o programa extensamente, desde que os resultados continuem os mesmos.","title":"Teoria - Efeitos colaterais"},{"location":"aulas/08-efeitos-colaterais/","text":"08 - Efeitos colaterais \u00b6 Escrever c\u00f3digo sem efeitos colaterais pode render ganhos de desempenho significativos ao paralelizar programas. Conceito Uma fun\u00e7\u00e3o tem efeitos colaterais quando ela modifica dados que n\u00e3o s\u00e3o nem passados via argumentos nem retornados pela fun\u00e7\u00e3o. S\u00e3o exemplos desse tipo de dados: vari\u00e1veis globais vari\u00e1veis alocadas via malloc vari\u00e1veis apontadas por ponteiros Uma fun\u00e7\u00e3o sem efeitos colaterais recebe todos os seus argumentos por c\u00f3pia, os processa e devolve seu resultado exclusivamente via retorno da fun\u00e7\u00e3o. Ou seja, todas as outras vari\u00e1veis do programa mant\u00e9m o mesmo valor que tinham antes da chamada dessa fun\u00e7\u00e3o. Pela defini\u00e7\u00e3o acima, notamos que uma fun\u00e7\u00e3o sem efeitos colaterais pode ser chamada por v\u00e1rias threads ao mesmo tempo. Claramente isto \u00e9 uma vantagem, j\u00e1 que isto pode facilitar muito a paraleliza\u00e7\u00e3o de c\u00f3digo. Parte 0: analizando o c\u00f3digo existente \u00b6 Nesta parte do roteiro iremos analisar o c\u00f3digo exemplo, testar uma paraleliza\u00e7\u00e3o ing\u00eanua e identificar seus poss\u00edveis problemas de paraleliza\u00e7\u00e3o. Question Considerando somente o arquivo pi_mc.c , existe c\u00f3digo com efeitos colaterais? Example Fa\u00e7a uma paraleliza\u00e7\u00e3o ing\u00eanua deste c\u00f3digo. Example Teste a paraleliza\u00e7\u00e3o ing\u00eanua do exerc\u00edcio anterior. Ela retorna os mesmos resultados em todas execu\u00e7\u00f5es? Se n\u00e3o, comente por que isto \u00e9 um problema. Dado que n\u00e3o encontramos problemas no arquivo pi_mc.c , vamos olhar ent\u00e3o os arquivos random.c/h . Question Existe c\u00f3digo com efeitos colaterais? Liste as fun\u00e7\u00f5es encontradas. Question Voltando para pi_mc.c , onde s\u00e3o chamadas as fun\u00e7\u00f5es identificadas acima? Question Agora que voc\u00ea est\u00e1 familiarizado com todo o c\u00f3digo, explique por que os resultados s\u00e3o diferentes quando rodamos o c\u00f3digo ingenuamente paralelo. S\u00f3 prossiga ap\u00f3s validar as respostas do item anterior com o professor ou com um colega que j\u00e1 tenha finalizado esta parte. Parte 1: exclus\u00e3o m\u00fatua \u00b6 Identificamos na parte anterior que a fun\u00e7\u00e3o drandom possui efeitos colaterais e estes efeitos colaterais est\u00e3o atrapalhando a paraleliza\u00e7\u00e3o do c\u00f3digo. Esta implementa\u00e7\u00e3o \u00e9 parecida com as fun\u00e7\u00f5es do cabe\u00e7alho <random> : temos um estado do gerador de n\u00fameros que \u00e9 passado para toda fun\u00e7\u00e3o que faz sorteios. Neste caso, o resultado do pr\u00f3ximo n\u00famero sorteado depende dos valores globais MULTIPLIER , ADDEND , PMOD e da vari\u00e1vel est\u00e1tica random_last . Example Modifique o c\u00f3digo para que ele use as fun\u00e7\u00f5es de gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios usando <random> . Salve em pi_mc_random.cpp . Na aula 06 usamos omp critical para criar se\u00e7\u00f5es de exclus\u00e3o m\u00fatua em que somente uma das threads rode por vez. No nosso caso o problema ocorre com a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios: ao gerar um n\u00famero o estado interno do gerador se modifica. Logo, tem um problema de acessos concorrentes a mesma vari\u00e1vel. Question Partindo do c\u00f3digo sequencial, quais linhas precisariam ser protegidas de acessos concorrentes? Example Utilize omp for e omp critical para paralelizar o c\u00f3digo em pi_mc_random.cpp . Question Avalie seu c\u00f3digo em termos de desempenho obtido e facilidade de programa\u00e7\u00e3o Parte 2: paraleliza\u00e7\u00e3o das dist\u00e2ncias \u00b6 Na parte anterior eliminamos acessos concorrentes ao gerador de n\u00fameros aleat\u00f3rios. Isso seria equivalente a fazer todos os sorteios antes e depois fazer os c\u00e1lculos das dist\u00e2ncias. Ou seja, os c\u00e1lculos de dist\u00e2ncia s\u00e3o independentes desde que os sorteios aleat\u00f3rios j\u00e1 tenham sido feitos. Example Modifique pi_mc_random.cpp para que o sorteio dos pontos seja feito em um vetor antes do for que faz os c\u00e1lculos de dist\u00e2ncias. Question \u00c9 poss\u00edvel paralelizar o for que faz o sorteio dos n\u00fameros? E o que faz o c\u00e1lculo das dist\u00e2ncias? Example Com base em suas respostas do item acima, paralize o que for poss\u00edvel e salve em um arquivo pi_mc_par1.cpp Question Houve ganho de desempenho? Compare com o programa original. Esta estrat\u00e9gia \u00e9 muito comum em casos em que a tarefa de interesse pode ser decomposta em uma parte inerentemente sequencial e uma que pode ser paralelizada mas que depende dos resultados da parte sequencial. Se a parte paraleliz\u00e1vel for custosa essa estrat\u00e9gia pode trazer ganhos mesmo que o programa n\u00e3o seja inteiramente paraleliz\u00e1vel. Parte 3: partes independentes \u00b6 A segunda estrat\u00e9gia que usaremos \u00e9 criar um gerador de n\u00fameros aleat\u00f3rios para cada thread. Ou seja, cada thread precisar\u00e1: criar um gerador de n\u00fameros aleat\u00f3rios pr\u00f3prio acumular os resultados na mesma vari\u00e1vel de somar pontos. Note que esta estrat\u00e9gia n\u00e3o \u00e9 equivalente ao programa original: cada thread est\u00e1 seguindo uma sequ\u00eancia diferente de n\u00fameros aleat\u00f3rios. Example Reorganize seu c\u00f3digo (partindo de pi_mc_random.cpp ) para que cada thread crie seu pr\u00f3prio gerador de n\u00fameros aleat\u00f3rios e fa\u00e7a \u00bc das itera\u00e7\u00f5es originais. Salve seu trabalho em pi_mc_par2.c Question Compare o desempenho com o programa original. Parte 4 - compara\u00e7\u00e3o de desempenho final \u00b6 Compare o desempenho das duas abordagens de paraleliza\u00e7\u00e3o. Question Qual \u00e9 mais r\u00e1pida? Question Qual \u00e9 mais f\u00e1cil de ser entendida?","title":"08 - Efeitos colaterais"},{"location":"aulas/08-efeitos-colaterais/#08-efeitos-colaterais","text":"Escrever c\u00f3digo sem efeitos colaterais pode render ganhos de desempenho significativos ao paralelizar programas. Conceito Uma fun\u00e7\u00e3o tem efeitos colaterais quando ela modifica dados que n\u00e3o s\u00e3o nem passados via argumentos nem retornados pela fun\u00e7\u00e3o. S\u00e3o exemplos desse tipo de dados: vari\u00e1veis globais vari\u00e1veis alocadas via malloc vari\u00e1veis apontadas por ponteiros Uma fun\u00e7\u00e3o sem efeitos colaterais recebe todos os seus argumentos por c\u00f3pia, os processa e devolve seu resultado exclusivamente via retorno da fun\u00e7\u00e3o. Ou seja, todas as outras vari\u00e1veis do programa mant\u00e9m o mesmo valor que tinham antes da chamada dessa fun\u00e7\u00e3o. Pela defini\u00e7\u00e3o acima, notamos que uma fun\u00e7\u00e3o sem efeitos colaterais pode ser chamada por v\u00e1rias threads ao mesmo tempo. Claramente isto \u00e9 uma vantagem, j\u00e1 que isto pode facilitar muito a paraleliza\u00e7\u00e3o de c\u00f3digo.","title":"08 - Efeitos colaterais"},{"location":"aulas/08-efeitos-colaterais/#parte-0-analizando-o-codigo-existente","text":"Nesta parte do roteiro iremos analisar o c\u00f3digo exemplo, testar uma paraleliza\u00e7\u00e3o ing\u00eanua e identificar seus poss\u00edveis problemas de paraleliza\u00e7\u00e3o. Question Considerando somente o arquivo pi_mc.c , existe c\u00f3digo com efeitos colaterais? Example Fa\u00e7a uma paraleliza\u00e7\u00e3o ing\u00eanua deste c\u00f3digo. Example Teste a paraleliza\u00e7\u00e3o ing\u00eanua do exerc\u00edcio anterior. Ela retorna os mesmos resultados em todas execu\u00e7\u00f5es? Se n\u00e3o, comente por que isto \u00e9 um problema. Dado que n\u00e3o encontramos problemas no arquivo pi_mc.c , vamos olhar ent\u00e3o os arquivos random.c/h . Question Existe c\u00f3digo com efeitos colaterais? Liste as fun\u00e7\u00f5es encontradas. Question Voltando para pi_mc.c , onde s\u00e3o chamadas as fun\u00e7\u00f5es identificadas acima? Question Agora que voc\u00ea est\u00e1 familiarizado com todo o c\u00f3digo, explique por que os resultados s\u00e3o diferentes quando rodamos o c\u00f3digo ingenuamente paralelo. S\u00f3 prossiga ap\u00f3s validar as respostas do item anterior com o professor ou com um colega que j\u00e1 tenha finalizado esta parte.","title":"Parte 0: analizando o c\u00f3digo existente"},{"location":"aulas/08-efeitos-colaterais/#parte-1-exclusao-mutua","text":"Identificamos na parte anterior que a fun\u00e7\u00e3o drandom possui efeitos colaterais e estes efeitos colaterais est\u00e3o atrapalhando a paraleliza\u00e7\u00e3o do c\u00f3digo. Esta implementa\u00e7\u00e3o \u00e9 parecida com as fun\u00e7\u00f5es do cabe\u00e7alho <random> : temos um estado do gerador de n\u00fameros que \u00e9 passado para toda fun\u00e7\u00e3o que faz sorteios. Neste caso, o resultado do pr\u00f3ximo n\u00famero sorteado depende dos valores globais MULTIPLIER , ADDEND , PMOD e da vari\u00e1vel est\u00e1tica random_last . Example Modifique o c\u00f3digo para que ele use as fun\u00e7\u00f5es de gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios usando <random> . Salve em pi_mc_random.cpp . Na aula 06 usamos omp critical para criar se\u00e7\u00f5es de exclus\u00e3o m\u00fatua em que somente uma das threads rode por vez. No nosso caso o problema ocorre com a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios: ao gerar um n\u00famero o estado interno do gerador se modifica. Logo, tem um problema de acessos concorrentes a mesma vari\u00e1vel. Question Partindo do c\u00f3digo sequencial, quais linhas precisariam ser protegidas de acessos concorrentes? Example Utilize omp for e omp critical para paralelizar o c\u00f3digo em pi_mc_random.cpp . Question Avalie seu c\u00f3digo em termos de desempenho obtido e facilidade de programa\u00e7\u00e3o","title":"Parte 1: exclus\u00e3o m\u00fatua"},{"location":"aulas/08-efeitos-colaterais/#parte-2-paralelizacao-das-distancias","text":"Na parte anterior eliminamos acessos concorrentes ao gerador de n\u00fameros aleat\u00f3rios. Isso seria equivalente a fazer todos os sorteios antes e depois fazer os c\u00e1lculos das dist\u00e2ncias. Ou seja, os c\u00e1lculos de dist\u00e2ncia s\u00e3o independentes desde que os sorteios aleat\u00f3rios j\u00e1 tenham sido feitos. Example Modifique pi_mc_random.cpp para que o sorteio dos pontos seja feito em um vetor antes do for que faz os c\u00e1lculos de dist\u00e2ncias. Question \u00c9 poss\u00edvel paralelizar o for que faz o sorteio dos n\u00fameros? E o que faz o c\u00e1lculo das dist\u00e2ncias? Example Com base em suas respostas do item acima, paralize o que for poss\u00edvel e salve em um arquivo pi_mc_par1.cpp Question Houve ganho de desempenho? Compare com o programa original. Esta estrat\u00e9gia \u00e9 muito comum em casos em que a tarefa de interesse pode ser decomposta em uma parte inerentemente sequencial e uma que pode ser paralelizada mas que depende dos resultados da parte sequencial. Se a parte paraleliz\u00e1vel for custosa essa estrat\u00e9gia pode trazer ganhos mesmo que o programa n\u00e3o seja inteiramente paraleliz\u00e1vel.","title":"Parte 2: paraleliza\u00e7\u00e3o das dist\u00e2ncias"},{"location":"aulas/08-efeitos-colaterais/#parte-3-partes-independentes","text":"A segunda estrat\u00e9gia que usaremos \u00e9 criar um gerador de n\u00fameros aleat\u00f3rios para cada thread. Ou seja, cada thread precisar\u00e1: criar um gerador de n\u00fameros aleat\u00f3rios pr\u00f3prio acumular os resultados na mesma vari\u00e1vel de somar pontos. Note que esta estrat\u00e9gia n\u00e3o \u00e9 equivalente ao programa original: cada thread est\u00e1 seguindo uma sequ\u00eancia diferente de n\u00fameros aleat\u00f3rios. Example Reorganize seu c\u00f3digo (partindo de pi_mc_random.cpp ) para que cada thread crie seu pr\u00f3prio gerador de n\u00fameros aleat\u00f3rios e fa\u00e7a \u00bc das itera\u00e7\u00f5es originais. Salve seu trabalho em pi_mc_par2.c Question Compare o desempenho com o programa original.","title":"Parte 3: partes independentes"},{"location":"aulas/08-efeitos-colaterais/#parte-4-comparacao-de-desempenho-final","text":"Compare o desempenho das duas abordagens de paraleliza\u00e7\u00e3o. Question Qual \u00e9 mais r\u00e1pida? Question Qual \u00e9 mais f\u00e1cil de ser entendida?","title":"Parte 4 - compara\u00e7\u00e3o de desempenho final"},{"location":"projetos/","text":"\u00cdndice de projetos \u00b6 A disciplina \u00e9 baseada em 4 projetos organizados em 5 entregas. Projeto 0 \u00b6 O projeto 0 consiste em atividades incrementais feitas em sala nas aula 01-05. Seu objetivo \u00e9 escrever programas b\u00e1sicos em C++; praticar o uso de conteiners da STL; cria\u00e7\u00e3o de projetos CMake; introduzir o processo de benchmarking. As atividades est\u00e3o descritas nas aulas 1-5 e o projeto deve ser entregue at\u00e9 04/03 . Sua entrega dever\u00e1 atender a todos os requisitos de entrega Projetos 1 a 3 \u00b6 Nestes tr\u00eas projetos resolveremos o problema da Aloca\u00e7\u00e3o de alunos para o PFE usando diferentes t\u00e9cnicas de computa\u00e7\u00e3o paralela. Projeto 1: programa\u00e7\u00e3o multi-core Parte 1: implementa\u00e7\u00e3o sequencial (31/03) Parte 2: multi-core (14/04) Projeto 2: GPGPU Projeto 3: computa\u00e7\u00e3o distribu\u00edda","title":"\u00cdndice"},{"location":"projetos/#indice-de-projetos","text":"A disciplina \u00e9 baseada em 4 projetos organizados em 5 entregas.","title":"\u00cdndice de projetos"},{"location":"projetos/#projeto-0","text":"O projeto 0 consiste em atividades incrementais feitas em sala nas aula 01-05. Seu objetivo \u00e9 escrever programas b\u00e1sicos em C++; praticar o uso de conteiners da STL; cria\u00e7\u00e3o de projetos CMake; introduzir o processo de benchmarking. As atividades est\u00e3o descritas nas aulas 1-5 e o projeto deve ser entregue at\u00e9 04/03 . Sua entrega dever\u00e1 atender a todos os requisitos de entrega","title":"Projeto 0"},{"location":"projetos/#projetos-1-a-3","text":"Nestes tr\u00eas projetos resolveremos o problema da Aloca\u00e7\u00e3o de alunos para o PFE usando diferentes t\u00e9cnicas de computa\u00e7\u00e3o paralela. Projeto 1: programa\u00e7\u00e3o multi-core Parte 1: implementa\u00e7\u00e3o sequencial (31/03) Parte 2: multi-core (14/04) Projeto 2: GPGPU Projeto 3: computa\u00e7\u00e3o distribu\u00edda","title":"Projetos 1 a 3"},{"location":"projetos/checklist/","text":"Requisitos b\u00e1sicos de projeto \u00b6 Os seguintes pontos s\u00e3o obrigat\u00f3rios para todos projetos entregues na disciplina. Caso eles n\u00e3o sejam satisfeitos a nota final ser\u00e1 D . Se sua nota for maior que C e alguns desses itens for o \u00fanico problema da entrega voc\u00ea pode reentregar sem desconto de nota. Warning A condi\u00e7\u00e3o acima n\u00e3o vale para o projeto 0 - revis\u00e3o de C++ , j\u00e1 que grande parte dele \u00e9 realizar as tarefas abaixo. CMakeLists.txt gera um execut\u00e1vel por m\u00e9todo testado Relat\u00f3rio feito em Jupyter Notebook ou PWeave. Seu relat\u00f3rio deve conter as seguintes se\u00e7\u00f5es: Descri\u00e7\u00e3o do problema tratado Descri\u00e7\u00e3o dos testes feitos (tamanho de entradas, quantas execu\u00e7\u00f5es s\u00e3o feitas, como mediu tempo, infra usada) Organiza\u00e7\u00e3o em alto n\u00edvel de seu projeto. Vers\u00e3o j\u00e1 rodada do relat\u00f3rio exportada para PDF README.txt explicando como rodar seus testes (pode estar no relat\u00f3rio). Conjunto de testes automatizados (via script Python ou direto no relat\u00f3rio) Respeitar os formatos de entrada e sa\u00edda definidos nos enunciados. Seu programa dever\u00e1 retornar sempre o mesmo resultado. Os tempos ser\u00e3o ligeiramente diferentes em cada execu\u00e7\u00e3o, mas o resultado final dever\u00e1 ser sempre o mesmo.","title":"Requisitos b\u00e1sicos de projeto"},{"location":"projetos/checklist/#requisitos-basicos-de-projeto","text":"Os seguintes pontos s\u00e3o obrigat\u00f3rios para todos projetos entregues na disciplina. Caso eles n\u00e3o sejam satisfeitos a nota final ser\u00e1 D . Se sua nota for maior que C e alguns desses itens for o \u00fanico problema da entrega voc\u00ea pode reentregar sem desconto de nota. Warning A condi\u00e7\u00e3o acima n\u00e3o vale para o projeto 0 - revis\u00e3o de C++ , j\u00e1 que grande parte dele \u00e9 realizar as tarefas abaixo. CMakeLists.txt gera um execut\u00e1vel por m\u00e9todo testado Relat\u00f3rio feito em Jupyter Notebook ou PWeave. Seu relat\u00f3rio deve conter as seguintes se\u00e7\u00f5es: Descri\u00e7\u00e3o do problema tratado Descri\u00e7\u00e3o dos testes feitos (tamanho de entradas, quantas execu\u00e7\u00f5es s\u00e3o feitas, como mediu tempo, infra usada) Organiza\u00e7\u00e3o em alto n\u00edvel de seu projeto. Vers\u00e3o j\u00e1 rodada do relat\u00f3rio exportada para PDF README.txt explicando como rodar seus testes (pode estar no relat\u00f3rio). Conjunto de testes automatizados (via script Python ou direto no relat\u00f3rio) Respeitar os formatos de entrada e sa\u00edda definidos nos enunciados. Seu programa dever\u00e1 retornar sempre o mesmo resultado. Os tempos ser\u00e3o ligeiramente diferentes em cada execu\u00e7\u00e3o, mas o resultado final dever\u00e1 ser sempre o mesmo.","title":"Requisitos b\u00e1sicos de projeto"},{"location":"projetos/projeto-multi-core/","text":"Multi-core: C++ e OpenMP \u00b6 O primeiro projeto consiste em implementar uma solu\u00e7\u00e3o multi-core para o problema da Aloca\u00e7\u00e3o de alunos do PFE . Para facilitar sua ele ser\u00e1 dividido em duas partes. A primeira parte focar\u00e1 em criar uma solu\u00e7\u00e3o que resolve este problema este C++ e compar\u00e1-la com uma solu\u00e7\u00e3o inocente em Python. Isto inclui estudar m\u00e9todos de resolu\u00e7\u00e3o do problema e implement\u00e1-los em C++. A segunda parte tratar\u00e1 da paraleliza\u00e7\u00e3o destes m\u00e9todos usando as t\u00e9cnicas mostradas em sala de aula. O programa dever\u00e1 ser escrito usando OpenMP e dever\u00e1 escalar o mais naturalmente poss\u00edvel conforme o n\u00famero de cores aumenta. Parte 1: estrat\u00e9gias de resolu\u00e7\u00e3o \u00b6 O arquivo solucao-ingenua.py cont\u00e9m uma solu\u00e7\u00e3o simplista escrita em Python. Este programa sempre encontra a melhor solu\u00e7\u00e3o, mas \u00e9 extremamente ing\u00eanuo . Por isso, ele tamb\u00e9m \u00e9 extremamente lento . Implementa\u00e7\u00e3o em C++ : Nosso primeiro passo ser\u00e1 implementar esse mesmo programa em C++. O objetivo desta parte ser\u00e1 implementar solu\u00e7\u00f5es para o problema sem n\u00f3s preocuparmos com paralelismo e o primeiro passo para isso \u00e9 implementar o algoritmo que est\u00e1 em Python em C++. Busca local : A estrat\u00e9gia de busca local visa encontrar boas solu\u00e7\u00f5es em um processo de melhora iterativa. A partir de uma solu\u00e7\u00e3o inicial (que pode ser aleat\u00f3ria), tentamos aplicar uma heur\u00edstica (truque) que pode melhorar a solu\u00e7\u00e3o (mas nunca piorar). Note que isto somente garante que a solu\u00e7\u00e3o ir\u00e1 melhorar iterativamente, por\u00e9m n\u00e3o garante que eventualmente chegaremos na melhor solu\u00e7\u00e3o poss\u00edvel. Al\u00e9m dissto, a solu\u00e7\u00e3o encontrada muda conforme a solu\u00e7\u00e3o inicial nem todas as solu\u00e7\u00f5es s\u00e3o poss\u00edveis de serem encontradas. Uma boa heur\u00edstica geralmente \u00e9 baseada em alguma caracter\u00edstica da solu\u00e7\u00e3o \u00f3tima. Para este problema usaremos a seguinte propriedade n\u00e3o existe nenhuma dupla de alunos que, se for trocada de projeto, melhora a satisfa\u00e7\u00e3o global. Claramente se a solu\u00e7\u00e3o \u00e9 a melhor poss\u00edvel ent\u00e3o isto n\u00e3o pode acontecer. Nosso algoritmo ser\u00e1 escolha uma atribui\u00e7\u00e3o aluno-projeto v\u00e1lida aleatoriamente verifique se existe um par de alunos cuja troca de projeto melhore a satisfa\u00e7\u00e3o global se existir fa\u00e7a a troca e repita o teste acima se n\u00e3o existir retorne a solu\u00e7\u00e3o atual Ao repertirmos este algoritmo conseguimos solu\u00e7\u00f5es razo\u00e1veis muito rapidamente. Ele \u00e9 uma busca local pois seu resultado depende de qual solu\u00e7\u00e3o inicial foi usada. Nem toda solu\u00e7\u00e3o inicial resultar\u00e1 no \u00f3timo global no fim do processo. Branch and Bound : Nosso algoritmo simpl\u00f3rio no item anterior faz v\u00e1rias escolhas recursivas ( branches ) e atualiza a melhor solu\u00e7\u00e3o encontrada at\u00e9 o momento. Imagine a seguinte situa\u00e7\u00e3o: em um certo momento temos uma solu\u00e7\u00e3o com valor 200 200 ainda faltam 3 alunos para serem alocados. a melhor solu\u00e7\u00e3o j\u00e1 encontrada tem valor 300 300 . Note que, mesmo se alocarmos os tr\u00eas alunos para sua primeira op\u00e7\u00e3o ficar\u00edamos com uma solu\u00e7\u00e3o de valor 275 < 300 275 < 300 . Ou seja, n\u00e3o precisamos tentar aloc\u00e1-los para projetos, pois mesmo que fa\u00e7amos o melhor poss\u00edvel ainda n\u00e3o conseguiremos superar a melhor solu\u00e7\u00e3o atual! Um bound \u00e9 uma estimativa otimista para o valor final de uma solu\u00e7\u00e3o parcial. Ou seja, dado que falta ainda alocar X alunos e tenho uma solu\u00e7\u00e3o de valor Y , uma estimativa otimista seria supor que todos ser\u00e3o alocados em sua primeira op\u00e7\u00e3o (solu\u00e7\u00e3o final com valor < Y + 25X < Y + 25X ). Warning Um bound \u00e9 uma estimativa otimista . Ou seja, pode n\u00e3o existir uma solu\u00e7\u00e3o com este valor! Um algoritmo branch and bound leva em conta essas estimativas em seu funcionamento: se o bound da solu\u00e7\u00e3o atual for pior que a solu\u00e7\u00e3o \u00f3tima atual, retorna continue a recurs\u00e3o caso contr\u00e1rio Esta t\u00e9cnica evita que nossa recurs\u00e3o entre em branches que n\u00e3o tem chance nenhuma de descobrir a melhor solu\u00e7\u00e3o (pois eles j\u00e1 s\u00e3o piores que uma solu\u00e7\u00e3o v\u00e1lida conhecida). Heur\u00edsticas de busca : O algoritmo recursivo implementado em Python testa todas as possibilidades de maneira bastante inocente. Ele n\u00e3o leva em conta, por exemplo, as prefer\u00eancia dos alunos ou o fato de alocar um aluno em uma op\u00e7\u00e3o com satisfa\u00e7\u00e3o 0 n\u00e3o mudar o valor global da solu\u00e7\u00e3o. Este item envolve modificar a ordem que as solu\u00e7\u00f5es s\u00e3o analisadas de maneira a tentar encontrar primeiro as solu\u00e7\u00f5es de maior satisfa\u00e7\u00e3o global. Combinada com o item anterior, est\u00e1 estrat\u00e9gia pode diminuir consideravelmente o tempo de execu\u00e7\u00e3o. Ser\u00e1 obrigat\u00f3rio implementar este item em cima do branch and bound. Parte 2: Paralelismo \u00b6 Cada item da parte anterior dever\u00e1 ser paralelizado usando OpenMP. Isto dever\u00e1 ser feito da maneira mais escal\u00e1vel poss\u00edvel: o tempo de execu\u00e7\u00e3o do programa dever\u00e1 diminuir conforme o n\u00famero de cores aumenta. Este item \u00e9 o principal da entrega, mas ele se apoia inteiramente em cima dos itens da primeira entrega. Warning Os projetos da disciplina consideram que n\u00e3o \u00e9 razo\u00e1vel tentar paralelizar um problema que voc\u00eas n\u00e3o sejam capazes de resolver sequencialmente. Avalia\u00e7\u00e3o \u00b6 A entrega ser\u00e1 dividida em duas partes: entrega do algoritmo sequencial em C++ , comparando-o com a implementa\u00e7\u00e3o em Python (30/03) entrega final (antes da prova) Na primeira entrega s\u00e3o esperados os seguintes itens: Requisitos b\u00e1sicos cumpridos Relat\u00f3rio comparando desempenho Python vs C++ Na segunda entrega seu relat\u00f3rio dever\u00e1 estar completo, levando em conta tamb\u00e9m as paraleliza\u00e7\u00f5es feitas na Parte 2. A rubrica de avalia\u00e7\u00e3o ser\u00e1 publicada logo ap\u00f3s a entrega sequencial. Extras \u00b6 Teremos uma competi\u00e7\u00e3o de desempenho no Monstr\u00e3o. Mais detalhes vir\u00e3o ap\u00f3s 20/03.","title":"Multi-core: C++ e OpenMP"},{"location":"projetos/projeto-multi-core/#multi-core-c-e-openmp","text":"O primeiro projeto consiste em implementar uma solu\u00e7\u00e3o multi-core para o problema da Aloca\u00e7\u00e3o de alunos do PFE . Para facilitar sua ele ser\u00e1 dividido em duas partes. A primeira parte focar\u00e1 em criar uma solu\u00e7\u00e3o que resolve este problema este C++ e compar\u00e1-la com uma solu\u00e7\u00e3o inocente em Python. Isto inclui estudar m\u00e9todos de resolu\u00e7\u00e3o do problema e implement\u00e1-los em C++. A segunda parte tratar\u00e1 da paraleliza\u00e7\u00e3o destes m\u00e9todos usando as t\u00e9cnicas mostradas em sala de aula. O programa dever\u00e1 ser escrito usando OpenMP e dever\u00e1 escalar o mais naturalmente poss\u00edvel conforme o n\u00famero de cores aumenta.","title":"Multi-core: C++ e OpenMP"},{"location":"projetos/projeto-multi-core/#parte-1-estrategias-de-resolucao","text":"O arquivo solucao-ingenua.py cont\u00e9m uma solu\u00e7\u00e3o simplista escrita em Python. Este programa sempre encontra a melhor solu\u00e7\u00e3o, mas \u00e9 extremamente ing\u00eanuo . Por isso, ele tamb\u00e9m \u00e9 extremamente lento . Implementa\u00e7\u00e3o em C++ : Nosso primeiro passo ser\u00e1 implementar esse mesmo programa em C++. O objetivo desta parte ser\u00e1 implementar solu\u00e7\u00f5es para o problema sem n\u00f3s preocuparmos com paralelismo e o primeiro passo para isso \u00e9 implementar o algoritmo que est\u00e1 em Python em C++. Busca local : A estrat\u00e9gia de busca local visa encontrar boas solu\u00e7\u00f5es em um processo de melhora iterativa. A partir de uma solu\u00e7\u00e3o inicial (que pode ser aleat\u00f3ria), tentamos aplicar uma heur\u00edstica (truque) que pode melhorar a solu\u00e7\u00e3o (mas nunca piorar). Note que isto somente garante que a solu\u00e7\u00e3o ir\u00e1 melhorar iterativamente, por\u00e9m n\u00e3o garante que eventualmente chegaremos na melhor solu\u00e7\u00e3o poss\u00edvel. Al\u00e9m dissto, a solu\u00e7\u00e3o encontrada muda conforme a solu\u00e7\u00e3o inicial nem todas as solu\u00e7\u00f5es s\u00e3o poss\u00edveis de serem encontradas. Uma boa heur\u00edstica geralmente \u00e9 baseada em alguma caracter\u00edstica da solu\u00e7\u00e3o \u00f3tima. Para este problema usaremos a seguinte propriedade n\u00e3o existe nenhuma dupla de alunos que, se for trocada de projeto, melhora a satisfa\u00e7\u00e3o global. Claramente se a solu\u00e7\u00e3o \u00e9 a melhor poss\u00edvel ent\u00e3o isto n\u00e3o pode acontecer. Nosso algoritmo ser\u00e1 escolha uma atribui\u00e7\u00e3o aluno-projeto v\u00e1lida aleatoriamente verifique se existe um par de alunos cuja troca de projeto melhore a satisfa\u00e7\u00e3o global se existir fa\u00e7a a troca e repita o teste acima se n\u00e3o existir retorne a solu\u00e7\u00e3o atual Ao repertirmos este algoritmo conseguimos solu\u00e7\u00f5es razo\u00e1veis muito rapidamente. Ele \u00e9 uma busca local pois seu resultado depende de qual solu\u00e7\u00e3o inicial foi usada. Nem toda solu\u00e7\u00e3o inicial resultar\u00e1 no \u00f3timo global no fim do processo. Branch and Bound : Nosso algoritmo simpl\u00f3rio no item anterior faz v\u00e1rias escolhas recursivas ( branches ) e atualiza a melhor solu\u00e7\u00e3o encontrada at\u00e9 o momento. Imagine a seguinte situa\u00e7\u00e3o: em um certo momento temos uma solu\u00e7\u00e3o com valor 200 200 ainda faltam 3 alunos para serem alocados. a melhor solu\u00e7\u00e3o j\u00e1 encontrada tem valor 300 300 . Note que, mesmo se alocarmos os tr\u00eas alunos para sua primeira op\u00e7\u00e3o ficar\u00edamos com uma solu\u00e7\u00e3o de valor 275 < 300 275 < 300 . Ou seja, n\u00e3o precisamos tentar aloc\u00e1-los para projetos, pois mesmo que fa\u00e7amos o melhor poss\u00edvel ainda n\u00e3o conseguiremos superar a melhor solu\u00e7\u00e3o atual! Um bound \u00e9 uma estimativa otimista para o valor final de uma solu\u00e7\u00e3o parcial. Ou seja, dado que falta ainda alocar X alunos e tenho uma solu\u00e7\u00e3o de valor Y , uma estimativa otimista seria supor que todos ser\u00e3o alocados em sua primeira op\u00e7\u00e3o (solu\u00e7\u00e3o final com valor < Y + 25X < Y + 25X ). Warning Um bound \u00e9 uma estimativa otimista . Ou seja, pode n\u00e3o existir uma solu\u00e7\u00e3o com este valor! Um algoritmo branch and bound leva em conta essas estimativas em seu funcionamento: se o bound da solu\u00e7\u00e3o atual for pior que a solu\u00e7\u00e3o \u00f3tima atual, retorna continue a recurs\u00e3o caso contr\u00e1rio Esta t\u00e9cnica evita que nossa recurs\u00e3o entre em branches que n\u00e3o tem chance nenhuma de descobrir a melhor solu\u00e7\u00e3o (pois eles j\u00e1 s\u00e3o piores que uma solu\u00e7\u00e3o v\u00e1lida conhecida). Heur\u00edsticas de busca : O algoritmo recursivo implementado em Python testa todas as possibilidades de maneira bastante inocente. Ele n\u00e3o leva em conta, por exemplo, as prefer\u00eancia dos alunos ou o fato de alocar um aluno em uma op\u00e7\u00e3o com satisfa\u00e7\u00e3o 0 n\u00e3o mudar o valor global da solu\u00e7\u00e3o. Este item envolve modificar a ordem que as solu\u00e7\u00f5es s\u00e3o analisadas de maneira a tentar encontrar primeiro as solu\u00e7\u00f5es de maior satisfa\u00e7\u00e3o global. Combinada com o item anterior, est\u00e1 estrat\u00e9gia pode diminuir consideravelmente o tempo de execu\u00e7\u00e3o. Ser\u00e1 obrigat\u00f3rio implementar este item em cima do branch and bound.","title":"Parte 1: estrat\u00e9gias de resolu\u00e7\u00e3o"},{"location":"projetos/projeto-multi-core/#parte-2-paralelismo","text":"Cada item da parte anterior dever\u00e1 ser paralelizado usando OpenMP. Isto dever\u00e1 ser feito da maneira mais escal\u00e1vel poss\u00edvel: o tempo de execu\u00e7\u00e3o do programa dever\u00e1 diminuir conforme o n\u00famero de cores aumenta. Este item \u00e9 o principal da entrega, mas ele se apoia inteiramente em cima dos itens da primeira entrega. Warning Os projetos da disciplina consideram que n\u00e3o \u00e9 razo\u00e1vel tentar paralelizar um problema que voc\u00eas n\u00e3o sejam capazes de resolver sequencialmente.","title":"Parte 2: Paralelismo"},{"location":"projetos/projeto-multi-core/#avaliacao","text":"A entrega ser\u00e1 dividida em duas partes: entrega do algoritmo sequencial em C++ , comparando-o com a implementa\u00e7\u00e3o em Python (30/03) entrega final (antes da prova) Na primeira entrega s\u00e3o esperados os seguintes itens: Requisitos b\u00e1sicos cumpridos Relat\u00f3rio comparando desempenho Python vs C++ Na segunda entrega seu relat\u00f3rio dever\u00e1 estar completo, levando em conta tamb\u00e9m as paraleliza\u00e7\u00f5es feitas na Parte 2. A rubrica de avalia\u00e7\u00e3o ser\u00e1 publicada logo ap\u00f3s a entrega sequencial.","title":"Avalia\u00e7\u00e3o"},{"location":"projetos/projeto-multi-core/#extras","text":"Teremos uma competi\u00e7\u00e3o de desempenho no Monstr\u00e3o. Mais detalhes vir\u00e3o ap\u00f3s 20/03.","title":"Extras"},{"location":"projetos/projeto-pfe/","text":"Projeto semestral - Aloca\u00e7\u00e3o de alunos para o PFE \u00b6 Neste semeste trabalharemos com um problema bastante familiar para os alunos do 8/9 semestre: a atribui\u00e7\u00e3o de alunos a projetos no Projeto Final de Engenharia. Cada aluno escolhe cinco op\u00e7\u00f5es de projetos de acordo com sua prefer\u00eancia. Cada projeto receber\u00e1 exatamente tr\u00eas alunos. Uma solu\u00e7\u00e3o para este problema \u00e9 uma atribui\u00e7\u00e3o de tr\u00eas alunos para cada projeto. Claramente algumas solu\u00e7\u00f5es s\u00e3o melhores pois maior quantidade de alunos est\u00e1 alocada em projetos que tem maior prefer\u00eancia. Para quantificar esta qualidade de cada solu\u00e7\u00e3o vamos adotar a seguinte estrat\u00e9gia: 5^2 = 25 5^2 = 25 se foi colocado na primeira op\u00e7\u00e3o .... 2^2 = 4 2^2 = 4 se foi colocado em sua quarta op\u00e7\u00e3o 1 1 se foi colocado em sua \u00faltima op\u00e7\u00e3o 0 0 se n\u00e3o foi poss\u00edvel coloc\u00e1-lo em nenhuma de suas op\u00e7\u00f5es. a satisfa\u00e7\u00e3o \"global\" de uma solu\u00e7\u00e3o \u00e9 a soma da satisfa\u00e7\u00e3o individual de todos alunos. Desta maneira, gostar\u00edamos de encontrar a melhor solu\u00e7\u00e3o (a que possui maior satisfa\u00e7\u00e3o global) dados o n\u00famero de alunos, o n\u00famero de projetos e at\u00e9 5 op\u00e7\u00f5es de projetos em ordem de prefer\u00eancia para cada aluno. Justificativa \u00b6 Apesar de parecer simples, este problema \u00e9 NP-completo : n\u00e3o existe um m\u00e9todo que encontra a solu\u00e7\u00e3o com maior satisfa\u00e7\u00e3o global em tempo polinomial. Al\u00e9m disso, n\u00e3o existe uma maneira que verifique se uma solu\u00e7\u00e3o \u00e9 a melhor poss\u00edvel em tempo polinomial. Ou seja, trabalhar com este problema invariavelmente envolver\u00e1 enumerar todas as possibilidades. Claramente este \u00e9 um problema onde SuperComputa\u00e7\u00e3o \u00e9 necess\u00e1ria! Veremos que t\u00e9cnicas de computa\u00e7\u00e3o paralela podem diminuir consideravelmente o tempo de execu\u00e7\u00e3o de nosso programa. Outra fonte de ideias para acelerar a resolu\u00e7\u00e3o deste problema \u00e9 a utiliza\u00e7\u00e3o de t\u00e9cnicas de otimiza\u00e7\u00e3o discreta, que s\u00e3o nada mais do que explorar alguma caracter\u00edstica do problema que estamos tratando para melhorar nossas solu\u00e7\u00f5es. Podemos us\u00e1-las para encontrar boas solu\u00e7\u00f5es sem enumerar todas ou para evitar enumerar solu\u00e7\u00f5es que com certeza n\u00e3o s\u00e3o as \u00f3timas. Por\u00e9m, nem sempre \u00e9 f\u00e1cil paralelizar estas t\u00e9cnicas e este ser\u00e1 um dos desafios dos projetos deste semestre. Entrada e sa\u00edda \u00b6 O formato de entrada do programa estar\u00e1 no formato abaixo. n_alunos n_projetos p1 p2 p3 p4 p5 ..... # repetido n_alunos vezes n_alunos \u00e9 o n\u00famero de alunos n_projetos \u00e9 o n\u00famero de projetos existentes cada linha seguinte representa as cinco prioridades de um aluno. p1, ..., p5 \u00e9 um n\u00famero entre 0 e n_projetos-1 , sem repeti\u00e7\u00f5es A sa\u00edda do programa dever\u00e1 estar no formato abaixo. satisfacao opt pa1 pa2 pa3 ... pa(n_alunos) satisfacao opt \u00e9 1 se a solu\u00e7\u00e3o encontrada \u00e9 a melhor poss\u00edvel, 0 caso contr\u00e1rio pa(i) cont\u00e9m a qual projeto o aluno i foi atribu\u00eddo A pasta code/projeto cont\u00e9m exemplos de entradas e sa\u00edda esperadas. Seu programa dever\u00e1 funcionar com estas entradas e produzir sa\u00eddas exatamente neste formato. Avisos Se existirem duas solu\u00e7\u00f5es com mesma satisfa\u00e7\u00e3o qualquer uma pode ser retornada. Informa\u00e7\u00f5es de debug devem ser enviadas para a sa\u00edda de erros ( std::cerr ). A sa\u00edda de seu programa dever\u00e1 estar exatamente no formato mostrado na se\u00e7\u00e3o anterior. Simplifica\u00e7\u00f5es: \u00b6 Seu programa pode assumir o seguinte: n_alunos \u00e9 divis\u00edvel por 3 n_projetos \u00e9 exatamente n_alunos/3 Isto facilita muito o problema, pois nunca conseguimos montar uma solu\u00e7\u00e3o inv\u00e1lida nem precisamos levar em conta a distribui\u00e7\u00e3o de alunos ao criar solu\u00e7\u00f5es. Entregas \u00b6 Os projetos da disciplina envolver\u00e3o resolver este problema usando diferentes tecnologias e iremos comparar os desempenhos obtidos com cada uma.","title":"Projeto semestral - Aloca\u00e7\u00e3o de alunos para o PFE"},{"location":"projetos/projeto-pfe/#projeto-semestral-alocacao-de-alunos-para-o-pfe","text":"Neste semeste trabalharemos com um problema bastante familiar para os alunos do 8/9 semestre: a atribui\u00e7\u00e3o de alunos a projetos no Projeto Final de Engenharia. Cada aluno escolhe cinco op\u00e7\u00f5es de projetos de acordo com sua prefer\u00eancia. Cada projeto receber\u00e1 exatamente tr\u00eas alunos. Uma solu\u00e7\u00e3o para este problema \u00e9 uma atribui\u00e7\u00e3o de tr\u00eas alunos para cada projeto. Claramente algumas solu\u00e7\u00f5es s\u00e3o melhores pois maior quantidade de alunos est\u00e1 alocada em projetos que tem maior prefer\u00eancia. Para quantificar esta qualidade de cada solu\u00e7\u00e3o vamos adotar a seguinte estrat\u00e9gia: 5^2 = 25 5^2 = 25 se foi colocado na primeira op\u00e7\u00e3o .... 2^2 = 4 2^2 = 4 se foi colocado em sua quarta op\u00e7\u00e3o 1 1 se foi colocado em sua \u00faltima op\u00e7\u00e3o 0 0 se n\u00e3o foi poss\u00edvel coloc\u00e1-lo em nenhuma de suas op\u00e7\u00f5es. a satisfa\u00e7\u00e3o \"global\" de uma solu\u00e7\u00e3o \u00e9 a soma da satisfa\u00e7\u00e3o individual de todos alunos. Desta maneira, gostar\u00edamos de encontrar a melhor solu\u00e7\u00e3o (a que possui maior satisfa\u00e7\u00e3o global) dados o n\u00famero de alunos, o n\u00famero de projetos e at\u00e9 5 op\u00e7\u00f5es de projetos em ordem de prefer\u00eancia para cada aluno.","title":"Projeto semestral - Aloca\u00e7\u00e3o de alunos para o PFE"},{"location":"projetos/projeto-pfe/#justificativa","text":"Apesar de parecer simples, este problema \u00e9 NP-completo : n\u00e3o existe um m\u00e9todo que encontra a solu\u00e7\u00e3o com maior satisfa\u00e7\u00e3o global em tempo polinomial. Al\u00e9m disso, n\u00e3o existe uma maneira que verifique se uma solu\u00e7\u00e3o \u00e9 a melhor poss\u00edvel em tempo polinomial. Ou seja, trabalhar com este problema invariavelmente envolver\u00e1 enumerar todas as possibilidades. Claramente este \u00e9 um problema onde SuperComputa\u00e7\u00e3o \u00e9 necess\u00e1ria! Veremos que t\u00e9cnicas de computa\u00e7\u00e3o paralela podem diminuir consideravelmente o tempo de execu\u00e7\u00e3o de nosso programa. Outra fonte de ideias para acelerar a resolu\u00e7\u00e3o deste problema \u00e9 a utiliza\u00e7\u00e3o de t\u00e9cnicas de otimiza\u00e7\u00e3o discreta, que s\u00e3o nada mais do que explorar alguma caracter\u00edstica do problema que estamos tratando para melhorar nossas solu\u00e7\u00f5es. Podemos us\u00e1-las para encontrar boas solu\u00e7\u00f5es sem enumerar todas ou para evitar enumerar solu\u00e7\u00f5es que com certeza n\u00e3o s\u00e3o as \u00f3timas. Por\u00e9m, nem sempre \u00e9 f\u00e1cil paralelizar estas t\u00e9cnicas e este ser\u00e1 um dos desafios dos projetos deste semestre.","title":"Justificativa"},{"location":"projetos/projeto-pfe/#entrada-e-saida","text":"O formato de entrada do programa estar\u00e1 no formato abaixo. n_alunos n_projetos p1 p2 p3 p4 p5 ..... # repetido n_alunos vezes n_alunos \u00e9 o n\u00famero de alunos n_projetos \u00e9 o n\u00famero de projetos existentes cada linha seguinte representa as cinco prioridades de um aluno. p1, ..., p5 \u00e9 um n\u00famero entre 0 e n_projetos-1 , sem repeti\u00e7\u00f5es A sa\u00edda do programa dever\u00e1 estar no formato abaixo. satisfacao opt pa1 pa2 pa3 ... pa(n_alunos) satisfacao opt \u00e9 1 se a solu\u00e7\u00e3o encontrada \u00e9 a melhor poss\u00edvel, 0 caso contr\u00e1rio pa(i) cont\u00e9m a qual projeto o aluno i foi atribu\u00eddo A pasta code/projeto cont\u00e9m exemplos de entradas e sa\u00edda esperadas. Seu programa dever\u00e1 funcionar com estas entradas e produzir sa\u00eddas exatamente neste formato. Avisos Se existirem duas solu\u00e7\u00f5es com mesma satisfa\u00e7\u00e3o qualquer uma pode ser retornada. Informa\u00e7\u00f5es de debug devem ser enviadas para a sa\u00edda de erros ( std::cerr ). A sa\u00edda de seu programa dever\u00e1 estar exatamente no formato mostrado na se\u00e7\u00e3o anterior.","title":"Entrada e sa\u00edda"},{"location":"projetos/projeto-pfe/#simplificacoes","text":"Seu programa pode assumir o seguinte: n_alunos \u00e9 divis\u00edvel por 3 n_projetos \u00e9 exatamente n_alunos/3 Isto facilita muito o problema, pois nunca conseguimos montar uma solu\u00e7\u00e3o inv\u00e1lida nem precisamos levar em conta a distribui\u00e7\u00e3o de alunos ao criar solu\u00e7\u00f5es.","title":"Simplifica\u00e7\u00f5es:"},{"location":"projetos/projeto-pfe/#entregas","text":"Os projetos da disciplina envolver\u00e3o resolver este problema usando diferentes tecnologias e iremos comparar os desempenhos obtidos com cada uma.","title":"Entregas"}]}